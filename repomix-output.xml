This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  .env.example
.cursor/
  mcp.json
app/
  __tests__/
    README.md
  components/
    billing/
      index.ts
      PlanCard.tsx
      PlanSelector.tsx
      QuotaProgressBar.tsx
      UsageAlertBanner.tsx
      UsageDashboard.tsx
    generate/
      templates/
        template-data.ts
      AdvancedOptions.tsx
      CodePreview.tsx
      EmptyState.tsx
      GenerateActions.tsx
      GenerateInputColumn.tsx
      GenerateLayout.tsx
      GeneratePreviewColumn.tsx
      LoadingState.tsx
      PromptExamples.tsx
      PromptInput.tsx
      SaveTemplateModal.tsx
      SectionNameInput.tsx
      SectionTypeSelector.tsx
      TemplateSuggestions.tsx
      ThemeSelector.tsx
    generations/
      DeleteConfirmModal.tsx
      GenerationsEmptyState.tsx
      index.ts
    home/
      FeatureNav.tsx
      index.ts
      QuickStats.tsx
      SetupGuide.tsx
    preview/
      drops/
        base/
          ShopifyDrop.ts
        ArticleDrop.ts
        BlockDrop.ts
        CartDrop.ts
        CollectionDrop.ts
        CollectionsDrop.ts
        CustomerDrop.ts
        ForloopDrop.ts
        ImageDrop.ts
        index.ts
        MediaDrop.ts
        PaginateDrop.ts
        ProductDrop.ts
        RequestDrop.ts
        RoutesDrop.ts
        ShopDrop.ts
        ThemeDrop.ts
        VariantDrop.ts
      hooks/
        useLiquidRenderer.ts
        usePreviewMessaging.ts
        useResourceDetection.ts
        useResourceFetcher.ts
      mockData/
        index.ts
        types.ts
      schema/
        __tests__/
          parseSchema.test.ts
        index.ts
        parseSchema.ts
        SchemaTypes.ts
      settings/
        ArticleSetting.tsx
        BlogSetting.tsx
        CheckboxSetting.tsx
        CollectionListSetting.tsx
        CollectionSetting.tsx
        ColorSetting.tsx
        FontPickerSetting.tsx
        ImagePickerModal.tsx
        ImageSetting.tsx
        index.ts
        LinkListSetting.tsx
        NumberSetting.tsx
        PageSetting.tsx
        ProductListSetting.tsx
        ProductSetting.tsx
        RadioSetting.tsx
        SelectSetting.tsx
        SettingField.tsx
        SettingsPanel.tsx
        TextAlignmentSetting.tsx
        TextSetting.tsx
        VideoSetting.tsx
        VideoUrlSetting.tsx
      utils/
        __tests__/
          colorFilters.test.ts
          fontFilters.test.ts
          liquidFilters.test.ts
          liquidTags.test.ts
          mediaFilters.test.ts
          metafieldFilters.test.ts
          utilityFilters.test.ts
        buildPreviewContext.ts
        colorFilters.ts
        fontFilters.ts
        htmlEscape.ts
        liquidFilters.ts
        liquidTags.ts
        mediaFilters.ts
        metafieldFilters.ts
        utilityFilters.ts
      EmptyPreviewState.tsx
      index.ts
      PreviewErrorBoundary.tsx
      PreviewFrame.tsx
      PreviewSkeleton.tsx
      PreviewToolbar.tsx
      ResourceSelector.tsx
      SectionPreview.tsx
      SelectedResourceDisplay.tsx
      types.ts
    sections/
      DeleteConfirmModal.tsx
      HistoryPreviewModal.tsx
      HistoryTable.tsx
      index.ts
      SectionsEmptyState.tsx
    shared/
      Banner.tsx
      Button.tsx
      Card.tsx
      EmptyState.tsx
      FilterButtonGroup.tsx
    templates/
      index.ts
      TemplateCard.tsx
      TemplateEditorModal.tsx
      TemplateGrid.tsx
    index.ts
  data/
    default-templates.ts
  routes/
    _index/
      route.tsx
      styles.module.css
    auth.login/
      error.server.tsx
      route.tsx
    api.files.tsx
    app._index.tsx
    app.additional.tsx
    app.api.resource.tsx
    app.billing.tsx
    app.sections._index.tsx
    app.sections.$id.tsx
    app.sections.new.tsx
    app.templates.tsx
    app.tsx
    auth.$.tsx
    webhooks.app.scopes_update.tsx
    webhooks.app.subscriptions_update.tsx
    webhooks.app.uninstalled.tsx
  services/
    adapters/
      ai-adapter.ts
      shopify-data-adapter.ts
      theme-adapter.ts
    flags/
      feature-flags.ts
      flag-utils.ts
    ai.server.ts
    billing.server.ts
    files.server.ts
    section.server.ts
    settings.server.ts
    shopify-data.server.ts
    template-seeder.server.ts
    template.server.ts
    theme.server.ts
    usage-tracking.server.ts
  types/
    billing.ts
    index.ts
    service.types.ts
    shopify-api.types.ts
  db.server.ts
  entry.server.tsx
  globals.d.ts
  root.tsx
  routes.ts
  shopify.server.ts
extensions/
  .gitkeep
prisma/
  schema.prisma
  seed-plans.ts
public/
  images/
    onboarding/
      generate-section.svg
      save-template.svg
      view-history.svg
  favicon.ico
.dockerignore
.editorconfig
.eslintignore
.eslintrc.cjs
.gitignore
.graphqlrc.ts
.mcp.json
.npmrc
.prettierignore
.repomixignore
CHANGELOG.md
CLAUDE.md
Dockerfile
env.d.ts
jest.config.cjs
jest.setup.cjs
package.json
README.md
shopify.app.toml
shopify.web.toml
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/components/preview/drops/MediaDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';

/**
 * Shopify Media Drop
 * Provides access to media objects (images, videos, 3D models) in Liquid templates
 */

interface MediaData {
  id: number;
  media_type: 'image' | 'video' | 'external_video' | 'model';
  position: number;
  alt?: string;
  src?: string;
  preview_image?: { src: string; width: number; height: number };
  sources?: Array<{ url: string; mime_type: string; width: number; height: number }>;
  host?: string;
  embed_url?: string;
}

export class MediaDrop extends ShopifyDrop {
  private media: MediaData;

  constructor(media: MediaData) {
    super();
    this.media = media;
  }

  get id(): number {
    return this.media.id;
  }

  get media_type(): string {
    return this.media.media_type;
  }

  get position(): number {
    return this.media.position;
  }

  get alt(): string {
    return this.media.alt || '';
  }

  get preview_image(): { src: string; width: number; height: number } | null {
    return this.media.preview_image || null;
  }

  // For images
  get src(): string {
    return this.media.src || '';
  }

  // For videos
  get sources(): Array<{ url: string; mime_type: string }> {
    return this.media.sources || [];
  }

  // For external videos
  get host(): string {
    return this.media.host || '';
  }

  get embed_url(): string {
    return this.media.embed_url || '';
  }

  /** Returns object representation for Liquid rendering */
  toLiquidDrop(): Record<string, unknown> {
    return {
      id: this.id,
      media_type: this.media_type,
      position: this.position,
      alt: this.alt,
      src: this.src,
      preview_image: this.preview_image,
      sources: this.sources,
      host: this.host,
      embed_url: this.embed_url,
    };
  }
}
</file>

<file path="app/components/preview/utils/__tests__/fontFilters.test.ts">
import { fontFilters } from '../fontFilters';

describe('fontFilters', () => {
  describe('font_face', () => {
    it('generates @font-face CSS', () => {
      const result = fontFilters.font_face({
        family: 'Roboto',
        weight: 400,
        style: 'normal',
      });
      expect(result).toContain('@font-face');
      expect(result).toContain('font-family: "Roboto"');
      expect(result).toContain('font-weight: 400');
      expect(result).toContain('font-style: normal');
      expect(result).toContain('font-display: swap');
    });

    it('uses defaults for missing properties', () => {
      const result = fontFilters.font_face({});
      expect(result).toContain('font-family: "sans-serif"');
      expect(result).toContain('font-weight: 400');
      expect(result).toContain('font-style: normal');
    });

    it('returns empty string for null', () => {
      expect(fontFilters.font_face(null)).toBe('');
    });
  });

  describe('font_url', () => {
    it('generates font URL with default woff2 format', () => {
      const result = fontFilters.font_url({ family: 'Roboto' });
      expect(result).toBe('https://fonts.shopifycdn.com/preview/roboto.woff2');
    });

    it('generates font URL with specified format', () => {
      const result = fontFilters.font_url({ family: 'Open Sans' }, 'woff');
      expect(result).toBe('https://fonts.shopifycdn.com/preview/open-sans.woff');
    });

    it('uses arial as default family', () => {
      const result = fontFilters.font_url({});
      expect(result).toBe('https://fonts.shopifycdn.com/preview/arial.woff2');
    });

    it('returns empty string for null', () => {
      expect(fontFilters.font_url(null)).toBe('');
    });
  });

  describe('font_modify', () => {
    it('modifies weight with number', () => {
      const result = fontFilters.font_modify({ family: 'Roboto', weight: 400 }, 'weight', 700);
      expect(result.weight).toBe(700);
    });

    it('modifies weight with string bold', () => {
      const result = fontFilters.font_modify({ family: 'Roboto' }, 'weight', 'bold');
      expect(result.weight).toBe(700);
    });

    it('modifies weight with string normal', () => {
      const result = fontFilters.font_modify({ family: 'Roboto', weight: 700 }, 'weight', 'normal');
      expect(result.weight).toBe(400);
    });

    it('modifies weight with numeric string', () => {
      const result = fontFilters.font_modify({ family: 'Roboto' }, 'weight', '600');
      expect(result.weight).toBe(600);
    });

    it('modifies style', () => {
      const result = fontFilters.font_modify({ family: 'Roboto' }, 'style', 'italic');
      expect(result.style).toBe('italic');
    });

    it('preserves other properties', () => {
      const result = fontFilters.font_modify({ family: 'Roboto', weight: 400 }, 'style', 'italic');
      expect(result.family).toBe('Roboto');
      expect(result.weight).toBe(400);
    });

    it('returns default for null input', () => {
      const result = fontFilters.font_modify(null, 'weight', 700);
      expect(result.family).toBe('sans-serif');
    });
  });
});
</file>

<file path="app/components/preview/utils/__tests__/mediaFilters.test.ts">
import { mediaFilters } from '../mediaFilters';

describe('mediaFilters', () => {
  describe('image_tag', () => {
    it('generates img tag from URL string', () => {
      const result = mediaFilters.image_tag('https://example.com/image.jpg');
      expect(result).toBe('<img src="https://example.com/image.jpg" alt="">');
    });

    it('generates img tag from image object with src', () => {
      const result = mediaFilters.image_tag({ src: 'https://example.com/image.jpg', alt: 'Test image' });
      expect(result).toBe('<img src="https://example.com/image.jpg" alt="Test image">');
    });

    it('generates img tag from image object with url', () => {
      const result = mediaFilters.image_tag({ url: 'https://example.com/image.jpg' });
      expect(result).toBe('<img src="https://example.com/image.jpg" alt="">');
    });

    it('uses placeholder for null/undefined', () => {
      const result = mediaFilters.image_tag(null);
      expect(result).toContain('src="data:image/svg+xml');
    });

    it('applies optional attributes', () => {
      const result = mediaFilters.image_tag('https://example.com/image.jpg', {
        class: 'product-image',
        loading: 'lazy',
        width: 300,
        height: 200,
      });
      expect(result).toContain('class="product-image"');
      expect(result).toContain('loading="lazy"');
      expect(result).toContain('width="300"');
      expect(result).toContain('height="200"');
    });

    it('overrides alt with option', () => {
      const result = mediaFilters.image_tag({ src: 'image.jpg', alt: 'Original' }, { alt: 'Override' });
      expect(result).toContain('alt="Override"');
    });
  });

  describe('video_tag', () => {
    it('generates video tag with src', () => {
      const result = mediaFilters.video_tag({ src: 'video.mp4' });
      expect(result).toContain('<video');
      expect(result).toContain('src="video.mp4"');
      expect(result).toContain('controls');
    });

    it('generates video tag with sources array', () => {
      const result = mediaFilters.video_tag({
        sources: [
          { url: 'video.webm', mime_type: 'video/webm' },
          { url: 'video.mp4', mime_type: 'video/mp4' },
        ],
      });
      expect(result).toContain('<source src="video.webm" type="video/webm">');
      expect(result).toContain('<source src="video.mp4" type="video/mp4">');
    });

    it('applies video options', () => {
      const result = mediaFilters.video_tag({ src: 'video.mp4' }, { autoplay: true, loop: true, muted: true });
      expect(result).toContain('autoplay');
      expect(result).toContain('loop');
      expect(result).toContain('muted');
    });

    it('returns empty string for null', () => {
      expect(mediaFilters.video_tag(null)).toBe('');
    });
  });

  describe('external_video_tag', () => {
    it('generates YouTube iframe', () => {
      const result = mediaFilters.external_video_tag({ host: 'youtube', id: 'abc123' });
      expect(result).toContain('<iframe');
      expect(result).toContain('https://www.youtube.com/embed/abc123');
      expect(result).toContain('external-video--youtube');
    });

    it('generates Vimeo iframe', () => {
      const result = mediaFilters.external_video_tag({ host: 'vimeo', id: '12345' });
      expect(result).toContain('https://player.vimeo.com/video/12345');
      expect(result).toContain('external-video--vimeo');
    });

    it('uses embed_url if provided', () => {
      const result = mediaFilters.external_video_tag({ embed_url: 'https://custom.url/embed' });
      expect(result).toContain('https://custom.url/embed');
    });

    it('returns empty string for null', () => {
      expect(mediaFilters.external_video_tag(null)).toBe('');
    });
  });

  describe('external_video_url', () => {
    it('returns YouTube embed URL', () => {
      expect(mediaFilters.external_video_url({ host: 'youtube', id: 'abc123' })).toBe(
        'https://www.youtube.com/embed/abc123'
      );
    });

    it('returns Vimeo embed URL', () => {
      expect(mediaFilters.external_video_url({ host: 'vimeo', id: '12345' })).toBe(
        'https://player.vimeo.com/video/12345'
      );
    });

    it('returns embed_url if provided', () => {
      expect(mediaFilters.external_video_url({ embed_url: 'https://custom.url' })).toBe('https://custom.url');
    });

    it('defaults to YouTube', () => {
      expect(mediaFilters.external_video_url({ id: 'xyz' })).toBe('https://www.youtube.com/embed/xyz');
    });
  });

  describe('model_viewer_tag', () => {
    it('generates model-viewer tag', () => {
      const result = mediaFilters.model_viewer_tag({ src: 'model.glb', alt: 'Product 3D' });
      expect(result).toContain('<model-viewer');
      expect(result).toContain('src="model.glb"');
      expect(result).toContain('alt="Product 3D"');
      expect(result).toContain('camera-controls');
      expect(result).toContain('auto-rotate');
    });

    it('uses default alt for missing', () => {
      const result = mediaFilters.model_viewer_tag({ src: 'model.glb' });
      expect(result).toContain('alt="3D Model"');
    });

    it('returns empty string for null', () => {
      expect(mediaFilters.model_viewer_tag(null)).toBe('');
    });
  });

  describe('media_tag', () => {
    it('renders image by default', () => {
      const result = mediaFilters.media_tag({ src: 'image.jpg' });
      expect(result).toContain('<img');
    });

    it('renders video for media_type video', () => {
      const result = mediaFilters.media_tag({ media_type: 'video', src: 'video.mp4' });
      expect(result).toContain('<video');
    });

    it('renders external video', () => {
      const result = mediaFilters.media_tag({ media_type: 'external_video', host: 'youtube', id: 'abc' });
      expect(result).toContain('<iframe');
    });

    it('renders model viewer', () => {
      const result = mediaFilters.media_tag({ media_type: 'model', src: 'model.glb' });
      expect(result).toContain('<model-viewer');
    });

    it('returns empty string for null', () => {
      expect(mediaFilters.media_tag(null)).toBe('');
    });
  });

  describe('placeholder_svg_tag', () => {
    it('generates product placeholder (1:1)', () => {
      const result = mediaFilters.placeholder_svg_tag('product');
      expect(result).toContain('viewBox="0 0 300 300"');
      expect(result).toContain('placeholder-svg--product');
    });

    it('generates collection placeholder (4:3)', () => {
      const result = mediaFilters.placeholder_svg_tag('collection');
      expect(result).toContain('viewBox="0 0 300 225"');
      expect(result).toContain('placeholder-svg--collection');
    });

    it('generates image placeholder (16:9)', () => {
      const result = mediaFilters.placeholder_svg_tag('image');
      expect(result).toContain('viewBox="0 0 300 169"');
    });

    it('defaults to 1:1 for unknown type', () => {
      const result = mediaFilters.placeholder_svg_tag('unknown');
      expect(result).toContain('viewBox="0 0 300 300"');
    });
  });
});
</file>

<file path="app/components/preview/utils/__tests__/metafieldFilters.test.ts">
import { metafieldFilters } from '../metafieldFilters';

describe('metafieldFilters', () => {
  describe('metafield_tag', () => {
    it('renders single line text', () => {
      const result = metafieldFilters.metafield_tag({
        value: 'Hello World',
        type: 'single_line_text_field',
      });
      expect(result).toBe('<span class="metafield metafield--text">Hello World</span>');
    });

    it('renders multi line text', () => {
      const result = metafieldFilters.metafield_tag({
        value: 'Line 1\nLine 2',
        type: 'multi_line_text_field',
      });
      expect(result).toContain('metafield--text');
    });

    it('renders rich text as div', () => {
      const result = metafieldFilters.metafield_tag({
        value: '<p>Rich content</p>',
        type: 'rich_text_field',
      });
      expect(result).toBe('<div class="metafield metafield--rich-text"><p>Rich content</p></div>');
    });

    it('renders URL as link', () => {
      const result = metafieldFilters.metafield_tag({
        value: 'https://example.com',
        type: 'url',
      });
      expect(result).toContain('<a href="https://example.com"');
      expect(result).toContain('metafield--url');
    });

    it('renders color as span with background', () => {
      const result = metafieldFilters.metafield_tag({
        value: '#ff0000',
        type: 'color',
      });
      expect(result).toContain('style="background-color: #ff0000"');
      expect(result).toContain('metafield--color');
    });

    it('renders rating with stars', () => {
      const result = metafieldFilters.metafield_tag({
        value: { value: 3, scale_max: 5 },
        type: 'rating',
      });
      expect(result).toContain('\u2605\u2605\u2605\u2606\u2606');
      expect(result).toContain('aria-label="3 out of 5"');
    });

    it('renders image file reference', () => {
      const result = metafieldFilters.metafield_tag({
        value: { url: 'https://example.com/image.jpg', alt: 'Test' },
        type: 'file_reference',
      });
      expect(result).toContain('<img');
      expect(result).toContain('src="https://example.com/image.jpg"');
      expect(result).toContain('alt="Test"');
    });

    it('renders non-image file as download link', () => {
      const result = metafieldFilters.metafield_tag({
        value: { url: 'https://example.com/file.pdf', alt: 'Manual' },
        type: 'file_reference',
      });
      expect(result).toContain('<a href="https://example.com/file.pdf"');
      expect(result).toContain('>Manual</a>');
    });

    it('renders product reference as link', () => {
      const result = metafieldFilters.metafield_tag({
        value: { title: 'Related Product', url: '/products/related' },
        type: 'product_reference',
      });
      expect(result).toContain('<a href="/products/related"');
      expect(result).toContain('>Related Product</a>');
    });

    it('renders boolean as Yes/No', () => {
      expect(metafieldFilters.metafield_tag({ value: true, type: 'boolean' })).toBe('Yes');
      expect(metafieldFilters.metafield_tag({ value: false, type: 'boolean' })).toBe('No');
    });

    it('renders number', () => {
      const result = metafieldFilters.metafield_tag({
        value: 42,
        type: 'number_integer',
      });
      expect(result).toBe('<span class="metafield metafield--number">42</span>');
    });

    it('renders date with time tag', () => {
      const result = metafieldFilters.metafield_tag({
        value: '2024-01-15',
        type: 'date',
      });
      expect(result).toContain('<time datetime="2024-01-15"');
      expect(result).toContain('metafield--date');
    });

    it('renders JSON as pre with escaped HTML', () => {
      const result = metafieldFilters.metafield_tag({
        value: { key: 'value' },
        type: 'json',
      });
      expect(result).toContain('<pre class="metafield metafield--json">');
      // JSON is HTML-escaped for safety (quotes become &quot;)
      expect(result).toContain('&quot;key&quot;');
      expect(result).toContain('&quot;value&quot;');
    });

    it('escapes HTML in text values', () => {
      const result = metafieldFilters.metafield_tag({
        value: '<script>alert("xss")</script>',
        type: 'single_line_text_field',
      });
      expect(result).not.toContain('<script>');
      expect(result).toContain('&lt;script&gt;');
    });

    it('returns empty string for null', () => {
      expect(metafieldFilters.metafield_tag(null)).toBe('');
    });
  });

  describe('metafield_text', () => {
    it('returns text value as string', () => {
      const result = metafieldFilters.metafield_text({
        value: 'Plain text',
        type: 'single_line_text_field',
      });
      expect(result).toBe('Plain text');
    });

    it('returns rating as fraction', () => {
      const result = metafieldFilters.metafield_text({
        value: { value: 4, scale_max: 5 },
        type: 'rating',
      });
      expect(result).toBe('4/5');
    });

    it('returns file URL', () => {
      const result = metafieldFilters.metafield_text({
        value: { url: 'https://example.com/file.pdf' },
        type: 'file_reference',
      });
      expect(result).toBe('https://example.com/file.pdf');
    });

    it('returns reference title', () => {
      const result = metafieldFilters.metafield_text({
        value: { title: 'Product Name' },
        type: 'product_reference',
      });
      expect(result).toBe('Product Name');
    });

    it('returns formatted date', () => {
      const result = metafieldFilters.metafield_text({
        value: '2024-01-15',
        type: 'date',
      });
      expect(result).toMatch(/\d{1,2}\/\d{1,2}\/\d{4}/);
    });

    it('returns stringified JSON', () => {
      const result = metafieldFilters.metafield_text({
        value: { foo: 'bar' },
        type: 'json',
      });
      expect(result).toBe('{"foo":"bar"}');
    });

    it('returns empty string for null', () => {
      expect(metafieldFilters.metafield_text(null)).toBe('');
    });
  });
});
</file>

<file path="app/components/preview/utils/__tests__/utilityFilters.test.ts">
import { utilityFilters } from '../utilityFilters';

describe('utilityFilters', () => {
  describe('default', () => {
    it('returns value when not nil', () => {
      expect(utilityFilters.default('hello', 'fallback')).toBe('hello');
      expect(utilityFilters.default(42, 0)).toBe(42);
      expect(utilityFilters.default(true, false)).toBe(true);
    });

    it('returns default for null', () => {
      expect(utilityFilters.default(null, 'fallback')).toBe('fallback');
    });

    it('returns default for undefined', () => {
      expect(utilityFilters.default(undefined, 'fallback')).toBe('fallback');
    });

    it('returns default for empty string', () => {
      expect(utilityFilters.default('', 'fallback')).toBe('fallback');
    });

    it('returns default for false', () => {
      expect(utilityFilters.default(false, true)).toBe(true);
    });

    it('returns 0 when 0 is the value (not default)', () => {
      expect(utilityFilters.default(0, 100)).toBe(0);
    });
  });

  describe('default_errors', () => {
    it('renders error list as ul', () => {
      const result = utilityFilters.default_errors([{ message: 'Error 1' }, { message: 'Error 2' }]);
      expect(result).toContain('<ul class="form-errors">');
      expect(result).toContain('<li>Error 1</li>');
      expect(result).toContain('<li>Error 2</li>');
    });

    it('returns empty string for null', () => {
      expect(utilityFilters.default_errors(null)).toBe('');
    });

    it('returns empty string for non-array', () => {
      expect(utilityFilters.default_errors('not an array')).toBe('');
    });

    it('escapes HTML in error messages', () => {
      const result = utilityFilters.default_errors([{ message: '<script>xss</script>' }]);
      expect(result).not.toContain('<script>');
      expect(result).toContain('&lt;script&gt;');
    });
  });

  describe('default_pagination', () => {
    it('renders pagination with previous and next', () => {
      const result = utilityFilters.default_pagination({
        previous: { url: '/page/1' },
        next: { url: '/page/3' },
      });
      expect(result).toContain('<nav class="pagination">');
      expect(result).toContain('href="/page/1"');
      expect(result).toContain('href="/page/3"');
      expect(result).toContain('Previous');
      expect(result).toContain('Next');
    });

    it('renders pagination parts', () => {
      const result = utilityFilters.default_pagination({
        parts: [
          { url: '/page/1', title: '1', is_link: true },
          { url: '/page/2', title: '2', is_link: false },
          { url: '/page/3', title: '3', is_link: true },
        ],
      });
      expect(result).toContain('<a href="/page/1">1</a>');
      expect(result).toContain('<span class="pagination__current">2</span>');
      expect(result).toContain('<a href="/page/3">3</a>');
    });

    it('returns empty string for null', () => {
      expect(utilityFilters.default_pagination(null)).toBe('');
    });
  });

  describe('highlight', () => {
    it('wraps matching text in mark tags', () => {
      const result = utilityFilters.highlight('Hello World', 'World');
      expect(result).toBe('Hello <mark>World</mark>');
    });

    it('is case insensitive', () => {
      const result = utilityFilters.highlight('Hello World', 'world');
      expect(result).toBe('Hello <mark>World</mark>');
    });

    it('highlights multiple occurrences', () => {
      const result = utilityFilters.highlight('foo bar foo', 'foo');
      expect(result).toBe('<mark>foo</mark> bar <mark>foo</mark>');
    });

    it('escapes regex special characters', () => {
      const result = utilityFilters.highlight('Price: $19.99', '$19.99');
      expect(result).toBe('Price: <mark>$19.99</mark>');
    });

    it('returns original text when no query', () => {
      expect(utilityFilters.highlight('Hello', '')).toBe('Hello');
    });

    it('returns empty string for null text', () => {
      expect(utilityFilters.highlight(null as unknown as string, 'query')).toBe('');
    });
  });

  describe('payment_type_img_url', () => {
    it('returns CDN URL for payment type', () => {
      expect(utilityFilters.payment_type_img_url('visa')).toBe(
        'https://cdn.shopify.com/s/files/1/0000/0001/files/visa.svg'
      );
    });
  });

  describe('payment_type_svg_tag', () => {
    it('returns SVG for known payment types', () => {
      expect(utilityFilters.payment_type_svg_tag('visa')).toContain('VISA');
      expect(utilityFilters.payment_type_svg_tag('mastercard')).toContain('MC');
      expect(utilityFilters.payment_type_svg_tag('american_express')).toContain('AMEX');
      expect(utilityFilters.payment_type_svg_tag('paypal')).toContain('PayPal');
    });

    it('returns generic SVG for unknown types', () => {
      const result = utilityFilters.payment_type_svg_tag('unknown_card');
      expect(result).toContain('unknown_card');
      expect(result).toContain('<svg');
    });
  });

  describe('stylesheet_tag', () => {
    it('generates link tag', () => {
      expect(utilityFilters.stylesheet_tag('/styles/main.css')).toBe(
        '<link rel="stylesheet" href="/styles/main.css" type="text/css">'
      );
    });
  });

  describe('script_tag', () => {
    it('generates script tag', () => {
      expect(utilityFilters.script_tag('/js/app.js')).toBe('<script src="/js/app.js"></script>');
    });
  });

  describe('preload_tag', () => {
    it('generates preload link without as attribute', () => {
      expect(utilityFilters.preload_tag('/styles/main.css')).toBe(
        '<link rel="preload" href="/styles/main.css">'
      );
    });

    it('generates preload link with as attribute', () => {
      expect(utilityFilters.preload_tag('/styles/main.css', 'style')).toBe(
        '<link rel="preload" href="/styles/main.css" as="style">'
      );
    });
  });

  describe('time_tag', () => {
    it('generates time element from string date', () => {
      const result = utilityFilters.time_tag('2024-01-15T10:30:00Z');
      expect(result).toContain('<time datetime=');
      expect(result).toContain('2024-01-15');
    });

    it('generates time element from Date object', () => {
      const result = utilityFilters.time_tag(new Date('2024-01-15T10:30:00Z'));
      expect(result).toContain('<time datetime=');
    });

    it('returns empty string for invalid date', () => {
      expect(utilityFilters.time_tag('invalid')).toBe('');
    });
  });

  describe('weight_with_unit', () => {
    it('converts grams to kg by default', () => {
      expect(utilityFilters.weight_with_unit(1000)).toBe('1.00 kg');
      expect(utilityFilters.weight_with_unit(2500)).toBe('2.50 kg');
    });

    it('converts grams to lb', () => {
      const result = utilityFilters.weight_with_unit(453.592, 'lb');
      expect(result).toMatch(/1\.00 lb/);
    });

    it('converts grams to oz', () => {
      const result = utilityFilters.weight_with_unit(28.3495, 'oz');
      expect(result).toMatch(/1\.00 oz/);
    });

    it('keeps grams when unit is g', () => {
      expect(utilityFilters.weight_with_unit(500, 'g')).toBe('500.00 g');
    });

    it('uses g for unknown units', () => {
      expect(utilityFilters.weight_with_unit(500, 'unknown')).toBe('500.00 g');
    });
  });
});
</file>

<file path="app/components/preview/utils/fontFilters.ts">
/**
 * Shopify Liquid Font Filter Implementations
 * Font manipulation and CSS generation for section preview
 */

interface FontObject {
  family?: string;
  fallback_families?: string;
  weight?: number | string;
  style?: string;
  variants?: Array<{ weight: number; style: string }>;
  src?: string;
}

export const fontFilters = {
  /** Generates @font-face CSS declaration */
  font_face: (font: unknown): string => {
    if (!font) return '';

    const fontObj = font as FontObject;
    const family = fontObj.family || 'sans-serif';
    const weight = fontObj.weight || 400;
    const style = fontObj.style || 'normal';

    // In production, this would generate actual @font-face with src URLs
    return `@font-face {
  font-family: "${family}";
  font-weight: ${weight};
  font-style: ${style};
  font-display: swap;
  src: local("${family}");
}`;
  },

  /** Returns URL to font file */
  font_url: (font: unknown, format?: string): string => {
    if (!font) return '';

    const fontObj = font as FontObject;
    // Return placeholder URL - real implementation would use Shopify CDN
    const family = (fontObj.family || 'arial').toLowerCase().replace(/\s+/g, '-');
    const ext = format || 'woff2';

    return `https://fonts.shopifycdn.com/preview/${family}.${ext}`;
  },

  /** Modifies font properties (weight, style) */
  font_modify: (font: unknown, attribute: string, value: string | number): FontObject => {
    if (!font) return { family: 'sans-serif' };

    const fontObj = { ...(font as FontObject) };

    switch (attribute) {
      case 'weight':
        fontObj.weight =
          typeof value === 'string'
            ? value === 'bold'
              ? 700
              : value === 'normal'
                ? 400
                : parseInt(value)
            : value;
        break;
      case 'style':
        fontObj.style = String(value);
        break;
    }

    return fontObj;
  },
};
</file>

<file path="app/components/preview/utils/htmlEscape.ts">
/**
 * Shared HTML escaping utilities for Liquid filter implementations
 * Prevents XSS by escaping HTML special characters
 */

/**
 * Escapes HTML special characters in a string
 * Use for text content that will be rendered inside HTML elements
 */
export function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/**
 * Escapes HTML attribute values (quotes only)
 * Use for attribute values already within quotes
 */
export function escapeAttr(str: string): string {
  return str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
</file>

<file path="app/components/preview/utils/mediaFilters.ts">
/**
 * Shopify Liquid Media Filter Implementations
 * Media rendering filters for images, videos, 3D models in section preview
 */

import { escapeAttr } from './htmlEscape';

interface ImageOptions {
  class?: string;
  alt?: string;
  loading?: 'lazy' | 'eager';
  width?: number;
  height?: number;
  sizes?: string;
  preload?: boolean;
}

interface VideoOptions {
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
  controls?: boolean;
  poster?: string;
}

// Inline SVG placeholder for missing images (works offline)
const PLACEHOLDER_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 200"><rect fill="#f0f0f0" width="300" height="200"/><text x="150" y="105" text-anchor="middle" fill="#999" font-family="sans-serif">No Image</text></svg>';
const PLACEHOLDER = 'data:image/svg+xml,' + encodeURIComponent(PLACEHOLDER_SVG);

export const mediaFilters = {
  /** Generates an img tag from an image object or URL */
  image_tag: (image: unknown, options: ImageOptions = {}): string => {
    let src = PLACEHOLDER;
    let alt = options.alt || '';

    if (typeof image === 'string') {
      src = image;
    } else if (image && typeof image === 'object') {
      const img = image as { src?: string; url?: string; alt?: string };
      src = img.src || img.url || PLACEHOLDER;
      alt = alt || img.alt || '';
    }

    const attrs: string[] = [
      `src="${escapeAttr(src)}"`,
      `alt="${escapeAttr(alt)}"`,
    ];

    if (options.class) attrs.push(`class="${escapeAttr(options.class)}"`);
    if (options.loading) attrs.push(`loading="${options.loading}"`);
    if (options.width) attrs.push(`width="${options.width}"`);
    if (options.height) attrs.push(`height="${options.height}"`);
    if (options.sizes) attrs.push(`sizes="${escapeAttr(options.sizes)}"`);

    return `<img ${attrs.join(' ')}>`;
  },

  /** Universal media renderer - dispatches to appropriate tag based on media_type */
  media_tag: (media: unknown, _options = {}): string => {
    if (!media) return '';

    const mediaObj = media as {
      media_type?: string;
      src?: string;
      url?: string;
      alt?: string;
      preview_image?: { src: string };
    };

    const type = mediaObj.media_type || 'image';

    switch (type) {
      case 'video':
        return mediaFilters.video_tag(media, {});
      case 'external_video':
        return mediaFilters.external_video_tag(media);
      case 'model':
        return mediaFilters.model_viewer_tag(media);
      default:
        return mediaFilters.image_tag(media, {});
    }
  },

  /** Generates HTML5 video tag with sources */
  video_tag: (video: unknown, options: VideoOptions = {}): string => {
    if (!video) return '';

    const videoObj = video as {
      src?: string;
      sources?: Array<{ url: string; mime_type: string }>;
    };
    const sources = videoObj.sources || [];

    const attrs: string[] = [];
    if (options.autoplay) attrs.push('autoplay');
    if (options.loop) attrs.push('loop');
    if (options.muted) attrs.push('muted');
    if (options.controls !== false) attrs.push('controls');
    if (options.poster) attrs.push(`poster="${escapeAttr(options.poster)}"`);

    if (sources.length > 0) {
      const sourcesTags = sources
        .map((s) => `<source src="${escapeAttr(s.url)}" type="${escapeAttr(s.mime_type)}">`)
        .join('');
      return `<video ${attrs.join(' ')}>${sourcesTags}</video>`;
    }

    return `<video ${attrs.join(' ')} src="${escapeAttr(videoObj.src || '')}"></video>`;
  },

  /** Generates iframe for YouTube/Vimeo embedded videos */
  external_video_tag: (video: unknown): string => {
    if (!video) return '';

    const videoObj = video as { host?: string; id?: string; embed_url?: string };
    const host = videoObj.host || 'youtube';
    const embedUrl = videoObj.embed_url || mediaFilters.external_video_url(video);

    return `<iframe src="${escapeAttr(embedUrl)}" class="external-video external-video--${host}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen loading="lazy"></iframe>`;
  },

  /** Returns the embed URL for external video */
  external_video_url: (video: unknown): string => {
    if (!video) return '';

    const videoObj = video as { host?: string; id?: string; embed_url?: string };

    if (videoObj.embed_url) return videoObj.embed_url;

    const host = videoObj.host || 'youtube';
    const id = videoObj.id || '';

    switch (host) {
      case 'youtube':
        return `https://www.youtube.com/embed/${id}`;
      case 'vimeo':
        return `https://player.vimeo.com/video/${id}`;
      default:
        return '';
    }
  },

  /** Generates model-viewer tag for 3D models */
  model_viewer_tag: (model: unknown): string => {
    if (!model) return '';

    const modelObj = model as { src?: string; alt?: string; poster?: string };

    return `<model-viewer src="${escapeAttr(modelObj.src || '')}" alt="${escapeAttr(modelObj.alt || '3D Model')}" poster="${escapeAttr(modelObj.poster || '')}" camera-controls auto-rotate loading="lazy"></model-viewer>`;
  },

  /** Generates placeholder SVG for different content types */
  placeholder_svg_tag: (type: string): string => {
    const sizes: Record<string, string> = {
      product: '1:1',
      collection: '4:3',
      image: '16:9',
      lifestyle: '3:2',
    };

    const ratio = sizes[type] || '1:1';
    const [w, h] = ratio.split(':').map(Number);
    const width = 300;
    const height = Math.round(width * (h / w));

    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" class="placeholder-svg placeholder-svg--${type}"><rect fill="#f0f0f0" width="${width}" height="${height}"/><text x="${width / 2}" y="${height / 2}" text-anchor="middle" fill="#999" font-family="sans-serif" font-size="14">${type}</text></svg>`;
  },
};
</file>

<file path="app/components/preview/utils/metafieldFilters.ts">
/**
 * Shopify Liquid Metafield Filter Implementations
 * Renders metafield values based on their types
 */

import { escapeHtml } from './htmlEscape';

interface Metafield {
  value: unknown;
  type: string;
  key?: string;
  namespace?: string;
}

interface RatingValue {
  value: number;
  scale_max: number;
}

interface FileReference {
  url?: string;
  alt?: string;
}

interface ResourceReference {
  title?: string;
  url?: string;
}

export const metafieldFilters = {
  /** Renders metafield value as HTML based on its type */
  metafield_tag: (metafield: unknown): string => {
    if (!metafield) return '';

    const mf = metafield as Metafield;
    const value = mf.value;
    const type = mf.type || 'single_line_text_field';

    switch (type) {
      case 'single_line_text_field':
      case 'multi_line_text_field':
        return `<span class="metafield metafield--text">${escapeHtml(String(value ?? ''))}</span>`;

      case 'rich_text_field':
        return `<div class="metafield metafield--rich-text">${value}</div>`;

      case 'url':
        return `<a href="${escapeHtml(String(value ?? ''))}" class="metafield metafield--url">${escapeHtml(String(value ?? ''))}</a>`;

      case 'color':
        return `<span class="metafield metafield--color" style="background-color: ${escapeHtml(String(value ?? ''))}"></span>`;

      case 'rating': {
        const rating = value as RatingValue;
        const filledStars = Math.round(rating.value);
        const emptyStars = rating.scale_max - filledStars;
        const stars = '\u2605'.repeat(filledStars) + '\u2606'.repeat(emptyStars);
        return `<span class="metafield metafield--rating" aria-label="${rating.value} out of ${rating.scale_max}">${stars}</span>`;
      }

      case 'file_reference': {
        const file = value as FileReference;
        if (file.url?.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
          return `<img src="${escapeHtml(file.url)}" alt="${escapeHtml(file.alt || '')}" class="metafield metafield--image">`;
        }
        return `<a href="${escapeHtml(file.url || '')}" class="metafield metafield--file">${escapeHtml(file.alt || 'Download')}</a>`;
      }

      case 'product_reference':
      case 'collection_reference':
      case 'page_reference': {
        const ref = value as ResourceReference;
        return `<a href="${escapeHtml(ref.url || '#')}" class="metafield metafield--reference">${escapeHtml(ref.title || 'Link')}</a>`;
      }

      case 'boolean':
        return value ? 'Yes' : 'No';

      case 'number_integer':
      case 'number_decimal':
        return `<span class="metafield metafield--number">${value}</span>`;

      case 'date':
      case 'date_time': {
        const date = new Date(value as string);
        return `<time datetime="${value}" class="metafield metafield--date">${date.toLocaleDateString()}</time>`;
      }

      case 'json':
        return `<pre class="metafield metafield--json">${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;

      default:
        return String(value ?? '');
    }
  },

  /** Returns metafield value as plain text */
  metafield_text: (metafield: unknown): string => {
    if (!metafield) return '';

    const mf = metafield as Metafield;
    const value = mf.value;
    const type = mf.type || 'single_line_text_field';

    switch (type) {
      case 'rating': {
        const rating = value as RatingValue;
        return `${rating.value}/${rating.scale_max}`;
      }

      case 'file_reference': {
        const file = value as FileReference;
        return file.url || '';
      }

      case 'product_reference':
      case 'collection_reference':
      case 'page_reference': {
        const ref = value as ResourceReference;
        return ref.title || '';
      }

      case 'date':
      case 'date_time':
        return new Date(value as string).toLocaleDateString();

      case 'json':
        return JSON.stringify(value);

      default:
        return String(value ?? '');
    }
  },
};
</file>

<file path="app/components/preview/utils/utilityFilters.ts">
/**
 * Shopify Liquid Utility Filter Implementations
 * General-purpose utility filters for section preview
 */

import { escapeHtml } from './htmlEscape';

interface PaginateObject {
  previous?: { url: string };
  parts?: Array<{ url: string; title: string; is_link: boolean }>;
  next?: { url: string };
}

interface FormError {
  message: string;
}

export const utilityFilters = {
  /** Returns defaultValue if value is nil, false, or empty string */
  default: (value: unknown, defaultValue: unknown): unknown => {
    if (value === null || value === undefined || value === '' || value === false) {
      return defaultValue;
    }
    return value;
  },

  /** Renders form errors as an unordered list */
  default_errors: (errors: unknown): string => {
    if (!errors || !Array.isArray(errors)) return '';

    const errorList = errors as FormError[];
    const items = errorList.map((e) => `<li>${escapeHtml(e.message)}</li>`).join('');
    return `<ul class="form-errors">${items}</ul>`;
  },

  /** Renders default pagination HTML */
  default_pagination: (paginate: unknown): string => {
    if (!paginate) return '';

    const p = paginate as PaginateObject;
    let html = '<nav class="pagination">';

    if (p.previous) {
      html += `<a href="${escapeHtml(p.previous.url)}" class="pagination__prev">Previous</a>`;
    }

    if (p.parts) {
      html += '<span class="pagination__pages">';
      for (const part of p.parts) {
        if (part.is_link) {
          html += `<a href="${escapeHtml(part.url)}">${escapeHtml(part.title)}</a>`;
        } else {
          html += `<span class="pagination__current">${escapeHtml(part.title)}</span>`;
        }
      }
      html += '</span>';
    }

    if (p.next) {
      html += `<a href="${escapeHtml(p.next.url)}" class="pagination__next">Next</a>`;
    }

    html += '</nav>';
    return html;
  },

  /** Highlights search query terms in text */
  highlight: (text: string, query: string): string => {
    if (!text || !query) return text || '';

    const escaped = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escaped})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  },

  /** Returns URL to payment type image */
  payment_type_img_url: (type: string): string => {
    // Return placeholder URL - real implementation uses Shopify CDN
    return `https://cdn.shopify.com/s/files/1/0000/0001/files/${type}.svg`;
  },

  /** Returns inline SVG for payment type icon */
  payment_type_svg_tag: (type: string): string => {
    const icons: Record<string, string> = {
      visa: '<svg viewBox="0 0 38 24"><rect fill="#1434CB" width="38" height="24" rx="3"/><text x="19" y="15" fill="white" text-anchor="middle" font-size="8">VISA</text></svg>',
      mastercard:
        '<svg viewBox="0 0 38 24"><rect fill="#EB001B" width="38" height="24" rx="3"/><circle cx="15" cy="12" r="7" fill="#F79E1B" fill-opacity="0.8"/><text x="19" y="15" fill="white" text-anchor="middle" font-size="6">MC</text></svg>',
      american_express:
        '<svg viewBox="0 0 38 24"><rect fill="#006FCF" width="38" height="24" rx="3"/><text x="19" y="15" fill="white" text-anchor="middle" font-size="6">AMEX</text></svg>',
      paypal:
        '<svg viewBox="0 0 38 24"><rect fill="#003087" width="38" height="24" rx="3"/><text x="19" y="15" fill="white" text-anchor="middle" font-size="6">PayPal</text></svg>',
      shopify_pay:
        '<svg viewBox="0 0 38 24"><rect fill="#5C6AC4" width="38" height="24" rx="3"/><text x="19" y="15" fill="white" text-anchor="middle" font-size="6">Shop</text></svg>',
    };

    return (
      icons[type] ||
      `<svg viewBox="0 0 38 24"><rect fill="#ccc" width="38" height="24" rx="3"/><text x="19" y="15" fill="#666" text-anchor="middle" font-size="6">${escapeHtml(type)}</text></svg>`
    );
  },

  /** Generates link tag for stylesheet */
  stylesheet_tag: (url: string): string => {
    return `<link rel="stylesheet" href="${escapeHtml(url)}" type="text/css">`;
  },

  /** Generates script tag */
  script_tag: (url: string): string => {
    return `<script src="${escapeHtml(url)}"></script>`;
  },

  /** Generates preload link tag */
  preload_tag: (url: string, as?: string): string => {
    const asAttr = as ? ` as="${escapeHtml(as)}"` : '';
    return `<link rel="preload" href="${escapeHtml(url)}"${asAttr}>`;
  },

  /** Generates time element from date */
  time_tag: (date: string | Date, format?: string): string => {
    const d = typeof date === 'string' ? new Date(date) : date;
    if (isNaN(d.getTime())) return '';

    const isoString = d.toISOString();
    const display = format ? d.toLocaleDateString() : d.toLocaleString();
    return `<time datetime="${isoString}">${escapeHtml(display)}</time>`;
  },

  /** Formats weight with unit (grams input, converts to specified unit) */
  weight_with_unit: (grams: number, unit?: string): string => {
    const u = unit || 'kg';
    let value: number;
    let displayUnit: string;

    switch (u) {
      case 'kg':
        value = grams / 1000;
        displayUnit = 'kg';
        break;
      case 'lb':
        value = grams * 0.00220462;
        displayUnit = 'lb';
        break;
      case 'oz':
        value = grams * 0.035274;
        displayUnit = 'oz';
        break;
      default:
        value = grams;
        displayUnit = 'g';
    }

    return `${value.toFixed(2)} ${displayUnit}`;
  },
};
</file>

<file path=".claude/.env.example">
# Claude Code - Global Environment Variables
# Location: .claude/.env
# Priority: LOWEST (overridden by skills/.env and skill-specific .env)
# Scope: Project-wide configuration, global defaults
# Setup: Copy to .claude/.env and configure

# ============================================
# Environment Variable Hierarchy
# ============================================
# Priority order (highest to lowest):
# 1. process.env                    - Runtime environment (HIGHEST)
# 2. .claude/skills/<skill>/.env    - Skill-specific overrides
# 3. .claude/skills/.env            - Shared across all skills
# 4. .claude/.env                   - Global defaults (this file, LOWEST)
#
# All skills use centralized resolver: ~/.claude/scripts/resolve_env.py
# Debug hierarchy: python ~/.claude/scripts/resolve_env.py --show-hierarchy

# ============================================
# Claude Code Notification Hooks
# ============================================
# Discord Webhook URL (for Discord notifications)
# Get from: Server Settings  Integrations  Webhooks  New Webhook
DISCORD_WEBHOOK_URL=

# Telegram Bot Token (for Telegram notifications)
# Get from: @BotFather in Telegram
TELEGRAM_BOT_TOKEN=

# Telegram Chat ID (your chat ID or group ID)
# Get from: https://api.telegram.org/bot<BOT_TOKEN>/getUpdates
TELEGRAM_CHAT_ID=

# ============================================
# AI/ML API Keys (Global Defaults)
# ============================================
# Google Gemini API (for ai-multimodal, docs-seeker skills)
# Get from: https://aistudio.google.com/apikey
GEMINI_API_KEY=

# Vertex AI Configuration (Optional alternative to AI Studio)
# GEMINI_USE_VERTEX=true
# VERTEX_PROJECT_ID=
# VERTEX_LOCATION=us-central1

# OpenAI API Key (if using OpenAI-based skills)
# OPENAI_API_KEY=

# Anthropic API Key (if using Claude API directly)
# ANTHROPIC_API_KEY=

# ============================================
# Development & CI/CD
# ============================================
# NODE_ENV=development
# DEBUG=false
# LOG_LEVEL=info

# ============================================
# Project Configuration
# ============================================
# PROJECT_NAME=claudekit-engineer
# ENVIRONMENT=local

# ============================================
# Example Usage Scenarios
# ============================================
# Scenario 1: Global default for all skills
# .claude/.env (this file):                GEMINI_API_KEY=global-dev-key
# Result: All skills use global-dev-key
#
# Scenario 2: Override for all skills
# .claude/.env (this file):                GEMINI_API_KEY=global-dev-key
# .claude/skills/.env:                     GEMINI_API_KEY=skills-prod-key
# Result: All skills use skills-prod-key
#
# Scenario 3: Skill-specific override
# .claude/.env (this file):                GEMINI_API_KEY=global-key
# .claude/skills/.env:                     GEMINI_API_KEY=shared-key
# .claude/skills/ai-multimodal/.env:       GEMINI_API_KEY=high-quota-key
# Result: ai-multimodal uses high-quota-key, other skills use shared-key
#
# Scenario 4: Runtime testing
# export GEMINI_API_KEY=test-key
# Result: All skills use test-key regardless of config files
#
# Priority: runtime > skill-specific > shared > global (this file)
</file>

<file path=".cursor/mcp.json">
{
  "mcpServers": {
    "shopify-dev-mcp": {
      "command": "npx",
      "args": ["-y", "@shopify/dev-mcp@latest"],
      "env": {
        "POLARIS_UNIFIED": "true",
        "LIQUID": "true"
      }
    }
  }
}
</file>

<file path="app/__tests__/README.md">
# Test Suite Documentation

## Running Tests

```bash
# Run all tests
npm test

# Run with coverage
npm test:coverage

# Run in watch mode
npm test:watch

# Run specific test file
npm test -- app/services/mocks/__tests__/mock-ai.test.ts

# Run tests for specific pattern
npm test -- --testPathPattern=adapter
```

## Test Structure

```
app/
 services/__tests__/      # Service layer tests
    performance.test.ts  # Performance benchmarks
 services/mocks/__tests__/ # Mock service tests
    mock-ai.test.ts
    mock-theme.test.ts
    mock-store.test.ts
 services/adapters/__tests__/ # Adapter pattern tests
     ai-adapter.test.ts
     theme-adapter.test.ts
```

## Current Coverage

- **Total Test Suites**: 6
- **Total Tests**: 41
- **Status**: All passing

### Test Distribution

- Mock Services: 22 tests
  - mock-store: 7 tests
  - mock-ai: 7 tests
  - mock-theme: 8 tests
- Adapters: 12 tests
  - ai-adapter: 3 tests
  - theme-adapter: 5 tests
- Performance: 7 tests

## Coverage Goals

- Overall: 70%+ (configured threshold)
- Services: 90%+
- Adapters: 100%
- Mock implementations: 100%

## Writing Tests

### Unit Tests

Test single functions/methods in isolation:

```typescript
describe('MockStore', () => {
  beforeEach(() => {
    mockStore.reset(); // Reset state before each test
  });

  it('saves section metadata', () => {
    const metadata = mockStore.saveSection('theme1', 'test.liquid', 'content');
    expect(metadata.filename).toBe('test.liquid');
  });
});
```

### Mock Configuration

Tests use mock mode by default (configured in `jest.setup.cjs`):

```typescript
// Mock the config
jest.mock('../../config.server', () => ({
  serviceConfig: {
    aiMode: 'mock',
    themeMode: 'mock',
    enableLogging: false,
    simulateLatency: false,
  },
  logServiceConfig: jest.fn(),
}));
```

### Performance Tests

Performance tests measure execution time without latency simulation:

```typescript
it('generates section in < 100ms (without latency)', async () => {
  const start = Date.now();
  await mockAIService.generateSection('test');
  const duration = Date.now() - start;
  expect(duration).toBeLessThan(100);
});
```

## Test Environment

- **Framework**: Jest v30.2.0
- **Environment**: jsdom (for DOM simulation)
- **TypeScript**: ts-jest for TS support
- **Testing Library**: @testing-library/react v16.3.0

### Polyfills

The test environment includes:
- `TextEncoder`/`TextDecoder` for Node compatibility
- `whatwg-fetch` for fetch API support
- Suppressed console output (log/warn)

## CI/CD Integration

Tests run automatically in CI via GitHub Actions:

```yaml
- name: Run unit tests
  run: npm test -- --coverage
```

Coverage reports are uploaded to Codecov for tracking.

## Best Practices

1. **Reset State**: Always reset mock store before each test
2. **Isolation**: Mock external dependencies (config, services)
3. **Fast Execution**: Disable latency simulation in tests
4. **Descriptive Names**: Use clear, descriptive test names
5. **Arrange-Act-Assert**: Follow AAA pattern
6. **No Side Effects**: Tests should not affect each other

## Troubleshooting

### Tests Timing Out

If tests timeout, check for:
- Missing `await` on async operations
- Infinite loops in code
- Network requests (should be mocked)

### Module Not Found Errors

Check:
- Path aliases in `jest.config.cjs` match `tsconfig.json`
- All imports use correct paths
- Mock declarations come before imports

### Type Errors

Run type checking separately:
```bash
npm run typecheck
```

Jest uses `ts-jest` with relaxed TypeScript config for tests.

## Future Enhancements

- [ ] Add component tests for UI components
- [ ] Add E2E tests with Playwright
- [ ] Add integration tests for route loaders/actions
- [ ] Implement mutation testing
- [ ] Add snapshot testing for generated code
</file>

<file path="app/components/billing/index.ts">
/**
 * Billing Components Exports
 */

export { PlanCard } from "./PlanCard";
export { PlanSelector } from "./PlanSelector";
export { QuotaProgressBar } from "./QuotaProgressBar";
export { UsageAlertBanner } from "./UsageAlertBanner";
export { UsageDashboard } from "./UsageDashboard";
</file>

<file path="app/components/billing/PlanSelector.tsx">
/**
 * Plan Selector Component
 * 3-tier pricing cards with responsive grid layout
 */

import { PlanCard } from "./PlanCard";
import type { PlanConfig, PlanTier } from "../../types/billing";

interface PlanSelectorProps {
  plans: PlanConfig[];
  currentPlan: PlanTier | null;
  onSelect: (planName: PlanTier) => void;
}

export function PlanSelector({ plans, currentPlan, onSelect }: PlanSelectorProps) {
  return (
    <s-section heading="Choose Your Plan" id="plan-selector">
      <s-grid gap="base">
        <s-paragraph color="subdued">
          All plans include unlimited themes, priority support, and 14-day free trial
        </s-paragraph>

        {/* Responsive 3-column grid */}
        <s-grid
          gridTemplateColumns="repeat(auto-fit, minmax(280px, 1fr))"
          gap="base"
        >
          {plans.map(plan => (
            <PlanCard
              key={plan.planName}
              plan={plan}
              isCurrentPlan={currentPlan === plan.planName}
              onSelect={() => onSelect(plan.planName)}
            />
          ))}
        </s-grid>

        {/* Pricing Details */}
        <s-box border="base" borderRadius="base" padding="base" background="subdued">
          <s-grid gap="small-200">
            <s-text type="strong">Pricing Details</s-text>
            <s-paragraph color="subdued">
               Base price charged monthly, usage charges billed at end of cycle
            </s-paragraph>
            <s-paragraph color="subdued">
               Overage charges apply beyond included sections
            </s-paragraph>
            <s-paragraph color="subdued">
               Usage caps prevent unexpected charges
            </s-paragraph>
            <s-paragraph color="subdued">
               Cancel anytime, no refunds for partial months
            </s-paragraph>
          </s-grid>
        </s-box>
      </s-grid>
    </s-section>
  );
}
</file>

<file path="app/components/billing/QuotaProgressBar.tsx">
/**
 * Visual progress indicator for quota usage
 * Shows percentage with dynamic tone (critical/warning/highlight)
 */

interface QuotaProgressBarProps {
  used: number;
  included: number;
  tone?: "critical" | "warning" | "highlight" | "primary" | "success";
}

export function QuotaProgressBar({ used, included, tone = "highlight" }: QuotaProgressBarProps) {
  const percentage = Math.min(100, Math.round((used / included) * 100));

  return (
    <s-grid gap="small-100">
      {/* Progress bar as styled div since s-progress might not be available */}
      <div
        role="progressbar"
        aria-valuenow={percentage}
        aria-valuemin={0}
        aria-valuemax={100}
        aria-label={`${percentage}% of quota used`}
        style={{
          width: "100%",
          height: "8px",
          backgroundColor: "#e1e3e5",
          borderRadius: "4px",
          overflow: "hidden"
        }}
      >
        <div
          style={{
            width: `${percentage}%`,
            height: "100%",
            backgroundColor: tone === "critical" ? "#d72c0d" : tone === "warning" ? "#f49342" : "#008060",
            transition: "width 0.3s ease"
          }}
        />
      </div>
      <s-grid gridTemplateColumns="1fr auto" alignItems="center">
        <s-paragraph color="subdued">
          {used} of {included} sections used
        </s-paragraph>
        <s-text color="subdued" fontVariantNumeric="tabular-nums">
          {percentage}%
        </s-text>
      </s-grid>
    </s-grid>
  );
}
</file>

<file path="app/components/billing/UsageAlertBanner.tsx">
/**
 * Warning banner when approaching quota cap (>= 75%)
 * Shows upgrade CTA at 90% threshold
 * Dismissible with local storage persistence
 */

import { useState, useEffect } from "react";
import type { QuotaCheck } from "../../types/billing";

interface UsageAlertBannerProps {
  quota: QuotaCheck;
  onUpgradeClick: () => void;
}

export function UsageAlertBanner({ quota, onUpgradeClick }: UsageAlertBannerProps) {
  const [dismissed, setDismissed] = useState(false);

  // Load dismissed state from localStorage
  useEffect(() => {
    const key = `usage-alert-dismissed-${quota.percentUsed}`;
    const isDismissed = localStorage.getItem(key) === "true";
    setDismissed(isDismissed);
  }, [quota.percentUsed]);

  // Don't show if <75% or already dismissed
  if (quota.percentUsed < 75 || dismissed) return null;

  const isCritical = quota.percentUsed >= 90;

  const handleDismiss = () => {
    setDismissed(true);
    const key = `usage-alert-dismissed-${quota.percentUsed}`;
    localStorage.setItem(key, "true");
  };

  return (
    <s-banner
      tone={isCritical ? "critical" : "warning"}
      onDismiss={handleDismiss}
    >
      <s-grid gap="small-200">
        <s-paragraph>
          {isCritical
            ? ` You've used ${Math.round(quota.percentUsed)}% of your monthly quota. Consider upgrading to avoid hitting your cap.`
            : `You've used ${Math.round(quota.percentUsed)}% of your monthly quota.`
          }
        </s-paragraph>
        {isCritical && (
          <s-stack direction="inline" gap="small-200">
            <s-button
              variant="primary"
              onClick={onUpgradeClick}
              accessibilityLabel="Upgrade your plan"
            >
              Upgrade Plan
            </s-button>
            <s-button variant="tertiary" href="/docs/billing">
              Learn more
            </s-button>
          </s-stack>
        )}
      </s-grid>
    </s-banner>
  );
}
</file>

<file path="app/components/billing/UsageDashboard.tsx">
/**
 * Usage Dashboard Component
 * Shows quota usage, progress bars, cost breakdown
 */

import { QuotaProgressBar } from "./QuotaProgressBar";
import type { QuotaCheck, Subscription } from "../../types/billing";

interface UsageDashboardProps {
  quota: QuotaCheck;
  subscription: Subscription | null;
}

export function UsageDashboard({ quota, subscription }: UsageDashboardProps) {
  // Determine progress tone based on percentage
  const progressTone =
    quota.percentUsed >= 90 ? "critical" :
    quota.percentUsed >= 75 ? "warning" :
    "highlight";

  // Format date helper
  const formatDate = (date: Date | string | null) => {
    if (!date) return "N/A";
    return new Date(date).toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
    });
  };

  // Calculate cost breakdown
  const overageCost = quota.overagesThisCycle * (subscription?.overagePrice ?? 0);
  const totalCost = (subscription?.basePrice ?? 0) + overageCost;

  return (
    <s-section heading="Usage This Month">
      <s-grid gap="base">
        {/* Main Usage Card */}
        <s-box
          border="base"
          borderRadius="base"
          padding="base"
          background="subdued"
        >
          <s-grid gap="base">
            {/* Usage Progress */}
            <s-grid gap="small-200">
              <s-grid
                gridTemplateColumns="1fr auto"
                alignItems="baseline"
              >
                <s-heading>Sections Generated</s-heading>
                <s-text type="strong" fontVariantNumeric="tabular-nums">
                  {quota.usageThisCycle} / {quota.includedQuota}
                </s-text>
              </s-grid>
              <QuotaProgressBar
                used={quota.usageThisCycle}
                included={quota.includedQuota}
                tone={progressTone}
              />
            </s-grid>

            {/* Quota Breakdown */}
            <s-divider />
            <s-grid gap="small-200">
              <s-grid gridTemplateColumns="1fr auto">
                <s-paragraph>Included sections</s-paragraph>
                <s-text fontVariantNumeric="tabular-nums">{quota.includedQuota}</s-text>
              </s-grid>
              <s-grid gridTemplateColumns="1fr auto">
                <s-paragraph>Sections used</s-paragraph>
                <s-text fontVariantNumeric="tabular-nums">{Math.min(quota.usageThisCycle, quota.includedQuota)}</s-text>
              </s-grid>
              <s-grid gridTemplateColumns="1fr auto">
                <s-paragraph color="subdued">Remaining</s-paragraph>
                <s-text color="subdued" fontVariantNumeric="tabular-nums">
                  {Math.max(0, quota.includedQuota - quota.usageThisCycle)}
                </s-text>
              </s-grid>

              {/* Overage (if applicable) */}
              {quota.overagesThisCycle > 0 && (
                <>
                  <s-divider />
                  <s-grid gridTemplateColumns="1fr auto">
                    <s-paragraph>Overage sections</s-paragraph>
                    <s-text fontVariantNumeric="tabular-nums">{quota.overagesThisCycle}</s-text>
                  </s-grid>
                  <s-grid gridTemplateColumns="1fr auto">
                    <s-paragraph color="subdued">
                      Overage cost
                    </s-paragraph>
                    <s-text color="subdued" fontVariantNumeric="tabular-nums">
                      ${overageCost.toFixed(2)}
                    </s-text>
                  </s-grid>
                </>
              )}
            </s-grid>

            {/* Billing Cycle Info */}
            {subscription && (
              <>
                <s-divider />
                <s-paragraph color="subdued">
                  Billing cycle ends: {formatDate(subscription.currentPeriodEnd)}
                </s-paragraph>
              </>
            )}
          </s-grid>
        </s-box>

        {/* Cost Breakdown Card (if overage exists or show estimate) */}
        {subscription && (
          <s-box
            border="base"
            borderRadius="base"
            padding="base"
            background="base"
          >
            <s-grid gap="base">
              <s-heading>Estimated Total This Cycle</s-heading>
              <s-grid gap="small-200">
                <s-grid gridTemplateColumns="1fr auto">
                  <s-paragraph>Base plan</s-paragraph>
                  <s-text fontVariantNumeric="tabular-nums">${subscription.basePrice.toFixed(2)}</s-text>
                </s-grid>
                {quota.overagesThisCycle > 0 && (
                  <s-grid gridTemplateColumns="1fr auto">
                    <s-paragraph>Usage charges</s-paragraph>
                    <s-text fontVariantNumeric="tabular-nums">
                      ${overageCost.toFixed(2)}
                    </s-text>
                  </s-grid>
                )}
                <s-divider />
                <s-grid gridTemplateColumns="1fr auto">
                  <s-text type="strong">Total</s-text>
                  <s-text type="strong" fontVariantNumeric="tabular-nums">
                    ${totalCost.toFixed(2)}
                  </s-text>
                </s-grid>
              </s-grid>
              <s-paragraph color="subdued">
                Usage charges are billed at the end of your billing cycle.
              </s-paragraph>
            </s-grid>
          </s-box>
        )}
      </s-grid>
    </s-section>
  );
}
</file>

<file path="app/components/generate/templates/template-data.ts">
/**
 * Template and example data for the Generate screen
 * Static data - no API calls needed
 */

export interface SectionTemplate {
  id: string;
  title: string;
  description: string;
  icon: string;
  category: 'marketing' | 'product' | 'content' | 'layout';
  prompt: string;
}

export const SECTION_TEMPLATES: SectionTemplate[] = [
  {
    id: 'hero',
    title: 'Hero Section',
    description: 'Full-width banner with headline and CTA',
    icon: '',
    category: 'marketing',
    prompt: 'A hero section with a full-width background image, centered headline, subtext, and a primary call-to-action button. Include settings for image upload, text alignment, and button customization.'
  },
  {
    id: 'product-grid',
    title: 'Product Grid',
    description: 'Responsive grid of featured products',
    icon: '',
    category: 'product',
    prompt: 'A responsive product grid section displaying featured products in a 3-column layout. Include product image, title, price, and "Add to Cart" button. Make it responsive (2 columns on tablet, 1 on mobile).'
  },
  {
    id: 'testimonials',
    title: 'Testimonials',
    description: 'Customer reviews with ratings',
    icon: '',
    category: 'marketing',
    prompt: 'A testimonials section with customer quotes, star ratings, and customer names. Display 3 testimonials in a row with avatar images. Include schema settings for each testimonial.'
  },
  {
    id: 'faq',
    title: 'FAQ Accordion',
    description: 'Expandable questions and answers',
    icon: '',
    category: 'content',
    prompt: 'An FAQ section with collapsible accordion items. Each item has a question (clickable header) and answer (expandable content). Include settings to add/remove FAQ items with custom text.'
  },
  {
    id: 'cta-banner',
    title: 'CTA Banner',
    description: 'Call-to-action with background',
    icon: '',
    category: 'marketing',
    prompt: 'A call-to-action banner section with background color, headline, description text, and a prominent button. Include settings for text content, colors, and button link.'
  },
  {
    id: 'feature-columns',
    title: 'Feature Columns',
    description: '3-column features with icons',
    icon: '',
    category: 'content',
    prompt: 'A features section with 3 columns, each containing an icon, heading, and description. Include schema settings to customize icon, text, and link for each column.'
  },
  {
    id: 'image-gallery',
    title: 'Image Gallery',
    description: 'Responsive image grid',
    icon: '',
    category: 'layout',
    prompt: 'An image gallery section displaying images in a responsive grid (4 columns on desktop, 2 on tablet, 1 on mobile). Include lightbox functionality on click. Schema settings for adding/removing images.'
  },
  {
    id: 'newsletter',
    title: 'Newsletter Signup',
    description: 'Email subscription form',
    icon: '',
    category: 'marketing',
    prompt: 'A newsletter signup section with heading, description, email input field, and subscribe button. Include settings for form action URL, success message, and styling options.'
  }
];

export interface PromptExample {
  id: string;
  label: string;
  prompt: string;
}

export const PROMPT_EXAMPLES: PromptExample[] = [
  {
    id: 'before-after',
    label: 'Before/After Slider',
    prompt: 'A before-and-after image slider section with draggable divider to compare two images side-by-side'
  },
  {
    id: 'countdown',
    label: 'Countdown Timer',
    prompt: 'A countdown timer section for limited-time offers, displaying days, hours, minutes, and seconds until a target date'
  },
  {
    id: 'logo-list',
    label: 'Logo List',
    prompt: 'A section displaying partner or client logos in a horizontal scrolling row with hover effects'
  },
  {
    id: 'video-embed',
    label: 'Video Hero',
    prompt: 'A hero section with background video (YouTube or Vimeo embed), overlay text, and CTA button with semi-transparent backdrop'
  }
];
</file>

<file path="app/components/generate/GenerateActions.tsx">
import { Button } from '../shared/Button';

export interface GenerateActionsProps {
  onGenerate: () => void;
  onSave: () => void;
  isGenerating: boolean;
  isSaving: boolean;
  canSave: boolean;
  generateButtonText?: string;
  saveButtonText?: string;
}

/**
 * Action buttons for generate and save operations
 * Handles loading states and conditional save button visibility
 */
export function GenerateActions({
  onGenerate,
  onSave,
  isGenerating,
  isSaving,
  canSave,
  generateButtonText = 'Generate Code',
  saveButtonText = 'Save to Theme'
}: GenerateActionsProps) {
  return (
    <>
      <Button
        variant="primary"
        loading={isGenerating}
        disabled={isGenerating || isSaving}
        onClick={onGenerate}
      >
        {generateButtonText}
      </Button>

      {canSave && (
        <Button
          loading={isSaving}
          disabled={isSaving || isGenerating}
          onClick={onSave}
        >
          {saveButtonText}
        </Button>
      )}
    </>
  );
}
</file>

<file path="app/components/generations/DeleteConfirmModal.tsx">
interface DeleteConfirmModalProps {
  id: string;
  isBulk: boolean;
  count: number;
  isDeleting: boolean;
  onConfirm: () => void;
}

/**
 * Confirmation modal for delete actions using Shopify s-modal component.
 * Uses declarative commandFor pattern - trigger with a button that has commandFor={id}
 */
export function DeleteConfirmModal({
  id,
  isBulk,
  count,
  isDeleting,
  onConfirm,
}: DeleteConfirmModalProps) {
  const title = isBulk
    ? `Delete ${count} generation${count > 1 ? "s" : ""}?`
    : "Delete this generation?";

  const message = isBulk
    ? `Are you sure you want to delete ${count} selected generation${count > 1 ? "s" : ""}? This action cannot be undone.`
    : "Are you sure you want to delete this generation? This action cannot be undone.";

  return (
    <s-modal id={id} heading={title} size="small">
      <s-stack gap="base" direction="block">
        <s-paragraph>{message}</s-paragraph>
      </s-stack>
      <s-button
        slot="secondary-actions"
        command="--hide"
        commandFor={id}
        disabled={isDeleting}
      >
        Cancel
      </s-button>
      <s-button
        slot="primary-action"
        variant="primary"
        tone="critical"
        commandFor={id}
        command="--hide"
        onClick={onConfirm}
        loading={isDeleting}
        disabled={isDeleting}
      >
        Delete
      </s-button>
    </s-modal>
  );
}
</file>

<file path="app/components/generations/GenerationsEmptyState.tsx">
interface GenerationsEmptyStateProps {
  hasFilters: boolean;
  onClearFilters: () => void;
  onCreateNew: () => void;
}

/**
 * Empty state component for generations page following Shopify Index pattern
 */
export function GenerationsEmptyState({
  hasFilters,
  onClearFilters,
  onCreateNew
}: GenerationsEmptyStateProps) {
  if (hasFilters) {
    return (
      <s-section accessibilityLabel="Empty state section">
        <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
          <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
            <s-stack alignItems="center">
              <s-heading>No matching generations</s-heading>
              <s-paragraph>
                No generations match your current filters. Try adjusting or clearing your filters.
              </s-paragraph>
            </s-stack>
            <s-button-group>
              <s-button slot="secondary-actions" onClick={onClearFilters}>
                Clear filters
              </s-button>
              <s-button slot="primary-action" variant="primary" onClick={onCreateNew}>
                Create new generation
              </s-button>
            </s-button-group>
          </s-grid>
        </s-grid>
      </s-section>
    );
  }

  return (
    <s-section accessibilityLabel="Empty state section">
      <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
        <s-box maxInlineSize="200px" maxBlockSize="200px">
          <s-image
            aspectRatio="1/0.5"
            src="https://cdn.shopify.com/static/images/polaris/patterns/callout.png"
            alt="A stylized graphic representing AI section generation"
          />
        </s-box>
        <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
          <s-stack alignItems="center">
            <s-heading>Start generating sections</s-heading>
            <s-paragraph>
              Create AI-powered Liquid sections for your Shopify theme. Describe what you want
              and let AI generate production-ready code.
            </s-paragraph>
          </s-stack>
          <s-button-group>
            <s-button
              slot="secondary-actions"
              accessibilityLabel="Learn more about AI section generation"
              href="/app"
            >
              Learn more
            </s-button>
            <s-button
              slot="primary-action"
              variant="primary"
              accessibilityLabel="Create your first AI section"
              onClick={onCreateNew}
            >
              Generate Section
            </s-button>
          </s-button-group>
        </s-grid>
      </s-grid>
    </s-section>
  );
}
</file>

<file path="app/components/generations/index.ts">
export { GenerationsEmptyState } from "./GenerationsEmptyState";
export { DeleteConfirmModal } from "./DeleteConfirmModal";
</file>

<file path="app/components/home/index.ts">
export { SetupGuide } from "./SetupGuide";
export { FeatureNav } from "./FeatureNav";
export { QuickStats } from "./QuickStats";
</file>

<file path="app/components/home/QuickStats.tsx">
interface QuickStatsProps {
  stats: {
    sectionsGenerated: number;
    templatesSaved: number;
    generationsThisWeek: number;
  };
}

export function QuickStats({ stats }: QuickStatsProps) {
  return (
    <s-stack gap="base" direction="block">
      <s-stack gap="small" direction="block">
        <s-text type="strong">{stats.sectionsGenerated}</s-text>
        <s-text color="subdued">Sections generated</s-text>
      </s-stack>
      <s-divider />
      <s-stack gap="small" direction="block">
        <s-text type="strong">{stats.templatesSaved}</s-text>
        <s-text color="subdued">Templates saved</s-text>
      </s-stack>
      <s-divider />
      <s-stack gap="small" direction="block">
        <s-text type="strong">{stats.generationsThisWeek}</s-text>
        <s-text color="subdued">This week</s-text>
      </s-stack>
    </s-stack>
  );
}
</file>

<file path="app/components/preview/drops/ArticleDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import { ImageDrop } from './ImageDrop';
import type { MockArticle } from '../mockData/types';

/**
 * Drop class for article objects
 * Provides Liquid-compatible access to article properties
 */
export class ArticleDrop extends ShopifyDrop {
  private article: MockArticle;

  constructor(article: MockArticle) {
    super();
    this.article = article;
  }

  get id(): number {
    return this.article.id;
  }

  get title(): string {
    return this.article.title;
  }

  get handle(): string {
    return this.article.handle;
  }

  get content(): string {
    return this.article.content;
  }

  get excerpt(): string {
    return this.article.excerpt;
  }

  get excerpt_or_content(): string {
    return this.article.excerpt || this.article.content;
  }

  get author(): string {
    return this.article.author;
  }

  get published_at(): string {
    return this.article.published_at;
  }

  get created_at(): string {
    return this.article.published_at;
  }

  get url(): string {
    return this.article.url;
  }

  get tags(): string[] {
    return this.article.tags;
  }

  get image(): ImageDrop | null {
    return this.article.image
      ? new ImageDrop(this.article.image)
      : null;
  }

  /**
   * Check if article has a specific tag
   */
  has_tag(tag: string): boolean {
    return this.article.tags.includes(tag);
  }

  /**
   * Comments count (placeholder, comments not implemented)
   */
  get comments_count(): number {
    return 0;
  }

  /**
   * Whether comments are enabled
   */
  get comments_enabled(): boolean {
    return false;
  }

  /**
   * User object (simplified)
   */
  get user(): { first_name: string; last_name: string; bio: string } {
    const nameParts = this.article.author.split(' ');
    return {
      first_name: nameParts[0] || '',
      last_name: nameParts.slice(1).join(' ') || '',
      bio: ''
    };
  }

  liquidMethodMissing(key: string): unknown {
    const data = this.article as unknown as Record<string, unknown>;
    return data[key];
  }
}
</file>

<file path="app/components/preview/drops/BlockDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { BlockInstance } from '../schema/SchemaTypes';

/**
 * Drop class for block objects
 * Provides Liquid-compatible access to block properties
 *
 * Usage in Liquid:
 * {% for block in section.blocks %}
 *   {{ block.id }}
 *   {{ block.type }}
 *   {{ block.settings.heading }}
 *   <div {{ block.shopify_attributes }}>...</div>
 * {% endfor %}
 */
export class BlockDrop extends ShopifyDrop {
  private block: BlockInstance;
  private _settingsDrop: Record<string, unknown> | null = null;

  constructor(block: BlockInstance) {
    super();
    this.block = block;
  }

  /**
   * Unique block identifier
   */
  get id(): string {
    return this.block.id;
  }

  /**
   * Block type from schema definition
   */
  get type(): string {
    return this.block.type;
  }

  /**
   * Block settings object
   * Returns settings wrapped for Liquid access
   */
  get settings(): Record<string, unknown> {
    if (!this._settingsDrop) {
      // Wrap settings in plain object for Liquid access
      // LiquidJS can access nested properties directly
      this._settingsDrop = { ...this.block.settings };
    }
    return this._settingsDrop;
  }

  /**
   * Shopify theme editor attributes
   * Renders as HTML data attributes for block identification
   *
   * Output: data-block-id="block-0" data-block-type="feature"
   */
  get shopify_attributes(): string {
    return `data-block-id="${this.block.id}" data-block-type="${this.block.type}"`;
  }

  /**
   * Dynamic property access fallback
   * Allows access to any block instance properties
   */
  liquidMethodMissing(key: string): unknown {
    const data = this.block as unknown as Record<string, unknown>;
    return data[key];
  }

  /**
   * String representation for debugging
   */
  valueOf(): string {
    return `[Block: ${this.block.type}]`;
  }
}
</file>

<file path="app/components/preview/drops/CartDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import { ImageDrop } from './ImageDrop';
import type { MockCart, MockCartItem } from '../mockData/types';

/**
 * CartItemDrop - Individual cart line item
 * Provides Liquid-compatible access to cart item properties
 */
export class CartItemDrop extends ShopifyDrop {
  private item: MockCartItem;

  constructor(item: MockCartItem) {
    super();
    this.item = item;
  }

  get id(): number { return this.item.id; }
  get title(): string { return this.item.title; }
  get quantity(): number { return this.item.quantity; }
  get price(): number { return this.item.price; }
  get line_price(): number { return this.item.line_price; }
  get original_price(): number { return this.item.price; }
  get original_line_price(): number { return this.item.line_price; }
  get final_price(): number { return this.item.price; }
  get final_line_price(): number { return this.item.line_price; }
  get url(): string { return this.item.url; }

  get image(): ImageDrop {
    return new ImageDrop(this.item.image);
  }

  get product(): { title: string; url: string } {
    return { title: this.item.title, url: this.item.url };
  }

  get variant(): { title: string } {
    return { title: 'Default' };
  }

  get discounts(): unknown[] { return []; }
  get properties(): Record<string, string> { return {}; }
  get selling_plan_allocation(): null { return null; }
}

/**
 * CartDrop - Shopping cart object
 * Provides Liquid-compatible access to cart properties
 */
export class CartDrop extends ShopifyDrop {
  private cart: MockCart;
  private _items: CartItemDrop[] | null = null;

  constructor(cart: MockCart) {
    super();
    this.cart = cart;
  }

  get item_count(): number { return this.cart.item_count; }
  get total_price(): number { return this.cart.total_price; }
  get original_total_price(): number { return this.cart.total_price; }
  get total_discount(): number { return 0; }
  get total_weight(): number { return 0; }
  get currency(): { iso_code: string } { return { iso_code: this.cart.currency }; }

  get items(): CartItemDrop[] {
    if (!this._items) {
      this._items = this.cart.items.map(item => new CartItemDrop(item));
    }
    return this._items;
  }

  get items_subtotal_price(): number { return this.cart.total_price; }
  get requires_shipping(): boolean { return true; }
  get note(): string { return ''; }
  get attributes(): Record<string, string> { return {}; }
  get cart_level_discount_applications(): unknown[] { return []; }
  get discount_applications(): unknown[] { return []; }

  /** Check if cart is empty */
  get empty(): boolean { return this.cart.item_count === 0; }
}
</file>

<file path="app/components/preview/drops/CollectionsDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import { CollectionDrop } from './CollectionDrop';
import type { MockCollection } from '../mockData/types';

/**
 * Drop class for collections global object
 * Provides Liquid-compatible access to collections by handle
 * Acts as a proxy - returns the default collection for any key lookup
 */
export class CollectionsDrop extends ShopifyDrop {
  private defaultCollection: CollectionDrop;
  private collectionMap: Map<string, CollectionDrop>;

  constructor(defaultCollectionData: MockCollection, additionalCollections: MockCollection[] = []) {
    super();
    this.defaultCollection = new CollectionDrop(defaultCollectionData);
    this.collectionMap = new Map();

    // Add the default collection by its handle
    this.collectionMap.set(defaultCollectionData.handle, this.defaultCollection);

    // Add any additional collections
    additionalCollections.forEach(col => {
      this.collectionMap.set(col.handle, new CollectionDrop(col));
    });
  }

  /**
   * Handle property access like collections['all'] or collections.featured
   * Returns the default collection for any unknown handle (preview fallback)
   */
  liquidMethodMissing(key: string): CollectionDrop {
    // Check if we have this specific collection
    const found = this.collectionMap.get(key);
    if (found) {
      return found;
    }
    // Otherwise return the default collection as fallback
    return this.defaultCollection;
  }

  /**
   * Make the Drop iterable for {% for collection in collections %}
   */
  [Symbol.iterator](): Iterator<CollectionDrop> {
    return this.collectionMap.values();
  }

  /**
   * Return array of all collections for iteration
   */
  toArray(): CollectionDrop[] {
    return Array.from(this.collectionMap.values());
  }

  /**
   * Size property for length checks
   */
  get size(): number {
    return this.collectionMap.size;
  }
}
</file>

<file path="app/components/preview/drops/CustomerDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { MockCustomer } from '../mockData/types';

/**
 * CustomerDrop - Logged-in customer data
 * Provides Liquid-compatible access to customer properties
 * Returns null/empty values when no customer is logged in
 */
export class CustomerDrop extends ShopifyDrop {
  private customer: MockCustomer | null;

  constructor(customer: MockCustomer | null) {
    super();
    this.customer = customer;
  }

  get id(): number | null { return this.customer?.id ?? null; }
  get email(): string { return this.customer?.email ?? ''; }
  get first_name(): string { return this.customer?.first_name ?? ''; }
  get last_name(): string { return this.customer?.last_name ?? ''; }
  get name(): string { return this.customer?.name ?? ''; }
  get orders_count(): number { return this.customer?.orders_count ?? 0; }
  get total_spent(): number { return this.customer?.total_spent ?? 0; }

  get phone(): string { return ''; }
  get default_address(): null { return null; }
  get addresses(): unknown[] { return []; }
  get orders(): unknown[] { return []; }
  get tags(): string[] { return []; }
  get tax_exempt(): boolean { return false; }
  get accepts_marketing(): boolean { return false; }
  get has_account(): boolean { return this.customer !== null; }

  /** Liquid truthy check - returns false when no customer */
  valueOf(): boolean { return this.customer !== null; }

  /** For Liquid truthiness check */
  toLiquid(): MockCustomer | null { return this.customer; }
}
</file>

<file path="app/components/preview/drops/ForloopDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';

/**
 * ForloopDrop - Loop iteration metadata
 * Available inside {% for %} loops as 'forloop'
 */
export class ForloopDrop extends ShopifyDrop {
  private _index: number;
  private _length: number;
  private _name: string;
  private _parentloop: ForloopDrop | null;

  constructor(index: number, length: number, name = 'item', parentloop: ForloopDrop | null = null) {
    super();
    this._index = index;
    this._length = length;
    this._name = name;
    this._parentloop = parentloop;
  }

  /** 1-based index */
  get index(): number { return this._index + 1; }

  /** 0-based index */
  get index0(): number { return this._index; }

  /** Reverse 1-based index */
  get rindex(): number { return this._length - this._index; }

  /** Reverse 0-based index */
  get rindex0(): number { return this._length - this._index - 1; }

  /** True if first iteration */
  get first(): boolean { return this._index === 0; }

  /** True if last iteration */
  get last(): boolean { return this._index === this._length - 1; }

  /** Total iterations */
  get length(): number { return this._length; }

  /** Parent forloop (for nested loops) */
  get parentloop(): ForloopDrop | null { return this._parentloop; }

  /** Loop variable name */
  get name(): string { return this._name; }
}
</file>

<file path="app/components/preview/drops/PaginateDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';

interface PaginateData {
  current_page: number;
  page_size: number;
  total_items: number;
}

interface PaginatePart {
  title: string;
  url: string;
  is_link: boolean;
}

/**
 * PaginateDrop - Pagination metadata for paginated collections
 * Provides Liquid-compatible access to pagination properties
 */
export class PaginateDrop extends ShopifyDrop {
  private data: PaginateData;

  constructor(data: PaginateData) {
    super();
    this.data = data;
  }

  get current_page(): number { return this.data.current_page; }
  get current_offset(): number { return (this.data.current_page - 1) * this.data.page_size; }
  get page_size(): number { return this.data.page_size; }
  get pages(): number { return Math.ceil(this.data.total_items / this.data.page_size); }
  get items(): number { return this.data.total_items; }

  get previous(): PaginatePart | null {
    if (this.data.current_page <= 1) return null;
    return {
      title: 'Previous',
      url: `?page=${this.data.current_page - 1}`,
      is_link: true
    };
  }

  get next(): PaginatePart | null {
    if (this.data.current_page >= this.pages) return null;
    return {
      title: 'Next',
      url: `?page=${this.data.current_page + 1}`,
      is_link: true
    };
  }

  /** Array of page parts for rendering pagination UI */
  get parts(): PaginatePart[] {
    const parts: PaginatePart[] = [];
    const totalPages = this.pages;

    for (let i = 1; i <= totalPages; i++) {
      parts.push({
        title: String(i),
        url: `?page=${i}`,
        is_link: i !== this.data.current_page
      });
    }

    return parts;
  }
}
</file>

<file path="app/components/preview/drops/RequestDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { MockRequest } from '../mockData/types';

/**
 * RequestDrop - Request/context information
 * Provides access to request details like design_mode, page_type, path
 */
export class RequestDrop extends ShopifyDrop {
  private data: MockRequest & { host?: string; origin?: string };

  constructor(data: Partial<MockRequest> & { host?: string; origin?: string } = {}) {
    super();
    this.data = {
      design_mode: true, // Always true in preview
      page_type: 'index',
      path: '/',
      host: 'preview.myshopify.com',
      origin: 'https://preview.myshopify.com',
      ...data
    };
  }

  /** True when in theme editor or preview */
  get design_mode(): boolean { return this.data.design_mode; }

  /** Current page type (product, collection, index, etc.) */
  get page_type(): string { return this.data.page_type; }

  /** Current request path */
  get path(): string { return this.data.path; }

  /** Request host */
  get host(): string { return this.data.host ?? 'preview.myshopify.com'; }

  /** Request origin */
  get origin(): string { return this.data.origin ?? 'https://preview.myshopify.com'; }

  /** Locale from Accept-Language */
  get locale(): { iso_code: string; primary: boolean } {
    return { iso_code: 'en', primary: true };
  }
}
</file>

<file path="app/components/preview/drops/RoutesDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';

/**
 * RoutesDrop - URL generation helpers
 * Provides common Shopify store URLs for templates
 */
export class RoutesDrop extends ShopifyDrop {
  private baseUrl: string;

  constructor(baseUrl = '') {
    super();
    this.baseUrl = baseUrl;
  }

  get root_url(): string { return this.baseUrl || '/'; }
  get account_url(): string { return `${this.baseUrl}/account`; }
  get account_login_url(): string { return `${this.baseUrl}/account/login`; }
  get account_logout_url(): string { return `${this.baseUrl}/account/logout`; }
  get account_register_url(): string { return `${this.baseUrl}/account/register`; }
  get account_addresses_url(): string { return `${this.baseUrl}/account/addresses`; }
  get cart_url(): string { return `${this.baseUrl}/cart`; }
  get cart_add_url(): string { return `${this.baseUrl}/cart/add`; }
  get cart_change_url(): string { return `${this.baseUrl}/cart/change`; }
  get cart_clear_url(): string { return `${this.baseUrl}/cart/clear`; }
  get cart_update_url(): string { return `${this.baseUrl}/cart/update`; }
  get collections_url(): string { return `${this.baseUrl}/collections`; }
  get all_products_collection_url(): string { return `${this.baseUrl}/collections/all`; }
  get search_url(): string { return `${this.baseUrl}/search`; }
  get predictive_search_url(): string { return `${this.baseUrl}/search/suggest`; }
  get product_recommendations_url(): string { return `${this.baseUrl}/recommendations/products`; }
}
</file>

<file path="app/components/preview/drops/ThemeDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';

/**
 * ThemeDrop - Current theme metadata
 * Provides Liquid-compatible access to theme properties
 */
export class ThemeDrop extends ShopifyDrop {
  constructor() {
    super();
  }

  get id(): number { return 1; }
  get name(): string { return 'Preview Theme'; }
  get role(): string { return 'main'; }
  get theme_store_id(): null { return null; }
}

/**
 * SettingsDrop - Global theme settings
 * Acts as a passthrough for settings values
 */
export class SettingsDrop extends ShopifyDrop {
  private settingsData: Record<string, unknown>;

  constructor(settings: Record<string, unknown> = {}) {
    super();
    this.settingsData = settings;
  }

  liquidMethodMissing(key: string): unknown {
    return this.settingsData[key];
  }

  /** Get a setting by key */
  get(key: string): unknown {
    return this.settingsData[key];
  }

  /** Check if a setting exists */
  has(key: string): boolean {
    return key in this.settingsData;
  }
}
</file>

<file path="app/components/preview/drops/VariantDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { MockProductVariant } from '../mockData/types';

/**
 * Drop class for product variant objects
 * Provides Liquid-compatible access to variant properties
 */
export class VariantDrop extends ShopifyDrop {
  private variant: MockProductVariant;

  constructor(variant: MockProductVariant) {
    super();
    this.variant = variant;
  }

  get id(): number {
    return this.variant.id;
  }

  get title(): string {
    return this.variant.title;
  }

  get price(): number {
    return this.variant.price;
  }

  get available(): boolean {
    return this.variant.available;
  }

  get inventory_quantity(): number {
    return this.variant.inventory_quantity;
  }

  get sku(): string {
    return this.variant.sku;
  }

  get option1(): string | null {
    return this.variant.option1;
  }

  get option2(): string | null {
    return this.variant.option2;
  }

  get option3(): string | null {
    return this.variant.option3;
  }

  /**
   * Whether this variant is currently selected
   * In preview, defaults to false
   */
  get selected(): boolean {
    return false;
  }

  /**
   * Formatted options string
   */
  get options(): string[] {
    return [
      this.variant.option1,
      this.variant.option2,
      this.variant.option3
    ].filter((o): o is string => o !== null);
  }

  liquidMethodMissing(key: string): unknown {
    const data = this.variant as unknown as Record<string, unknown>;
    return data[key];
  }
}
</file>

<file path="app/components/preview/hooks/usePreviewMessaging.ts">
import { useCallback, useEffect, useRef } from 'react';
import type { PreviewMessage } from '../types';

interface UsePreviewMessagingResult {
  sendMessage: (message: PreviewMessage) => void;
  setIframe: (iframe: HTMLIFrameElement | null) => void;
}

/**
 * Hook for handling postMessage communication with preview iframe
 * Includes security validation for message origin
 */
export function usePreviewMessaging(
  onMessage?: (message: PreviewMessage) => void
): UsePreviewMessagingResult {
  const iframeRef = useRef<HTMLIFrameElement | null>(null);
  const expectedOrigin = typeof window !== 'undefined' ? window.location.origin : '';

  // Listen for messages from iframe
  useEffect(() => {
    if (!onMessage) return;

    const handleMessage = (event: MessageEvent) => {
      // Security: Validate origin
      if (event.origin !== expectedOrigin) {
        console.warn('Ignored message from unexpected origin:', event.origin);
        return;
      }

      // Validate message structure
      if (event.data && typeof event.data.type === 'string') {
        onMessage(event.data as PreviewMessage);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [onMessage, expectedOrigin]);

  const sendMessage = useCallback((message: PreviewMessage) => {
    if (!iframeRef.current?.contentWindow) {
      console.warn('Cannot send message: iframe not ready');
      return;
    }

    // Use '*' for srcDoc iframes since they have null origin
    // Security is handled by validating message structure in the iframe
    iframeRef.current.contentWindow.postMessage(message, '*');
  }, []);

  const setIframe = useCallback((iframe: HTMLIFrameElement | null) => {
    iframeRef.current = iframe;
  }, []);

  return { sendMessage, setIframe };
}
</file>

<file path="app/components/preview/schema/__tests__/parseSchema.test.ts">
import { resolveTranslationKey, extractSettings, extractBlocks } from '../parseSchema';
import type { SchemaDefinition } from '../SchemaTypes';

describe('resolveTranslationKey', () => {
  it('resolves translation key with label suffix', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.background_image.label');
    expect(result).toBe('Background Image');
  });

  it('resolves translation key with options and label suffix', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.text_alignment.options__2.label');
    expect(result).toBe('Text Alignment');
  });

  it('leaves plain text unchanged', () => {
    const result = resolveTranslationKey('Background Color');
    expect(result).toBe('Background Color');
  });

  it('handles empty string', () => {
    const result = resolveTranslationKey('');
    expect(result).toBe('');
  });

  it('handles undefined', () => {
    const result = resolveTranslationKey(undefined);
    expect(result).toBe('');
  });

  it('converts snake_case to Title Case', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.button_text.label');
    expect(result).toBe('Button Text');
  });

  it('handles translation key with info suffix', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.heading.info');
    expect(result).toBe('Heading');
  });

  it('handles translation key with placeholder suffix', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.email.placeholder');
    expect(result).toBe('Email');
  });

  it('skips common prefixes and suffixes', () => {
    const result = resolveTranslationKey('t:sections.blocks.settings.call_to_action.label');
    expect(result).toBe('Call To Action');
  });

  it('handles numbered options patterns', () => {
    const result = resolveTranslationKey('t:sections.hero.settings.alignment.options__1.label');
    expect(result).toBe('Alignment');
  });

  it('fallback returns key without t: prefix', () => {
    const result = resolveTranslationKey('t:label');
    expect(result).toBe('label');
  });
});

describe('extractSettings', () => {
  it('resolves translation keys in setting labels', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      settings: [
        {
          type: 'text',
          id: 'heading',
          label: 't:sections.hero.settings.heading.label',
        },
      ],
    };

    const settings = extractSettings(schema);
    expect(settings).toHaveLength(1);
    expect(settings[0].label).toBe('Heading');
  });

  it('resolves translation keys in select option labels', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      settings: [
        {
          type: 'select',
          id: 'alignment',
          label: 't:sections.hero.settings.alignment.label',
          options: [
            { value: 'left', label: 't:sections.hero.settings.alignment.options__1.label' },
            { value: 'center', label: 't:sections.hero.settings.alignment.options__2.label' },
          ],
        },
      ],
    };

    const settings = extractSettings(schema);
    expect(settings).toHaveLength(1);
    expect(settings[0].label).toBe('Alignment');
    expect(settings[0].options?.[0].label).toBe('Alignment');
    expect(settings[0].options?.[1].label).toBe('Alignment');
  });

  it('resolves translation keys in info and placeholder', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      settings: [
        {
          type: 'text',
          id: 'email',
          label: 't:sections.contact.settings.email.label',
          info: 't:sections.contact.settings.email.info',
          placeholder: 't:sections.contact.settings.email.placeholder',
        },
      ],
    };

    const settings = extractSettings(schema);
    expect(settings).toHaveLength(1);
    expect(settings[0].label).toBe('Email');
    expect(settings[0].info).toBe('Email');
    expect(settings[0].placeholder).toBe('Email');
  });

  it('leaves plain text labels unchanged', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      settings: [
        {
          type: 'text',
          id: 'title',
          label: 'Section Title',
        },
      ],
    };

    const settings = extractSettings(schema);
    expect(settings).toHaveLength(1);
    expect(settings[0].label).toBe('Section Title');
  });
});

describe('extractBlocks', () => {
  it('resolves translation keys in block names', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      blocks: [
        {
          type: 'testimonial',
          name: 't:sections.testimonials.blocks.testimonial.name',
          settings: [
            {
              type: 'text',
              id: 'author',
              label: 't:sections.testimonials.blocks.testimonial.settings.author.label',
            },
          ],
        },
      ],
    };

    const blocks = extractBlocks(schema);
    expect(blocks).toHaveLength(1);
    expect(blocks[0].name).toBe('Testimonial');
    expect(blocks[0].settings?.[0].label).toBe('Author');
  });

  it('resolves translation keys in block setting options', () => {
    const schema: SchemaDefinition = {
      name: 'Test Section',
      blocks: [
        {
          type: 'button',
          name: 't:sections.cta.blocks.button.name',
          settings: [
            {
              type: 'select',
              id: 'style',
              label: 't:sections.cta.blocks.button.settings.style.label',
              options: [
                { value: 'primary', label: 't:sections.cta.blocks.button.settings.style.options__1.label' },
                { value: 'secondary', label: 't:sections.cta.blocks.button.settings.style.options__2.label' },
              ],
            },
          ],
        },
      ],
    };

    const blocks = extractBlocks(schema);
    expect(blocks).toHaveLength(1);
    expect(blocks[0].name).toBe('Button');
    expect(blocks[0].settings?.[0].label).toBe('Style');
    expect(blocks[0].settings?.[0].options?.[0].label).toBe('Style');
    expect(blocks[0].settings?.[0].options?.[1].label).toBe('Style');
  });
});
</file>

<file path="app/components/preview/schema/index.ts">
export * from './SchemaTypes';
export * from './parseSchema';
</file>

<file path="app/components/preview/settings/ArticleSetting.tsx">
/**
 * ArticleSetting Component
 * Renders input for schema settings with type: "article"
 * App Bridge doesn't support article picker - uses handle input
 * Format: blog-handle/article-handle
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface ArticleSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function ArticleSetting({
  setting,
  value,
  onChange,
  disabled,
}: ArticleSettingProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-text-field
        label="Article handle"
        value={value}
        placeholder="blog-name/article-handle"
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <span style={{ fontSize: '12px', color: '#8c9196' }}>
        Format: blog-handle/article-handle
      </span>
    </div>
  );
}
</file>

<file path="app/components/preview/settings/BlogSetting.tsx">
/**
 * BlogSetting Component
 * Renders input for schema settings with type: "blog"
 * App Bridge doesn't support blog picker - uses handle input
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface BlogSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function BlogSetting({
  setting,
  value,
  onChange,
  disabled,
}: BlogSettingProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-text-field
        label="Blog handle"
        value={value}
        placeholder="news"
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/FontPickerSetting.tsx">
/**
 * FontPickerSetting Component
 * Renders font selection for typography settings
 * Shopify provides system + Google fonts - we offer common web-safe fonts
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface FontPickerSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

// Common web-safe fonts that approximate Shopify's font picker
const FONT_OPTIONS = [
  { value: 'system-ui', label: 'System UI', stack: 'system-ui, sans-serif' },
  { value: 'arial', label: 'Arial', stack: 'Arial, sans-serif' },
  { value: 'helvetica', label: 'Helvetica', stack: 'Helvetica, Arial, sans-serif' },
  { value: 'georgia', label: 'Georgia', stack: 'Georgia, serif' },
  { value: 'times', label: 'Times New Roman', stack: '"Times New Roman", serif' },
  { value: 'courier', label: 'Courier New', stack: '"Courier New", monospace' },
  { value: 'verdana', label: 'Verdana', stack: 'Verdana, sans-serif' },
  { value: 'trebuchet', label: 'Trebuchet MS', stack: '"Trebuchet MS", sans-serif' },
  { value: 'tahoma', label: 'Tahoma', stack: 'Tahoma, sans-serif' },
  { value: 'palatino', label: 'Palatino', stack: '"Palatino Linotype", Palatino, serif' },
];

export function FontPickerSetting({ setting, value, onChange, disabled }: FontPickerSettingProps) {
  const handleChange = (e: Event) => {
    const target = e.target as HTMLSelectElement;
    onChange(target.value);
  };

  const selectedFont = FONT_OPTIONS.find(f => f.value === value) || FONT_OPTIONS[0];

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-select
        label="Font family"
        value={value || 'system-ui'}
        disabled={disabled || undefined}
        onChange={handleChange}
      >
        {FONT_OPTIONS.map((font) => (
          <option key={font.value} value={font.value}>
            {font.label}
          </option>
        ))}
      </s-select>

      {/* Font preview */}
      <div style={{
        padding: '12px',
        backgroundColor: '#f6f6f7',
        borderRadius: '4px',
        fontFamily: selectedFont.stack,
        fontSize: '16px'
      }}>
        The quick brown fox jumps over the lazy dog
      </div>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <span style={{ fontSize: '12px', color: '#8c9196' }}>
        In Shopify, this opens the full font picker with Google Fonts
      </span>
    </div>
  );
}
</file>

<file path="app/components/preview/settings/ImagePickerModal.tsx">
/**
 * ImagePickerModal Component
 * Modal for selecting images from Shopify Files library
 * Uses Polaris s-modal with commandFor/command pattern
 */

import { useState, useEffect, useCallback, useRef } from "react";

export const IMAGE_PICKER_MODAL_ID = "image-picker-modal";

interface ShopifyFile {
  id: string;
  alt: string | null;
  createdAt: string;
  image: {
    url: string;
    width: number;
    height: number;
  } | null;
  filename?: string;
}

interface FilesResponse {
  files: ShopifyFile[];
  pageInfo: {
    hasNextPage: boolean;
    endCursor: string | null;
  };
  error?: string;
}

export function ImagePickerModal() {
  const [files, setFiles] = useState<ShopifyFile[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedFile, setSelectedFile] = useState<ShopifyFile | null>(null);
  const [endCursor, setEndCursor] = useState<string | null>(null);
  const [hasNextPage, setHasNextPage] = useState(false);
  const currentSettingId = useRef<string | null>(null);

  // Fetch files from API
  const fetchFiles = useCallback(
    async (append = false, cursor: string | null = null) => {
      setIsLoading(true);
      setError(null);

      try {
        const params = new URLSearchParams({
          first: "20",
          ...(cursor && { after: cursor }),
          ...(searchQuery && { query: searchQuery }),
        });

        const response = await fetch(`/api/files?${params}`);
        const data: FilesResponse = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        setFiles((prev) => (append ? [...prev, ...data.files] : data.files));
        setHasNextPage(data.pageInfo.hasNextPage);
        setEndCursor(data.pageInfo.endCursor);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load images");
        console.error("Failed to fetch files:", err);
      } finally {
        setIsLoading(false);
      }
    },
    [searchQuery]
  );

  // Listen for open events from ImageSetting components
  useEffect(() => {
    const handleOpen = (event: Event) => {
      const customEvent = event as CustomEvent<{ settingId: string }>;
      currentSettingId.current = customEvent.detail.settingId;
      setSelectedFile(null);
      setSearchQuery("");
      fetchFiles(false, null);
    };

    window.addEventListener("image-picker-open", handleOpen);
    return () => {
      window.removeEventListener("image-picker-open", handleOpen);
    };
  }, [fetchFiles]);

  // Handle search with debounce
  useEffect(() => {
    const timer = setTimeout(() => {
      if (currentSettingId.current) {
        fetchFiles(false, null);
      }
    }, 300);
    return () => clearTimeout(timer);
  }, [searchQuery, fetchFiles]);

  const handleLoadMore = () => {
    if (hasNextPage && endCursor) {
      fetchFiles(true, endCursor);
    }
  };

  const handleSelect = () => {
    if (selectedFile?.image?.url && currentSettingId.current) {
      // Dispatch event with selected image
      window.dispatchEvent(new CustomEvent('image-picker-select', {
        detail: {
          settingId: currentSettingId.current,
          imageUrl: selectedFile.image.url,
          alt: selectedFile.alt
        }
      }));
    }
  };

  const handleFileClick = (file: ShopifyFile) => {
    setSelectedFile(file);
  };

  // Format file size or dimensions for display
  const formatDimensions = (file: ShopifyFile) => {
    if (file.image) {
      return `${file.image.width}  ${file.image.height}`;
    }
    return "";
  };

  return (
    <s-modal id={IMAGE_PICKER_MODAL_ID} heading="Select Image" size="large">
      {/* Search Bar */}
      <div style={{ marginBottom: "16px" }}>
        <s-text-field
          label=""
          placeholder="Search files"
          value={searchQuery}
          onInput={(e: Event) =>
            setSearchQuery((e.target as HTMLInputElement).value)
          }
        />
      </div>

      {/* Error State */}
      {error && (
        <s-banner tone="critical" dismissible>
          {error}
        </s-banner>
      )}

      {/* Loading State */}
      {isLoading && files.length === 0 && (
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "repeat(auto-fill, minmax(120px, 1fr))",
            gap: "12px",
            padding: "16px 0",
          }}
        >
          {[...Array(8)].map((_, i) => (
            <div
              key={i}
              style={{
                aspectRatio: "1",
                backgroundColor: "#f1f2f4",
                borderRadius: "8px",
                animation: "pulse 1.5s infinite",
              }}
            />
          ))}
        </div>
      )}

      {/* Empty State */}
      {!isLoading && files.length === 0 && !error && (
        <div
          style={{
            padding: "48px",
            textAlign: "center",
            color: "#6d7175",
          }}
        >
          <p style={{ margin: 0 }}>No images found</p>
          {searchQuery && (
            <p style={{ margin: "8px 0 0", fontSize: "13px" }}>
              Try a different search term
            </p>
          )}
        </div>
      )}

      {/* Image Grid */}
      {files.length > 0 && (
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "repeat(auto-fill, minmax(100px, 1fr))",
            gap: "12px",
            maxHeight: "400px",
            overflowY: "auto",
            padding: "4px",
          }}
        >
          {files.map((file) => (
            <button
              key={file.id}
              type="button"
              onClick={() => handleFileClick(file)}
              style={{
                position: "relative",
                aspectRatio: "1",
                border:
                  selectedFile?.id === file.id
                    ? "2px solid #008060"
                    : "1px solid #e1e3e5",
                borderRadius: "8px",
                overflow: "hidden",
                cursor: "pointer",
                padding: 0,
                background: "#f6f6f7",
                transition: "border-color 0.15s, box-shadow 0.15s",
              }}
              onMouseEnter={(e) => {
                if (selectedFile?.id !== file.id) {
                  e.currentTarget.style.borderColor = "#8c9196";
                }
              }}
              onMouseLeave={(e) => {
                if (selectedFile?.id !== file.id) {
                  e.currentTarget.style.borderColor = "#e1e3e5";
                }
              }}
            >
              {file.image?.url && (
                <img
                  src={file.image.url}
                  alt={file.alt || file.filename || "Image"}
                  style={{
                    width: "100%",
                    height: "100%",
                    objectFit: "cover",
                  }}
                  loading="lazy"
                />
              )}

              {/* Selection checkmark */}
              {selectedFile?.id === file.id && (
                <div
                  style={{
                    position: "absolute",
                    top: "6px",
                    right: "6px",
                    width: "20px",
                    height: "20px",
                    borderRadius: "50%",
                    backgroundColor: "#008060",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  <svg
                    width="12"
                    height="12"
                    viewBox="0 0 20 20"
                    fill="white"
                  >
                    <path d="M8.72 15.78a.75.75 0 0 1-1.06 0l-4.44-4.44a.75.75 0 1 1 1.06-1.06l3.91 3.91 7.97-7.97a.75.75 0 1 1 1.06 1.06l-8.5 8.5Z" />
                  </svg>
                </div>
              )}

              {/* Filename overlay */}
              <div
                style={{
                  position: "absolute",
                  bottom: 0,
                  left: 0,
                  right: 0,
                  padding: "4px 6px",
                  background: "linear-gradient(transparent, rgba(0,0,0,0.6))",
                  color: "white",
                  fontSize: "10px",
                  whiteSpace: "nowrap",
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                }}
              >
                {file.filename || "Image"}
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Load More Button */}
      {hasNextPage && (
        <div style={{ textAlign: "center", marginTop: "16px" }}>
          <s-button
            variant="tertiary"
            onClick={handleLoadMore}
            loading={isLoading || undefined}
          >
            Load more
          </s-button>
        </div>
      )}

      {/* Selected Image Info */}
      {selectedFile && (
        <div
          style={{
            marginTop: "16px",
            padding: "12px",
            backgroundColor: "#f1f2f4",
            borderRadius: "8px",
            display: "flex",
            alignItems: "center",
            gap: "12px",
          }}
        >
          {selectedFile.image?.url && (
            <img
              src={selectedFile.image.url}
              alt={selectedFile.alt || "Selected"}
              style={{
                width: "48px",
                height: "48px",
                objectFit: "cover",
                borderRadius: "4px",
              }}
            />
          )}
          <div style={{ flex: 1, minWidth: 0 }}>
            <div
              style={{
                fontWeight: 500,
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
              }}
            >
              {selectedFile.filename || "Selected image"}
            </div>
            <div style={{ fontSize: "12px", color: "#6d7175" }}>
              {formatDimensions(selectedFile)}
            </div>
          </div>
        </div>
      )}

      {/* Modal Actions - using commandFor/command pattern */}
      <s-button
        slot="secondary-actions"
        commandFor={IMAGE_PICKER_MODAL_ID}
        command="--hide"
      >
        Cancel
      </s-button>
      <s-button
        slot="primary-action"
        variant="primary"
        commandFor={IMAGE_PICKER_MODAL_ID}
        command="--hide"
        onClick={handleSelect}
        disabled={!selectedFile || undefined}
      >
        Done
      </s-button>
    </s-modal>
  );
}
</file>

<file path="app/components/preview/settings/index.ts">
export { SettingsPanel } from './SettingsPanel';
export { SettingField } from './SettingField';
export { TextSetting } from './TextSetting';
export { NumberSetting } from './NumberSetting';
export { SelectSetting } from './SelectSetting';
export { CheckboxSetting } from './CheckboxSetting';
export { ColorSetting } from './ColorSetting';
export { ImageSetting } from './ImageSetting';
</file>

<file path="app/components/preview/settings/LinkListSetting.tsx">
/**
 * LinkListSetting Component
 * Renders input for schema settings with type: "link_list"
 * Common values: main-menu, footer, header
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface LinkListSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function LinkListSetting({
  setting,
  value,
  onChange,
  disabled,
}: LinkListSettingProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-text-field
        label="Menu handle"
        value={value}
        placeholder="main-menu"
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <span style={{ fontSize: '12px', color: '#8c9196' }}>
        Common: main-menu, footer, header
      </span>
    </div>
  );
}
</file>

<file path="app/components/preview/settings/PageSetting.tsx">
/**
 * PageSetting Component
 * Renders input for schema settings with type: "page"
 * Uses handle-based input (App Bridge doesn't support page picker)
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface PageSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function PageSetting({
  setting,
  value,
  onChange,
  disabled,
}: PageSettingProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-text-field
        label="Page handle"
        value={value}
        placeholder="contact-us"
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/RadioSetting.tsx">
/**
 * RadioSetting Component
 * Renders radio button group for small option sets
 * Alternative to select dropdown (per Shopify docs: use when 5 options)
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface RadioSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function RadioSetting({ setting, value, onChange, disabled }: RadioSettingProps) {
  const options = setting.options || [];

  const handleChange = (optionValue: string) => {
    if (!disabled) {
      onChange(optionValue);
    }
  };

  // Generate unique name for radio group
  const groupName = `radio-${setting.id}`;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <div style={{
        display: 'flex',
        flexDirection: 'column',
        gap: '8px',
        padding: '8px 0'
      }}>
        {options.map((option) => (
          <label
            key={option.value}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              cursor: disabled ? 'not-allowed' : 'pointer',
              opacity: disabled ? 0.5 : 1,
            }}
          >
            <input
              type="radio"
              name={groupName}
              value={option.value}
              checked={value === option.value}
              onChange={() => handleChange(option.value)}
              disabled={disabled}
              style={{
                width: '16px',
                height: '16px',
                accentColor: '#000',
              }}
            />
            <span style={{ fontSize: '14px', color: '#202223' }}>
              {option.label}
            </span>
          </label>
        ))}
      </div>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/TextAlignmentSetting.tsx">
/**
 * TextAlignmentSetting Component
 * Renders alignment button group (left/center/right)
 * Uses segmented control pattern per Shopify design
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface TextAlignmentSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

const ALIGNMENT_OPTIONS = [
  { value: 'left', label: 'Left' },
  { value: 'center', label: 'Center' },
  { value: 'right', label: 'Right' },
];

export function TextAlignmentSetting({ setting, value, onChange, disabled }: TextAlignmentSettingProps) {
  const handleClick = (alignValue: string) => {
    if (!disabled) {
      onChange(alignValue);
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <div style={{
        display: 'flex',
        border: '1px solid #c9cccf',
        borderRadius: '4px',
        overflow: 'hidden',
        width: 'fit-content'
      }}>
        {ALIGNMENT_OPTIONS.map((option, index) => (
          <button
            key={option.value}
            type="button"
            onClick={() => handleClick(option.value)}
            disabled={disabled}
            style={{
              padding: '8px 16px',
              border: 'none',
              borderRight: index < ALIGNMENT_OPTIONS.length - 1 ? '1px solid #c9cccf' : 'none',
              backgroundColor: value === option.value ? '#000' : '#fff',
              color: value === option.value ? '#fff' : '#202223',
              cursor: disabled ? 'not-allowed' : 'pointer',
              fontWeight: 500,
              fontSize: '14px',
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
              opacity: disabled ? 0.5 : 1,
              transition: 'background-color 0.15s, color 0.15s'
            }}
            title={option.label}
          >
            {option.label}
          </button>
        ))}
      </div>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/VideoSetting.tsx">
/**
 * VideoSetting Component
 * Renders input for Shopify-hosted video (file_reference metafield)
 * In preview mode, accepts URL input for demonstration
 */

import type { SchemaSetting } from '../schema/SchemaTypes';

export interface VideoSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function VideoSetting({ setting, value, onChange, disabled }: VideoSettingProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  const handleClear = () => {
    onChange('');
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      {value ? (
        <div style={{
          border: '1px solid #e1e3e5',
          borderRadius: '8px',
          padding: '12px',
          backgroundColor: '#f6f6f7',
          display: 'flex',
          flexDirection: 'column',
          gap: '8px'
        }}>
          {/* Video preview */}
          <video
            src={value}
            style={{
              maxWidth: '100%',
              maxHeight: '120px',
              borderRadius: '4px'
            }}
            controls
            muted
            onError={(e) => {
              (e.target as HTMLVideoElement).style.display = 'none';
            }}
          />
          <s-button
            variant="secondary"
            tone="critical"
            onClick={handleClear}
            disabled={disabled || undefined}
          >
            Remove
          </s-button>
        </div>
      ) : (
        <div style={{
          border: '2px dashed #c9cccf',
          borderRadius: '8px',
          padding: '16px',
          backgroundColor: '#f6f6f7',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '8px'
        }}>
          <span style={{ color: '#6d7175' }}>Enter video URL for preview</span>
        </div>
      )}

      <s-text-field
        label="Video URL"
        value={value}
        placeholder="https://cdn.shopify.com/videos/..."
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <span style={{ fontSize: '12px', color: '#8c9196' }}>
        In Shopify, this uses the video upload picker. Enter URL for preview.
      </span>
    </div>
  );
}
</file>

<file path="app/components/preview/settings/VideoUrlSetting.tsx">
/**
 * VideoUrlSetting Component
 * Renders URL input for external video (YouTube/Vimeo)
 * Validates URL and shows video type and ID when valid
 */

import { useState, useEffect } from 'react';
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface VideoUrlSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

interface VideoInfo {
  type: 'youtube' | 'vimeo' | null;
  id: string | null;
}

/**
 * Extract video ID and type from URL
 */
function parseVideoUrl(url: string): VideoInfo {
  if (!url) return { type: null, id: null };

  // YouTube patterns
  const youtubeMatch = url.match(
    /(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/
  );
  if (youtubeMatch) {
    return { type: 'youtube', id: youtubeMatch[1] };
  }

  // Vimeo patterns
  const vimeoMatch = url.match(
    /(?:vimeo\.com\/(?:video\/)?|player\.vimeo\.com\/video\/)(\d+)/
  );
  if (vimeoMatch) {
    return { type: 'vimeo', id: vimeoMatch[1] };
  }

  return { type: null, id: null };
}

export function VideoUrlSetting({ setting, value, onChange, disabled }: VideoUrlSettingProps) {
  const [videoInfo, setVideoInfo] = useState<VideoInfo>({ type: null, id: null });

  useEffect(() => {
    setVideoInfo(parseVideoUrl(value));
  }, [value]);

  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  // Determine accepted types from setting (defaults to both)
  const acceptedTypes = setting.accept || ['youtube', 'vimeo'];
  const acceptHint = acceptedTypes.join(', ');

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      <s-text-field
        label="Video URL"
        value={value}
        placeholder="https://www.youtube.com/watch?v=..."
        disabled={disabled || undefined}
        onInput={handleInput}
      />

      {/* Video info display */}
      {videoInfo.type && videoInfo.id && (
        <div style={{
          padding: '8px 12px',
          backgroundColor: '#f6f6f7',
          borderRadius: '4px',
          fontSize: '13px'
        }}>
          <span style={{ color: '#6d7175' }}>
            {videoInfo.type === 'youtube' ? 'YouTube' : 'Vimeo'} video: {videoInfo.id}
          </span>
        </div>
      )}

      {/* Invalid URL warning */}
      {value && !videoInfo.type && (
        <span style={{ fontSize: '13px', color: '#d72c0d' }}>
          Could not parse video URL. Supported: {acceptHint}
        </span>
      )}

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <span style={{ fontSize: '12px', color: '#8c9196' }}>
        Accepted: {acceptHint}
      </span>
    </div>
  );
}
</file>

<file path="app/components/preview/utils/__tests__/colorFilters.test.ts">
import { colorFilters } from '../colorFilters';

describe('colorFilters', () => {
  describe('color_to_rgb', () => {
    it('converts hex to rgb', () => {
      expect(colorFilters.color_to_rgb('#ff0000')).toBe('rgb(255, 0, 0)');
      expect(colorFilters.color_to_rgb('#00ff00')).toBe('rgb(0, 255, 0)');
      expect(colorFilters.color_to_rgb('#0000ff')).toBe('rgb(0, 0, 255)');
    });

    it('converts short hex to rgb', () => {
      expect(colorFilters.color_to_rgb('#f00')).toBe('rgb(255, 0, 0)');
    });

    it('preserves alpha in rgba', () => {
      expect(colorFilters.color_to_rgb('#ff000080')).toBe('rgba(255, 0, 0, 0.5019607843137255)');
    });

    it('passes through rgb unchanged', () => {
      expect(colorFilters.color_to_rgb('rgb(255, 0, 0)')).toBe('rgb(255, 0, 0)');
    });

    it('returns original for invalid input', () => {
      expect(colorFilters.color_to_rgb('not-a-color')).toBe('not-a-color');
    });
  });

  describe('color_to_hsl', () => {
    it('converts hex to hsl', () => {
      expect(colorFilters.color_to_hsl('#ff0000')).toBe('hsl(0, 100%, 50%)');
      expect(colorFilters.color_to_hsl('#00ff00')).toBe('hsl(120, 100%, 50%)');
      expect(colorFilters.color_to_hsl('#0000ff')).toBe('hsl(240, 100%, 50%)');
    });

    it('converts rgb to hsl', () => {
      expect(colorFilters.color_to_hsl('rgb(255, 0, 0)')).toBe('hsl(0, 100%, 50%)');
    });
  });

  describe('color_to_hex', () => {
    it('converts rgb to hex', () => {
      expect(colorFilters.color_to_hex('rgb(255, 0, 0)')).toBe('#ff0000');
      expect(colorFilters.color_to_hex('rgb(0, 255, 0)')).toBe('#00ff00');
    });

    it('returns hex unchanged', () => {
      expect(colorFilters.color_to_hex('#ff0000')).toBe('#ff0000');
    });
  });

  describe('color_lighten', () => {
    it('lightens a color', () => {
      const result = colorFilters.color_lighten('#000000', 50);
      // Black lightened by 50% should be gray
      expect(result).toBe('rgb(128, 128, 128)');
    });

    it('does not exceed 100% lightness', () => {
      const result = colorFilters.color_lighten('#ffffff', 20);
      // Already white, should stay white
      expect(result).toBe('rgb(255, 255, 255)');
    });
  });

  describe('color_darken', () => {
    it('darkens a color', () => {
      const result = colorFilters.color_darken('#ffffff', 50);
      // White darkened by 50% should be gray
      expect(result).toBe('rgb(128, 128, 128)');
    });

    it('does not go below 0% lightness', () => {
      const result = colorFilters.color_darken('#000000', 20);
      // Already black, should stay black
      expect(result).toBe('rgb(0, 0, 0)');
    });
  });

  describe('color_saturate', () => {
    it('increases saturation', () => {
      // Gray has 0 saturation, increasing it makes it more colorful
      const result = colorFilters.color_saturate('hsl(0, 50%, 50%)', 25);
      expect(result).toMatch(/rgb\(\d+,\s*\d+,\s*\d+\)/);
    });
  });

  describe('color_desaturate', () => {
    it('decreases saturation', () => {
      const result = colorFilters.color_desaturate('#ff0000', 100);
      // Fully desaturated red should be gray
      expect(result).toBe('rgb(128, 128, 128)');
    });
  });

  describe('color_brightness', () => {
    it('returns high brightness for white', () => {
      expect(colorFilters.color_brightness('#ffffff')).toBeGreaterThan(200);
    });

    it('returns 0 brightness for black', () => {
      expect(colorFilters.color_brightness('#000000')).toBe(0);
    });

    it('returns middle brightness for gray', () => {
      const brightness = colorFilters.color_brightness('#808080');
      expect(brightness).toBeGreaterThan(100);
      expect(brightness).toBeLessThan(150);
    });
  });

  describe('color_modify', () => {
    it('modifies alpha', () => {
      expect(colorFilters.color_modify('#ff0000', 'alpha', 0.5)).toBe('rgba(255, 0, 0, 0.5)');
    });

    it('modifies hue', () => {
      const result = colorFilters.color_modify('#ff0000', 'hue', 120);
      // Changing hue from red (0) to green (120)
      expect(result).toMatch(/rgb\(\d+,\s*\d+,\s*\d+\)/);
    });

    it('modifies saturation', () => {
      const result = colorFilters.color_modify('#ff0000', 'saturation', 50);
      expect(result).toMatch(/rgb\(\d+,\s*\d+,\s*\d+\)/);
    });

    it('modifies lightness', () => {
      const result = colorFilters.color_modify('#ff0000', 'lightness', 75);
      expect(result).toMatch(/rgb\(\d+,\s*\d+,\s*\d+\)/);
    });
  });

  describe('color_mix', () => {
    it('mixes two colors equally', () => {
      const result = colorFilters.color_mix('#ff0000', '#0000ff', 50);
      // 50/50 mix of red and blue should be purple-ish
      expect(result).toMatch(/rgb\(\d+,\s*\d+,\s*\d+\)/);
    });

    it('weights toward first color', () => {
      const result = colorFilters.color_mix('#ff0000', '#0000ff', 100);
      expect(result).toBe('rgb(255, 0, 0)');
    });

    it('weights toward second color', () => {
      const result = colorFilters.color_mix('#ff0000', '#0000ff', 0);
      expect(result).toBe('rgb(0, 0, 255)');
    });
  });

  describe('color_contrast', () => {
    it('returns black for light colors', () => {
      expect(colorFilters.color_contrast('#ffffff')).toBe('#000000');
      expect(colorFilters.color_contrast('#ffff00')).toBe('#000000');
    });

    it('returns white for dark colors', () => {
      expect(colorFilters.color_contrast('#000000')).toBe('#ffffff');
      expect(colorFilters.color_contrast('#000080')).toBe('#ffffff');
    });
  });

  describe('color_extract', () => {
    it('extracts red component', () => {
      expect(colorFilters.color_extract('#ff0000', 'red')).toBe(255);
      expect(colorFilters.color_extract('#000000', 'red')).toBe(0);
    });

    it('extracts green component', () => {
      expect(colorFilters.color_extract('#00ff00', 'green')).toBe(255);
    });

    it('extracts blue component', () => {
      expect(colorFilters.color_extract('#0000ff', 'blue')).toBe(255);
    });

    it('extracts alpha component', () => {
      expect(colorFilters.color_extract('#ff0000', 'alpha')).toBe(1);
      expect(colorFilters.color_extract('rgba(255, 0, 0, 0.5)', 'alpha')).toBe(0.5);
    });

    it('extracts hue', () => {
      expect(colorFilters.color_extract('#ff0000', 'hue')).toBe(0);
      expect(colorFilters.color_extract('#00ff00', 'hue')).toBe(120);
    });

    it('extracts saturation', () => {
      expect(colorFilters.color_extract('#ff0000', 'saturation')).toBe(100);
      expect(colorFilters.color_extract('#808080', 'saturation')).toBe(0);
    });

    it('extracts lightness', () => {
      expect(colorFilters.color_extract('#ffffff', 'lightness')).toBe(100);
      expect(colorFilters.color_extract('#000000', 'lightness')).toBe(0);
    });
  });
});
</file>

<file path="app/components/preview/utils/__tests__/liquidFilters.test.ts">
import { arrayFilters, stringFilters, mathFilters } from '../liquidFilters';

// ============================================================================
// Array Filters Tests
// ============================================================================

describe('arrayFilters', () => {
  describe('first', () => {
    it('returns first element of array', () => {
      expect(arrayFilters.first([1, 2, 3])).toBe(1);
      expect(arrayFilters.first(['a', 'b', 'c'])).toBe('a');
    });

    it('returns undefined for empty array', () => {
      expect(arrayFilters.first([])).toBeUndefined();
    });

    it('handles undefined/null input', () => {
      expect(arrayFilters.first(undefined as unknown as [])).toBeUndefined();
    });
  });

  describe('last', () => {
    it('returns last element of array', () => {
      expect(arrayFilters.last([1, 2, 3])).toBe(3);
      expect(arrayFilters.last(['a', 'b', 'c'])).toBe('c');
    });

    it('returns undefined for empty array', () => {
      expect(arrayFilters.last([])).toBeUndefined();
    });
  });

  describe('map', () => {
    it('extracts property values from objects', () => {
      const arr = [{ title: 'A' }, { title: 'B' }, { title: 'C' }];
      expect(arrayFilters.map(arr, 'title')).toEqual(['A', 'B', 'C']);
    });

    it('returns undefined for missing properties', () => {
      const arr = [{ title: 'A' }, { name: 'B' }];
      expect(arrayFilters.map(arr, 'title')).toEqual(['A', undefined]);
    });

    it('returns empty array for non-array input', () => {
      expect(arrayFilters.map('not array' as unknown as [], 'key')).toEqual([]);
    });
  });

  describe('compact', () => {
    it('removes null and undefined values', () => {
      expect(arrayFilters.compact([1, null, 2, undefined, 3])).toEqual([1, 2, 3]);
    });

    it('keeps falsy values like 0 and empty string', () => {
      expect(arrayFilters.compact([0, '', false, null, undefined])).toEqual([0, '', false]);
    });
  });

  describe('concat', () => {
    it('concatenates two arrays', () => {
      expect(arrayFilters.concat([1, 2], [3, 4])).toEqual([1, 2, 3, 4]);
    });

    it('handles empty arrays', () => {
      expect(arrayFilters.concat([], [1, 2])).toEqual([1, 2]);
      expect(arrayFilters.concat([1, 2], [])).toEqual([1, 2]);
    });
  });

  describe('reverse', () => {
    it('reverses array', () => {
      expect(arrayFilters.reverse([1, 2, 3])).toEqual([3, 2, 1]);
    });

    it('does not mutate original array', () => {
      const original = [1, 2, 3];
      arrayFilters.reverse(original);
      expect(original).toEqual([1, 2, 3]);
    });
  });

  describe('sort', () => {
    it('sorts simple array', () => {
      expect(arrayFilters.sort([3, 1, 2])).toEqual([1, 2, 3]);
    });

    it('sorts by property key', () => {
      const arr = [{ price: 30 }, { price: 10 }, { price: 20 }];
      expect(arrayFilters.sort(arr, 'price')).toEqual([
        { price: 10 },
        { price: 20 },
        { price: 30 },
      ]);
    });

    it('sorts strings alphabetically by key', () => {
      const arr = [{ name: 'Charlie' }, { name: 'Alice' }, { name: 'Bob' }];
      expect(arrayFilters.sort(arr, 'name')).toEqual([
        { name: 'Alice' },
        { name: 'Bob' },
        { name: 'Charlie' },
      ]);
    });
  });

  describe('sort_natural', () => {
    it('sorts case-insensitively', () => {
      expect(arrayFilters.sort_natural(['Banana', 'apple', 'Cherry'])).toEqual([
        'apple',
        'Banana',
        'Cherry',
      ]);
    });

    it('sorts by key case-insensitively', () => {
      const arr = [{ name: 'Banana' }, { name: 'apple' }, { name: 'Cherry' }];
      expect(arrayFilters.sort_natural(arr, 'name')).toEqual([
        { name: 'apple' },
        { name: 'Banana' },
        { name: 'Cherry' },
      ]);
    });
  });

  describe('uniq', () => {
    it('returns unique values', () => {
      expect(arrayFilters.uniq([1, 2, 2, 3, 1, 3])).toEqual([1, 2, 3]);
    });

    it('preserves order of first occurrence', () => {
      expect(arrayFilters.uniq(['b', 'a', 'b', 'c', 'a'])).toEqual(['b', 'a', 'c']);
    });
  });

  describe('find', () => {
    it('finds object by property value', () => {
      const arr = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];
      expect(arrayFilters.find(arr, 'id', 2)).toEqual({ id: 2, name: 'B' });
    });

    it('returns undefined if not found', () => {
      const arr = [{ id: 1 }, { id: 2 }];
      expect(arrayFilters.find(arr, 'id', 3)).toBeUndefined();
    });
  });

  describe('reject', () => {
    it('filters out matching items', () => {
      const arr = [
        { status: 'active' },
        { status: 'inactive' },
        { status: 'active' },
      ];
      expect(arrayFilters.reject(arr, 'status', 'inactive')).toEqual([
        { status: 'active' },
        { status: 'active' },
      ]);
    });
  });
});

// ============================================================================
// String Filters Tests
// ============================================================================

describe('stringFilters', () => {
  describe('escape_once', () => {
    it('escapes HTML entities', () => {
      expect(stringFilters.escape_once('<script>alert("xss")</script>')).toBe(
        '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'
      );
    });

    it('does not double-escape already escaped entities', () => {
      // Already-escaped entities should not be double-escaped
      expect(stringFilters.escape_once('&lt;div&gt;')).toBe('&lt;div&gt;');
      expect(stringFilters.escape_once('&amp;')).toBe('&amp;');
    });

    it('prevents XSS via multi-encoded inputs', () => {
      // Should NOT unescape &amp;lt; to &lt; to <
      const result = stringFilters.escape_once('&amp;lt;script&amp;gt;');
      expect(result).not.toContain('<script>');
    });
  });

  describe('newline_to_br', () => {
    it('converts newlines to br tags', () => {
      expect(stringFilters.newline_to_br('Line 1\nLine 2\nLine 3')).toBe(
        'Line 1<br>Line 2<br>Line 3'
      );
    });
  });

  describe('strip_html', () => {
    it('removes all HTML tags', () => {
      expect(stringFilters.strip_html('<p>Hello <b>World</b></p>')).toBe('Hello World');
    });

    it('handles self-closing tags', () => {
      expect(stringFilters.strip_html('Line 1<br/>Line 2')).toBe('Line 1Line 2');
    });
  });

  describe('strip_newlines', () => {
    it('removes newlines', () => {
      expect(stringFilters.strip_newlines('Line 1\nLine 2\r\nLine 3')).toBe('Line 1Line 2Line 3');
    });
  });

  describe('url_encode', () => {
    it('encodes special characters', () => {
      expect(stringFilters.url_encode('hello world')).toBe('hello%20world');
      expect(stringFilters.url_encode('foo=bar&baz=qux')).toBe('foo%3Dbar%26baz%3Dqux');
    });
  });

  describe('url_decode', () => {
    it('decodes URL-encoded strings', () => {
      expect(stringFilters.url_decode('hello%20world')).toBe('hello world');
    });

    it('handles invalid encoding gracefully', () => {
      expect(stringFilters.url_decode('%invalid')).toBe('%invalid');
    });
  });

  describe('base64_encode', () => {
    it('encodes to base64', () => {
      expect(stringFilters.base64_encode('Hello, World!')).toBe('SGVsbG8sIFdvcmxkIQ==');
    });

    it('handles Unicode and emoji characters', () => {
      const encoded = stringFilters.base64_encode('Hello  ');
      expect(encoded).toBeTruthy();
      expect(typeof encoded).toBe('string');
      // Should be able to decode back
      expect(stringFilters.base64_decode(encoded)).toBe('Hello  ');
    });
  });

  describe('base64_decode', () => {
    it('decodes from base64', () => {
      expect(stringFilters.base64_decode('SGVsbG8sIFdvcmxkIQ==')).toBe('Hello, World!');
    });

    it('handles invalid base64 gracefully', () => {
      expect(stringFilters.base64_decode('!!!invalid!!!')).toBe('!!!invalid!!!');
    });
  });

  describe('md5', () => {
    it('returns a 32-character hash', () => {
      const hash = stringFilters.md5('test');
      expect(hash).toHaveLength(32);
      expect(hash).toMatch(/^[0-9a-f]+$/);
    });
  });

  describe('sha256', () => {
    it('returns a 64-character hash', () => {
      const hash = stringFilters.sha256('test');
      expect(hash).toHaveLength(64);
      expect(hash).toMatch(/^[0-9a-f]+$/);
    });
  });

  describe('remove_first', () => {
    it('removes first occurrence', () => {
      expect(stringFilters.remove_first('hello hello world', 'hello ')).toBe('hello world');
    });

    it('returns unchanged if not found', () => {
      expect(stringFilters.remove_first('hello', 'xyz')).toBe('hello');
    });
  });

  describe('remove_last', () => {
    it('removes last occurrence', () => {
      expect(stringFilters.remove_last('hello hello world', 'hello')).toBe('hello  world');
    });
  });

  describe('replace_first', () => {
    it('replaces first occurrence', () => {
      expect(stringFilters.replace_first('hello hello', 'hello', 'hi')).toBe('hi hello');
    });
  });

  describe('replace_last', () => {
    it('replaces last occurrence', () => {
      expect(stringFilters.replace_last('hello hello', 'hello', 'hi')).toBe('hello hi');
    });
  });

  describe('slice', () => {
    it('extracts substring from start', () => {
      expect(stringFilters.slice('hello world', 0, 5)).toBe('hello');
    });

    it('extracts to end if length not specified', () => {
      expect(stringFilters.slice('hello world', 6)).toBe('world');
    });

    it('handles negative start index', () => {
      expect(stringFilters.slice('hello world', -5)).toBe('world');
    });
  });

  describe('camelize', () => {
    it('converts hyphenated to camelCase', () => {
      expect(stringFilters.camelize('hello-world')).toBe('helloWorld');
    });

    it('converts underscored to camelCase', () => {
      expect(stringFilters.camelize('hello_world')).toBe('helloWorld');
    });

    it('converts spaces to camelCase', () => {
      expect(stringFilters.camelize('hello world')).toBe('helloWorld');
    });
  });
});

// ============================================================================
// Math Filters Tests
// ============================================================================

describe('mathFilters', () => {
  describe('abs', () => {
    it('returns absolute value', () => {
      expect(mathFilters.abs(-5)).toBe(5);
      expect(mathFilters.abs(5)).toBe(5);
    });

    it('handles string numbers', () => {
      expect(mathFilters.abs('-10' as unknown as number)).toBe(10);
    });
  });

  describe('at_least', () => {
    it('returns num if greater than min', () => {
      expect(mathFilters.at_least(15, 10)).toBe(15);
    });

    it('returns min if num is less', () => {
      expect(mathFilters.at_least(5, 10)).toBe(10);
    });
  });

  describe('at_most', () => {
    it('returns num if less than max', () => {
      expect(mathFilters.at_most(5, 10)).toBe(5);
    });

    it('returns max if num is greater', () => {
      expect(mathFilters.at_most(15, 10)).toBe(10);
    });
  });

  describe('ceil', () => {
    it('rounds up to nearest integer', () => {
      expect(mathFilters.ceil(1.2)).toBe(2);
      expect(mathFilters.ceil(1.8)).toBe(2);
    });
  });

  describe('floor', () => {
    it('rounds down to nearest integer', () => {
      expect(mathFilters.floor(1.2)).toBe(1);
      expect(mathFilters.floor(1.8)).toBe(1);
    });
  });

  describe('round', () => {
    it('rounds to nearest integer by default', () => {
      expect(mathFilters.round(3.4)).toBe(3);
      expect(mathFilters.round(3.5)).toBe(4);
    });

    it('rounds to specified precision', () => {
      expect(mathFilters.round(3.14159, 2)).toBe(3.14);
      expect(mathFilters.round(3.14159, 4)).toBe(3.1416);
    });
  });

  describe('plus', () => {
    it('adds two numbers', () => {
      expect(mathFilters.plus(5, 3)).toBe(8);
    });

    it('handles string numbers', () => {
      expect(mathFilters.plus('5' as unknown as number, '3' as unknown as number)).toBe(8);
    });
  });

  describe('minus', () => {
    it('subtracts second from first', () => {
      expect(mathFilters.minus(10, 3)).toBe(7);
    });
  });
});
</file>

<file path="app/components/preview/utils/__tests__/liquidTags.test.ts">
import { Liquid } from 'liquidjs';
import { registerShopifyTags } from '../liquidTags';

// Helper to create a configured engine
function createEngine(): Liquid {
  const engine = new Liquid({ strictFilters: false, strictVariables: false });
  registerShopifyTags(engine);
  return engine;
}

describe('Shopify Liquid Tags', () => {
  let engine: Liquid;

  beforeEach(() => {
    engine = createEngine();
  });

  // =========================================================================
  // Style Tag Tests
  // =========================================================================
  describe('{% style %} tag', () => {
    it('outputs CSS wrapped in style tag with data attribute', async () => {
      const template = '{% style %}.test { color: red; }{% endstyle %}';
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<style data-shopify-style>.test { color: red; }</style>');
    });

    it('processes Liquid variables in CSS', async () => {
      const template = '{% style %}.test { color: {{ color }}; }{% endstyle %}';
      const result = await engine.parseAndRender(template, { color: 'blue' });
      expect(result).toBe('<style data-shopify-style>.test { color: blue; }</style>');
    });

    it('handles empty style block', async () => {
      const template = '{% style %}{% endstyle %}';
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<style data-shopify-style></style>');
    });
  });

  // =========================================================================
  // Liquid Tag Tests
  // =========================================================================
  describe('{% liquid %} tag', () => {
    it('processes multiple statements', async () => {
      const template = `{% liquid
assign x = "hello"
echo x
%}`;
      const result = await engine.parseAndRender(template);
      expect(result.trim()).toBe('hello');
    });

    it('handles assign and conditionals', async () => {
      const template = `{% liquid
assign show = true
if show
  echo "visible"
endif
%}`;
      const result = await engine.parseAndRender(template);
      expect(result).toContain('visible');
    });

    it('handles empty liquid block', async () => {
      const template = '{% liquid %}';
      const result = await engine.parseAndRender(template);
      expect(result).toBe('');
    });
  });

  // =========================================================================
  // Include Tag Tests
  // =========================================================================
  describe('{% include %} tag', () => {
    it('outputs placeholder comment with snippet name', async () => {
      const template = "{% include 'product-card' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Include snippet: product-card (not loaded in preview, shared scope) -->');
    });

    it('handles variables in args', async () => {
      const template = "{% include 'icon', icon: 'star' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toContain('icon');
    });
  });

  // =========================================================================
  // Tablerow Tag Tests
  // =========================================================================
  describe('{% tablerow %} tag', () => {
    it('generates table rows and cells', async () => {
      const template = '{% tablerow item in items %}{{ item }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b', 'c'] });
      expect(result).toContain('<tr class="row1">');
      expect(result).toContain('<td class="col1">a</td>');
      expect(result).toContain('<td class="col2">b</td>');
      expect(result).toContain('<td class="col3">c</td>');
      expect(result).toContain('</tr>');
    });

    it('respects cols option', async () => {
      const template = '{% tablerow item in items cols:2 %}{{ item }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b', 'c', 'd'] });
      // Should have 2 rows with 2 cols each
      expect(result).toContain('<tr class="row1">');
      expect(result).toContain('<tr class="row2">');
    });

    it('provides tablerowloop variables', async () => {
      const template = '{% tablerow item in items %}{{ tablerowloop.index }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b'] });
      expect(result).toContain('>1<');
      expect(result).toContain('>2<');
    });

    it('provides forloop inside tablerow', async () => {
      const template = '{% tablerow item in items %}{{ forloop.index }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b'] });
      expect(result).toContain('>1<');
      expect(result).toContain('>2<');
    });

    it('handles limit option', async () => {
      const template = '{% tablerow item in items limit:2 %}{{ item }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b', 'c', 'd'] });
      expect(result).toContain('a');
      expect(result).toContain('b');
      expect(result).not.toContain('>c<');
      expect(result).not.toContain('>d<');
    });

    it('handles offset option', async () => {
      const template = '{% tablerow item in items offset:2 %}{{ item }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: ['a', 'b', 'c', 'd'] });
      expect(result).not.toContain('>a<');
      expect(result).not.toContain('>b<');
      expect(result).toContain('c');
      expect(result).toContain('d');
    });

    it('handles empty collection', async () => {
      const template = '{% tablerow item in items %}{{ item }}{% endtablerow %}';
      const result = await engine.parseAndRender(template, { items: [] });
      expect(result).toBe('');
    });
  });

  // =========================================================================
  // Layout Stub Tests
  // =========================================================================
  describe('{% layout %} stub', () => {
    it('outputs comment with layout name', async () => {
      const template = "{% layout 'alternate' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Layout: alternate (not applied in section preview) -->');
    });

    it('handles layout none', async () => {
      const template = '{% layout none %}';
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Layout: none (not applied in section preview) -->');
    });
  });

  // =========================================================================
  // Content_for Stub Tests
  // =========================================================================
  describe('{% content_for %} stub', () => {
    it('wraps content in comments', async () => {
      const template = "{% content_for 'header' %}<h1>Title</h1>{% endcontent_for %}";
      const result = await engine.parseAndRender(template);
      expect(result).toContain('<!-- content_for block -->');
      expect(result).toContain('<h1>Title</h1>');
      expect(result).toContain('<!-- end content_for -->');
    });

    it('renders Liquid inside content_for', async () => {
      const template = "{% content_for 'header' %}{{ title }}{% endcontent_for %}";
      const result = await engine.parseAndRender(template, { title: 'Hello' });
      expect(result).toContain('Hello');
    });
  });

  // =========================================================================
  // Sections Stub Tests
  // =========================================================================
  describe('{% sections %} stub', () => {
    it('outputs comment with group name', async () => {
      const template = "{% sections 'footer' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Sections group: footer (not rendered in single section preview) -->');
    });
  });

  // =========================================================================
  // Form Tag Tests (existing)
  // =========================================================================
  describe('{% form %} tag', () => {
    it('wraps content in form element', async () => {
      const template = "{% form 'contact' %}<input type='text'>{% endform %}";
      const result = await engine.parseAndRender(template);
      expect(result).toContain('<form method="post"');
      expect(result).toContain('class="shopify-form shopify-form-contact"');
      expect(result).toContain("<input type='text'>");
      expect(result).toContain('</form>');
    });

    it('provides form context variable', async () => {
      const template = "{% form 'contact' %}{{ form.id }}{% endform %}";
      const result = await engine.parseAndRender(template);
      expect(result).toContain('form-contact-preview');
    });
  });

  // =========================================================================
  // Section and Render Tags (existing)
  // =========================================================================
  describe('{% section %} tag', () => {
    it('outputs comment placeholder', async () => {
      const template = "{% section 'header' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Section: header (not rendered in preview) -->');
    });
  });

  describe('{% render %} tag', () => {
    it('outputs comment placeholder', async () => {
      const template = "{% render 'icon-star' %}";
      const result = await engine.parseAndRender(template);
      expect(result).toBe('<!-- Render snippet: icon-star (not loaded in preview) -->');
    });
  });
});
</file>

<file path="app/components/preview/utils/colorFilters.ts">
/**
 * Shopify Liquid Color Filter Implementations
 * Color manipulation and conversion filters for section preview rendering
 */

interface RGBA {
  r: number;
  g: number;
  b: number;
  a: number;
}

interface HSL {
  h: number;
  s: number;
  l: number;
}

/**
 * Parses color string (hex/rgb/rgba/hsl/hsla) to RGBA object
 */
function parseColor(color: string): RGBA | null {
  if (!color || typeof color !== 'string') return null;
  const s = color.trim().toLowerCase();

  // Hex format: #rgb, #rrggbb, #rrggbbaa
  if (s.startsWith('#')) {
    const hex = s.slice(1);
    if (hex.length === 3) {
      return {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16),
        a: 1,
      };
    }
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
        a: 1,
      };
    }
    if (hex.length === 8) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
        a: parseInt(hex.slice(6, 8), 16) / 255,
      };
    }
  }

  // RGB(A) format: rgb(r, g, b) or rgba(r, g, b, a)
  const rgbMatch = s.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/);
  if (rgbMatch) {
    return {
      r: parseInt(rgbMatch[1], 10),
      g: parseInt(rgbMatch[2], 10),
      b: parseInt(rgbMatch[3], 10),
      a: rgbMatch[4] ? parseFloat(rgbMatch[4]) : 1,
    };
  }

  // HSL(A) format: hsl(h, s%, l%) or hsla(h, s%, l%, a)
  const hslMatch = s.match(/hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([\d.]+)\s*)?\)/);
  if (hslMatch) {
    const rgb = hslToRgb(parseInt(hslMatch[1], 10), parseInt(hslMatch[2], 10), parseInt(hslMatch[3], 10));
    return {
      ...rgb,
      a: hslMatch[4] ? parseFloat(hslMatch[4]) : 1,
    };
  }

  return null;
}

/**
 * Converts RGB to HSL
 */
function rgbToHsl(r: number, g: number, b: number): HSL {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100),
  };
}

/**
 * Converts HSL to RGB
 */
function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  h /= 360;
  s /= 100;
  l /= 100;
  let r: number, g: number, b: number;

  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
  };
}

/**
 * Clamps value between min and max
 */
function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

// ============================================================================
// Color Filter Exports
// ============================================================================

export const colorFilters = {
  /** Converts color to RGB/RGBA format */
  color_to_rgb: (color: string): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    return parsed.a < 1
      ? `rgba(${parsed.r}, ${parsed.g}, ${parsed.b}, ${parsed.a})`
      : `rgb(${parsed.r}, ${parsed.g}, ${parsed.b})`;
  },

  /** Converts color to HSL/HSLA format */
  color_to_hsl: (color: string): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
    return parsed.a < 1
      ? `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${parsed.a})`
      : `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
  },

  /** Converts color to hex format */
  color_to_hex: (color: string): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const toHex = (n: number) => n.toString(16).padStart(2, '0');
    return `#${toHex(parsed.r)}${toHex(parsed.g)}${toHex(parsed.b)}`;
  },

  /** Lightens color by amount (0-100) */
  color_lighten: (color: string, amount: number): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
    hsl.l = clamp(hsl.l + (Number(amount) || 0), 0, 100);
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return parsed.a < 1
      ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parsed.a})`
      : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
  },

  /** Darkens color by amount (0-100) */
  color_darken: (color: string, amount: number): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
    hsl.l = clamp(hsl.l - (Number(amount) || 0), 0, 100);
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return parsed.a < 1
      ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parsed.a})`
      : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
  },

  /** Increases saturation by amount (0-100) */
  color_saturate: (color: string, amount: number): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
    hsl.s = clamp(hsl.s + (Number(amount) || 0), 0, 100);
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return parsed.a < 1
      ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parsed.a})`
      : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
  },

  /** Decreases saturation by amount (0-100) */
  color_desaturate: (color: string, amount: number): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
    hsl.s = clamp(hsl.s - (Number(amount) || 0), 0, 100);
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return parsed.a < 1
      ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parsed.a})`
      : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
  },

  /** Returns perceived brightness (0-255) */
  color_brightness: (color: string): number => {
    const parsed = parseColor(color);
    if (!parsed) return 0;
    // Perceived brightness formula (ITU-R BT.601)
    return Math.round((parsed.r * 299 + parsed.g * 587 + parsed.b * 114) / 1000);
  },

  /** Modifies a specific color attribute */
  color_modify: (color: string, attr: string, value: number): string => {
    const parsed = parseColor(color);
    if (!parsed) return color;
    const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);

    switch (attr) {
      case 'alpha':
        return `rgba(${parsed.r}, ${parsed.g}, ${parsed.b}, ${clamp(Number(value), 0, 1)})`;
      case 'hue':
        hsl.h = ((Number(value) % 360) + 360) % 360;
        break;
      case 'saturation':
        hsl.s = clamp(Number(value), 0, 100);
        break;
      case 'lightness':
        hsl.l = clamp(Number(value), 0, 100);
        break;
      default:
        return color;
    }

    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return parsed.a < 1
      ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parsed.a})`
      : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
  },

  /** Mixes two colors with optional weight (0-100, default 50) */
  color_mix: (color1: string, color2: string, weight = 50): string => {
    const c1 = parseColor(color1);
    const c2 = parseColor(color2);
    if (!c1 || !c2) return color1;

    const w = clamp(Number(weight), 0, 100) / 100;
    const r = Math.round(c1.r * w + c2.r * (1 - w));
    const g = Math.round(c1.g * w + c2.g * (1 - w));
    const b = Math.round(c1.b * w + c2.b * (1 - w));
    const a = c1.a * w + c2.a * (1 - w);

    return a < 1 ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;
  },

  /** Returns contrasting color (black or white) based on brightness */
  color_contrast: (color: string): string => {
    const parsed = parseColor(color);
    if (!parsed) return '#000000';
    const brightness = (parsed.r * 299 + parsed.g * 587 + parsed.b * 114) / 1000;
    return brightness > 128 ? '#000000' : '#ffffff';
  },

  /** Extracts a specific color component */
  color_extract: (color: string, component: string): number => {
    const parsed = parseColor(color);
    if (!parsed) return 0;

    switch (component) {
      case 'red':
        return parsed.r;
      case 'green':
        return parsed.g;
      case 'blue':
        return parsed.b;
      case 'alpha':
        return parsed.a;
      case 'hue': {
        const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
        return hsl.h;
      }
      case 'saturation': {
        const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
        return hsl.s;
      }
      case 'lightness': {
        const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
        return hsl.l;
      }
      default:
        return 0;
    }
  },
};
</file>

<file path="app/components/preview/utils/liquidFilters.ts">
/**
 * Shopify Liquid Filter Implementations
 * Array, String, and Math filters for section preview rendering
 */

// ============================================================================
// Input Validation Constants
// ============================================================================

const MAX_ARRAY_SIZE = 10000;
const MAX_STRING_LENGTH = 100000;

/** Validates and truncates arrays to prevent DoS */
function validateArraySize<T>(arr: T[]): T[] {
  if (!Array.isArray(arr)) return [];
  if (arr.length > MAX_ARRAY_SIZE) {
    console.warn(`Liquid filter: Array exceeds max size (${MAX_ARRAY_SIZE}), truncating`);
    return arr.slice(0, MAX_ARRAY_SIZE);
  }
  return arr;
}

/** Validates and truncates strings to prevent DoS */
function validateStringLength(str: unknown): string {
  const s = String(str ?? '');
  if (s.length > MAX_STRING_LENGTH) {
    console.warn(`Liquid filter: String exceeds max length (${MAX_STRING_LENGTH}), truncating`);
    return s.slice(0, MAX_STRING_LENGTH);
  }
  return s;
}

// ============================================================================
// Array Filters
// ============================================================================

export const arrayFilters = {
  /** Returns first element of array */
  first: <T>(arr: T[]): T | undefined => arr?.[0],

  /** Returns last element of array */
  last: <T>(arr: T[]): T | undefined => arr?.[arr?.length - 1],

  /** Extracts property values from array of objects */
  map: <T>(arr: T[], key: string): unknown[] => {
    const validated = validateArraySize(arr);
    return validated.map((item) => {
      if (item != null && typeof item === 'object') {
        return (item as Record<string, unknown>)[key];
      }
      return undefined;
    });
  },

  /** Removes null/undefined values from array */
  compact: <T>(arr: T[]): T[] => arr?.filter((item) => item != null) ?? [],

  /** Concatenates two arrays */
  concat: <T>(arr1: T[], arr2: T[]): T[] => [...(arr1 ?? []), ...(arr2 ?? [])],

  /** Reverses array order */
  reverse: <T>(arr: T[]): T[] => [...(arr ?? [])].reverse(),

  /** Sorts array by optional property key */
  sort: <T>(arr: T[], key?: string): T[] => {
    const validated = validateArraySize(arr);
    const copy = [...validated];
    if (key) {
      return copy.sort((a, b) => {
        if (a == null || b == null) return 0;
        const aVal = (a as Record<string, unknown>)[key];
        const bVal = (b as Record<string, unknown>)[key];
        if (typeof aVal === 'string' && typeof bVal === 'string') {
          return aVal.localeCompare(bVal);
        }
        return Number(aVal) - Number(bVal);
      });
    }
    return copy.sort();
  },

  /** Case-insensitive natural sort */
  sort_natural: <T>(arr: T[], key?: string): T[] => {
    const validated = validateArraySize(arr);
    const copy = [...validated];
    return copy.sort((a, b) => {
      const aVal = key && a != null ? String((a as Record<string, unknown>)[key]) : String(a ?? '');
      const bVal = key && b != null ? String((b as Record<string, unknown>)[key]) : String(b ?? '');
      return aVal.toLowerCase().localeCompare(bVal.toLowerCase());
    });
  },

  /** Returns unique values */
  uniq: <T>(arr: T[]): T[] => [...new Set(arr ?? [])],

  /** Finds first item matching property value */
  find: <T>(arr: T[], key: string, value: unknown): T | undefined => {
    const validated = validateArraySize(arr);
    return validated.find((item) => {
      if (item == null || typeof item !== 'object') return false;
      return (item as Record<string, unknown>)[key] === value;
    });
  },

  /** Filters out items matching property value */
  reject: <T>(arr: T[], key: string, value: unknown): T[] => {
    const validated = validateArraySize(arr);
    return validated.filter((item) => {
      if (item == null || typeof item !== 'object') return true;
      return (item as Record<string, unknown>)[key] !== value;
    });
  },
};

// ============================================================================
// String Filters
// ============================================================================

export const stringFilters = {
  /** Escapes HTML but doesn't double-escape already-escaped entities */
  escape_once: (str: string): string => {
    const s = validateStringLength(str);
    // Use lookahead to only escape unescaped characters (don't double-escape)
    return s
      .replace(/&(?!(amp|lt|gt|quot|#39|#\d+);)/gi, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  },

  /** Converts newlines to <br> tags */
  newline_to_br: (str: string): string => String(str ?? '').replace(/\n/g, '<br>'),

  /** Strips all HTML tags */
  strip_html: (str: string): string => {
    const s = validateStringLength(str);
    // Use limited regex to prevent catastrophic backtracking
    return s.replace(/<[^>]{0,1000}>/g, '');
  },

  /** Removes all newline characters */
  strip_newlines: (str: string): string => String(str ?? '').replace(/[\r\n]+/g, ''),

  /** URL encodes a string */
  url_encode: (str: string): string => encodeURIComponent(String(str ?? '')),

  /** URL decodes a string */
  url_decode: (str: string): string => {
    try {
      return decodeURIComponent(String(str ?? ''));
    } catch {
      return String(str ?? '');
    }
  },

  /** Base64 encodes a string (handles Unicode via TextEncoder) */
  base64_encode: (str: string): string => {
    try {
      const s = validateStringLength(str);
      // Use TextEncoder for proper UTF-8 handling (supports Unicode/emoji)
      const bytes = new TextEncoder().encode(s);
      const binString = Array.from(bytes, (byte) => String.fromCodePoint(byte)).join('');
      return btoa(binString);
    } catch {
      return String(str ?? '');
    }
  },

  /** Base64 decodes a string (handles Unicode via TextDecoder) */
  base64_decode: (str: string): string => {
    try {
      const s = String(str ?? '');
      const binString = atob(s);
      const bytes = Uint8Array.from(binString, (char) => char.codePointAt(0) ?? 0);
      return new TextDecoder().decode(bytes);
    } catch {
      return String(str ?? '');
    }
  },

  /** MD5 hash placeholder - returns mock hash for preview */
  md5: (str: string): string => {
    // Simple hash for preview purposes (not cryptographically secure)
    const s = String(str ?? '');
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      const char = s.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).padStart(32, '0').slice(0, 32);
  },

  /** SHA256 hash placeholder - returns mock hash for preview */
  sha256: (str: string): string => {
    const s = String(str ?? '');
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      const char = s.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).padStart(64, '0').slice(0, 64);
  },

  /** HMAC SHA256 placeholder */
  hmac_sha256: (str: string, _secret: string): string => {
    return stringFilters.sha256(str);
  },

  /** Removes first occurrence of substring */
  remove_first: (str: string, sub: string): string => {
    const s = String(str ?? '');
    const idx = s.indexOf(sub);
    return idx === -1 ? s : s.slice(0, idx) + s.slice(idx + sub.length);
  },

  /** Removes last occurrence of substring */
  remove_last: (str: string, sub: string): string => {
    const s = String(str ?? '');
    const idx = s.lastIndexOf(sub);
    return idx === -1 ? s : s.slice(0, idx) + s.slice(idx + sub.length);
  },

  /** Replaces first occurrence */
  replace_first: (str: string, old: string, replacement: string): string => {
    const s = String(str ?? '');
    const idx = s.indexOf(old);
    return idx === -1 ? s : s.slice(0, idx) + replacement + s.slice(idx + old.length);
  },

  /** Replaces last occurrence */
  replace_last: (str: string, old: string, replacement: string): string => {
    const s = String(str ?? '');
    const idx = s.lastIndexOf(old);
    return idx === -1 ? s : s.slice(0, idx) + replacement + s.slice(idx + old.length);
  },

  /** Extracts substring from start position with optional length */
  slice: (str: string, start: number, length?: number): string => {
    const s = String(str ?? '');
    // Handle negative start index (from end)
    const startIdx = start < 0 ? Math.max(0, s.length + start) : start;
    return length !== undefined ? s.slice(startIdx, startIdx + length) : s.slice(startIdx);
  },

  /** Converts to camelCase */
  camelize: (str: string): string => {
    return String(str ?? '').replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''));
  },
};

// ============================================================================
// Math Filters
// ============================================================================

export const mathFilters = {
  /** Returns absolute value */
  abs: (num: number): number => Math.abs(Number(num) || 0),

  /** Returns maximum of num and min */
  at_least: (num: number, min: number): number => Math.max(Number(num) || 0, Number(min) || 0),

  /** Returns minimum of num and max */
  at_most: (num: number, max: number): number => Math.min(Number(num) || 0, Number(max) || 0),

  /** Rounds up to nearest integer */
  ceil: (num: number): number => Math.ceil(Number(num) || 0),

  /** Rounds down to nearest integer */
  floor: (num: number): number => Math.floor(Number(num) || 0),

  /** Rounds to specified precision */
  round: (num: number, precision = 0): number => {
    const factor = Math.pow(10, Number(precision) || 0);
    return Math.round((Number(num) || 0) * factor) / factor;
  },

  /** Adds two numbers */
  plus: (num: number, addend: number): number => (Number(num) || 0) + (Number(addend) || 0),

  /** Subtracts second number from first */
  minus: (num: number, sub: number): number => (Number(num) || 0) - (Number(sub) || 0),
};
</file>

<file path="app/components/preview/utils/liquidTags.ts">
/**
 * Shopify-specific Liquid Tags for Preview
 * Implements tags not available in standard LiquidJS
 *
 * NOTE: LiquidJS uses generators, not async/await!
 * Use `* render(ctx, emitter)` with `yield` instead of `async render()` with `await`
 * @see https://liquidjs.com/tutorials/render-tag-content.html
 */
import type { Liquid, TopLevelToken, Context, Emitter } from 'liquidjs';
import { ForloopDrop } from '../drops';

// Template type for parsed templates
type Template = unknown;

/**
 * Register all Shopify-specific tags on a LiquidJS engine instance
 */
export function registerShopifyTags(engine: Liquid): void {
  registerFormTags(engine);
  registerPaginateTags(engine);
  registerSectionTags(engine);
  registerCommentTags(engine);
  registerStyleTags(engine);
  registerJavascriptTags(engine);
  registerLiquidTag(engine);
  registerIncludeTag(engine);
  registerTablerowTags(engine);
  registerLayoutStubs(engine);
}

// Form tags: {% form 'type' %} ... {% endform %}
function registerFormTags(engine: Liquid): void {
  engine.registerTag('form', {
    parse: function (tagToken: { args: string; getText: () => string }, remainTokens: TopLevelToken[]) {
      this.args = tagToken.args;
      this.tpl = [];
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endform', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      let formType = 'generic';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        formType = match ? match[1] : 'generic';
      }
      const formContext = {
        errors: [],
        posted_successfully: false,
        id: `form-${formType}-preview`,
        toString: () => '',
        valueOf: () => ''
      };
      ctx.push({ form: formContext });
      emitter.write(`<form method="post" class="shopify-form shopify-form-${formType}" data-preview="true">\n`);
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('\n</form>');
      ctx.pop();
    },
  });

  engine.registerTag('endform', {
    parse: function () {},
    render: function () {},
  });
}

// Paginate tags: {% paginate collection.products by 5 %} ... {% endpaginate %}
function registerPaginateTags(engine: Liquid): void {
  engine.registerTag('paginate', {
    parse: function (tagToken: { args: string; getText: () => string }, remainTokens: TopLevelToken[]) {
      this.args = tagToken.args;
      this.tpl = [];
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endpaginate', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      emitter.write('<!-- Paginated section (preview shows first page) -->\n');
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('\n<!-- End pagination -->');
    },
  });

  engine.registerTag('endpaginate', {
    parse: function () {},
    render: function () {},
  });
}

// Section and render tags
function registerSectionTags(engine: Liquid): void {
  engine.registerTag('section', {
    parse: function (tagToken: { args: string }) { this.args = tagToken.args; },
    * render(_ctx: Context, emitter: Emitter) {
      let sectionName = 'unknown';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        sectionName = match ? match[1] : 'unknown';
      }
      emitter.write(`<!-- Section: ${sectionName} (not rendered in preview) -->`);
    },
  });

  engine.registerTag('render', {
    parse: function (tagToken: { args: string }) { this.args = tagToken.args; },
    * render(_ctx: Context, emitter: Emitter) {
      let snippetName = 'unknown';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        snippetName = match ? match[1] : 'unknown';
      }
      emitter.write(`<!-- Render snippet: ${snippetName} (not loaded in preview) -->`);
    },
  });
}

// Comment tags: {% comment %} ... {% endcomment %}
function registerCommentTags(engine: Liquid): void {
  engine.registerTag('comment', {
    parse: function (tagToken: { getText: () => string }, remainTokens: TopLevelToken[]) {
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endcomment', () => stream.stop())
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    render: function () {},
  });

  engine.registerTag('endcomment', {
    parse: function () {},
    render: function () {},
  });
}

// Style tags: {% style %} CSS {% endstyle %} and {% stylesheet %}
function registerStyleTags(engine: Liquid): void {
  // {% style %} - Shopify-specific scoped CSS tag
  engine.registerTag('style', {
    parse: function (tagToken: { getText: () => string }, remainTokens: TopLevelToken[]) {
      this.tpl = [];
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endstyle', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      emitter.write('<style data-shopify-style>');
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('</style>');
    },
  });

  engine.registerTag('endstyle', {
    parse: function () {},
    render: function () {},
  });

  // {% stylesheet %} - Legacy Shopify CSS tag
  engine.registerTag('stylesheet', {
    parse: function (tagToken: { getText: () => string }, remainTokens: TopLevelToken[]) {
      this.tpl = [];
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endstylesheet', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      emitter.write('<style>');
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('</style>');
    },
  });

  engine.registerTag('endstylesheet', {
    parse: function () {},
    render: function () {},
  });
}

// Javascript tags: {% javascript %} ... {% endjavascript %}
function registerJavascriptTags(engine: Liquid): void {
  engine.registerTag('javascript', {
    parse: function (tagToken: { getText: () => string }, remainTokens: TopLevelToken[]) {
      this.tpl = [];
      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endjavascript', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      emitter.write('<script>');
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('</script>');
    },
  });

  engine.registerTag('endjavascript', {
    parse: function () {},
    render: function () {},
  });
}

// {% liquid %} - Multi-statement block tag
function registerLiquidTag(engine: Liquid): void {
  engine.registerTag('liquid', {
    parse: function (tagToken: { args: string }) {
      this.statements = tagToken.args;
    },
    * render(ctx: Context, emitter: Emitter) {
      if (!this.statements) return;

      const lines = this.statements.split('\n').map((l: string) => l.trim()).filter(Boolean);

      for (const line of lines) {
        // Handle echo statements: echo variable -> {{ variable }}
        // Handle other statements: statement -> {% statement %}
        const wrappedLine = line.startsWith('echo ')
          ? `{{ ${line.replace(/^echo\s+/, '')} }}`
          : `{% ${line} %}`;

        try {
          const templates = this.liquid.parse(wrappedLine);
          yield this.liquid.renderer.renderTemplates(templates, ctx, emitter);
        } catch (e) {
          console.warn(`Liquid tag parse error: ${line}`, e);
        }
      }
    },
  });
}

// {% include 'snippet', var: value %} - Shared scope include
function registerIncludeTag(engine: Liquid): void {
  engine.registerTag('include', {
    parse: function (tagToken: { args: string }) {
      this.args = tagToken.args;
    },
    * render(_ctx: Context, emitter: Emitter) {
      let snippetName = 'unknown';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        snippetName = match ? match[1] : 'unknown';
      }
      // In full implementation: load snippet, parse vars, render with SHARED scope
      emitter.write(`<!-- Include snippet: ${snippetName} (not loaded in preview, shared scope) -->`);
    },
  });
}

// {% tablerow item in array cols:3 %} ... {% endtablerow %}
function registerTablerowTags(engine: Liquid): void {
  engine.registerTag('tablerow', {
    parse: function (tagToken: { args: string; getText: () => string }, remainTokens: TopLevelToken[]) {
      this.args = tagToken.args;
      this.tpl = [];

      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endtablerow', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      // Parse: tablerow item in array cols:3 limit:6 offset:0
      const argsMatch = this.args.match(/(\w+)\s+in\s+(\S+)(?:\s+(.*))?/);
      if (!argsMatch) return;

      const [, varName, collectionExpr, optionsStr] = argsMatch;

      // Parse options
      const options: { cols?: number; limit?: number; offset?: number } = {};
      if (optionsStr) {
        const colsMatch = optionsStr.match(/cols:\s*(\d+)/);
        const limitMatch = optionsStr.match(/limit:\s*(\d+)/);
        const offsetMatch = optionsStr.match(/offset:\s*(\d+)/);

        if (colsMatch) options.cols = parseInt(colsMatch[1], 10);
        if (limitMatch) options.limit = parseInt(limitMatch[1], 10);
        if (offsetMatch) options.offset = parseInt(offsetMatch[1], 10);
      }

      // Get collection from context
      const collection = (yield this.liquid.evalValue(collectionExpr, ctx)) as unknown[];
      if (!Array.isArray(collection)) return;

      // Apply offset and limit
      let items = collection;
      if (options.offset) items = items.slice(options.offset);
      if (options.limit) items = items.slice(0, options.limit);

      const cols = options.cols || items.length;
      let row = 0;
      let col = 0;

      for (let i = 0; i < items.length; i++) {
        const item = items[i];

        // Start new row
        if (col === 0) {
          row++;
          emitter.write(`<tr class="row${row}">`);
        }

        col++;

        // Create tablerowloop object (Shopify-specific)
        const tablerowloop = {
          index: i + 1,
          index0: i,
          rindex: items.length - i,
          rindex0: items.length - i - 1,
          first: i === 0,
          last: i === items.length - 1,
          length: items.length,
          col: col,
          col0: col - 1,
          col_first: col === 1,
          col_last: col === cols || i === items.length - 1,
          row: row
        };

        // Push context with item, tablerowloop, and forloop
        ctx.push({
          [varName]: item,
          tablerowloop,
          forloop: new ForloopDrop(i, items.length, varName)
        });

        // Render cell content
        emitter.write(`<td class="col${col}">`);
        yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
        emitter.write('</td>');

        ctx.pop();

        // End row if needed
        if (col >= cols) {
          emitter.write('</tr>');
          col = 0;
        }
      }

      // Close last row if incomplete
      if (col > 0) {
        emitter.write('</tr>');
      }
    },
  });

  engine.registerTag('endtablerow', {
    parse: function () {},
    render: function () {},
  });
}

// Layout stubs: {% layout %}, {% content_for %}, {% sections %}
function registerLayoutStubs(engine: Liquid): void {
  // {% layout 'name' %} or {% layout none %}
  engine.registerTag('layout', {
    parse: function (tagToken: { args: string }) { this.args = tagToken.args; },
    * render(_ctx: Context, emitter: Emitter) {
      let layoutName = 'theme';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        if (match) layoutName = match[1];
        if (this.args.includes('none')) layoutName = 'none';
      }
      emitter.write(`<!-- Layout: ${layoutName} (not applied in section preview) -->`);
    },
  });

  // {% content_for 'header' %} ... {% endcontent_for %}
  engine.registerTag('content_for', {
    parse: function (tagToken: { args: string; getText: () => string }, remainTokens: TopLevelToken[]) {
      this.args = tagToken.args;
      this.tpl = [];

      const stream = this.liquid.parser.parseStream(remainTokens);
      stream
        .on('tag:endcontent_for', () => stream.stop())
        .on('template', (tpl: Template) => {
          if (tpl) this.tpl.push(tpl);
        })
        .on('end', () => {
          throw new Error(`tag ${tagToken.getText()} not closed`);
        });
      stream.start();
    },
    * render(ctx: Context, emitter: Emitter) {
      emitter.write('<!-- content_for block -->');
      yield this.liquid.renderer.renderTemplates(this.tpl, ctx, emitter);
      emitter.write('<!-- end content_for -->');
    },
  });

  engine.registerTag('endcontent_for', {
    parse: function () {},
    render: function () {},
  });

  // {% sections 'group' %}
  engine.registerTag('sections', {
    parse: function (tagToken: { args: string }) { this.args = tagToken.args; },
    * render(_ctx: Context, emitter: Emitter) {
      let groupName = 'main';
      if (this.args) {
        const match = this.args.match(/['"]([^'"]+)['"]/);
        groupName = match ? match[1] : 'main';
      }
      emitter.write(`<!-- Sections group: ${groupName} (not rendered in single section preview) -->`);
    },
  });
}
</file>

<file path="app/components/preview/EmptyPreviewState.tsx">
export interface EmptyPreviewStateProps {
  message?: string;
}

/**
 * Empty state shown when no code is available to preview
 */
export function EmptyPreviewState({
  message = 'Generate a section to see the preview'
}: EmptyPreviewStateProps) {
  return (
    <div style={{
      padding: '32px',
      backgroundColor: '#f6f6f7',
      borderRadius: '8px',
      minHeight: '300px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }}>
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: '12px'
      }}>
        <span style={{ fontSize: '48px', opacity: 0.5 }}></span>
        <p style={{ color: '#6d7175', margin: 0, textAlign: 'center' }}>
          {message}
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/components/preview/index.ts">
// Main preview components
export { SectionPreview } from './SectionPreview';
export { PreviewFrame } from './PreviewFrame';
export { PreviewToolbar } from './PreviewToolbar';
export { PreviewErrorBoundary } from './PreviewErrorBoundary';
export { PreviewSkeleton } from './PreviewSkeleton';
export { EmptyPreviewState } from './EmptyPreviewState';

// Hooks
export { useLiquidRenderer } from './hooks/useLiquidRenderer';
export { usePreviewMessaging } from './hooks/usePreviewMessaging';

// Types
export * from './types';

// Schema utilities
export * from './schema';

// Settings components
export * from './settings';

// Mock data
export * from './mockData';
</file>

<file path="app/components/preview/PreviewErrorBoundary.tsx">
import { Component, type ReactNode } from 'react';

interface Props {
  children: ReactNode;
  onRetry?: () => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

/**
 * Error boundary to catch rendering errors in preview
 * Provides retry functionality and user-friendly error display
 */
export class PreviewErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Preview error:', error, errorInfo);
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null });
    this.props.onRetry?.();
  };

  render() {
    if (this.state.hasError) {
      return (
        <div style={{
          padding: '32px',
          backgroundColor: '#f6f6f7',
          borderRadius: '8px',
          textAlign: 'center'
        }}>
          <h3 style={{ margin: '0 0 12px', fontSize: '16px', fontWeight: 600 }}>
            Preview Failed
          </h3>
          <p style={{ color: '#6d7175', margin: '0 0 16px' }}>
            Something went wrong rendering the preview.
            {this.state.error?.message && (
              <>
                <br />
                <span style={{ fontFamily: 'monospace', fontSize: '12px' }}>
                  {this.state.error.message}
                </span>
              </>
            )}
          </p>
          <s-button variant="primary" onClick={this.handleRetry}>
            Try Again
          </s-button>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="app/components/preview/PreviewSkeleton.tsx">
/**
 * Loading skeleton for preview component
 */
export function PreviewSkeleton() {
  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
      {/* Toolbar skeleton */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '8px 0'
      }}>
        <div style={{ display: 'flex', gap: '8px' }}>
          {[1, 2, 3].map(i => (
            <div
              key={i}
              style={{
                width: '60px',
                height: '28px',
                backgroundColor: '#e1e3e5',
                borderRadius: '4px',
                animation: 'pulse 1.5s ease-in-out infinite'
              }}
            />
          ))}
        </div>
        <div style={{
          width: '80px',
          height: '28px',
          backgroundColor: '#e1e3e5',
          borderRadius: '4px',
          animation: 'pulse 1.5s ease-in-out infinite'
        }} />
      </div>

      {/* Preview frame skeleton */}
      <div style={{
        backgroundColor: '#f6f6f7',
        borderRadius: '8px',
        padding: '16px',
        minHeight: '400px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '12px'
        }}>
          <s-spinner size="large" />
          <p style={{ color: '#6d7175', margin: 0, fontSize: '14px' }}>
            Rendering preview...
          </p>
        </div>
      </div>

      <style>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="app/components/preview/SelectedResourceDisplay.tsx">
/**
 * Selected Resource Display Component
 * Shows thumbnail, title, and clear button for a selected resource
 */

interface SelectedResourceDisplayProps {
  title: string;
  image?: string;
  onClear: () => void;
  disabled?: boolean;
}

/**
 * SelectedResourceDisplay - Compact display of a selected resource
 * Shows thumbnail, title, and clear button
 */
export function SelectedResourceDisplay({
  title,
  image,
  onClear,
  disabled
}: SelectedResourceDisplayProps) {
  return (
    <s-stack gap="small" direction="inline">
      {/* Thumbnail */}
      {image && (
        <img
          src={image}
          alt={title}
          style={{
            width: '32px',
            height: '32px',
            objectFit: 'cover',
            borderRadius: '4px',
            border: '1px solid var(--p-color-border-secondary)'
          }}
        />
      )}

      {/* Title (truncated) */}
      <s-text>
        {title.length > 30 ? `${title.substring(0, 30)}...` : title}
      </s-text>

      {/* Clear button */}
      <s-button
        variant="tertiary"
        onClick={onClear}
        disabled={disabled || undefined}
        accessibilityLabel={`Clear ${title} selection`}
      >
        
      </s-button>
    </s-stack>
  );
}
</file>

<file path="app/components/preview/types.ts">
/**
 * Preview component types
 */

export interface PreviewSettings {
  [key: string]: string | number | boolean;
}

export interface PreviewMessage {
  type: 'RENDER' | 'RENDER_ERROR' | 'RESIZE';
  html?: string;
  css?: string;
  error?: string;
  height?: number;
}

export interface PreviewState {
  isLoading: boolean;
  error: string | null;
  lastRenderTime: number;
}

export type DeviceSize = 'mobile' | 'tablet' | 'desktop';

export const DEVICE_WIDTHS: Record<DeviceSize, number> = {
  mobile: 375,
  tablet: 768,
  desktop: 1200
};
</file>

<file path="app/components/sections/DeleteConfirmModal.tsx">
interface DeleteConfirmModalProps {
  id: string;
  isBulk: boolean;
  count: number;
  isDeleting: boolean;
  onConfirm: () => void;
}

/**
 * Confirmation modal for delete actions using Shopify s-modal component.
 * Uses declarative commandFor pattern - trigger with a button that has commandFor={id}
 */
export function DeleteConfirmModal({
  id,
  isBulk,
  count,
  isDeleting,
  onConfirm,
}: DeleteConfirmModalProps) {
  const title = isBulk
    ? `Delete ${count} section${count > 1 ? "s" : ""}?`
    : "Delete this section?";

  const message = isBulk
    ? `Are you sure you want to delete ${count} selected section${count > 1 ? "s" : ""}? This action cannot be undone.`
    : "Are you sure you want to delete this section? This action cannot be undone.";

  return (
    <s-modal id={id} heading={title} size="small">
      <s-stack gap="base" direction="block">
        <s-paragraph>{message}</s-paragraph>
      </s-stack>
      <s-button
        slot="secondary-actions"
        command="--hide"
        commandFor={id}
        disabled={isDeleting}
      >
        Cancel
      </s-button>
      <s-button
        slot="primary-action"
        variant="primary"
        tone="critical"
        commandFor={id}
        command="--hide"
        onClick={onConfirm}
        loading={isDeleting}
        disabled={isDeleting}
      >
        Delete
      </s-button>
    </s-modal>
  );
}
</file>

<file path="app/components/sections/HistoryPreviewModal.tsx">
import type { Section } from "@prisma/client";
import { useState } from "react";

export interface HistoryPreviewModalProps {
  item: Section;
  onClose: () => void;
}

/**
 * Modal preview for history item code
 */
export function HistoryPreviewModal({
  item,
  onClose
}: HistoryPreviewModalProps) {
  const [copySuccess, setCopySuccess] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(item.code);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (error) {
      console.error('Failed to copy:', error);
    }
  };

  const handleDownload = () => {
    const fileName = item.fileName || 'section';
    const sanitizedName = fileName.replace(/[^a-zA-Z0-9-_]/g, '-');
    const blob = new Blob([item.code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${sanitizedName}.liquid`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  return (
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="history-preview-title"
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      }}
      onClick={onClose}
      onKeyDown={(e) => { if (e.key === 'Escape') onClose(); }}
    >
      {/* eslint-disable-next-line jsx-a11y/no-static-element-interactions */}
      <div
        style={{
          backgroundColor: 'var(--p-color-bg-surface)',
          borderRadius: '12px',
          maxWidth: '800px',
          width: '100%',
          maxHeight: '80vh',
          overflow: 'hidden',
          display: 'flex',
          flexDirection: 'column'
        }}
        onClick={(e) => e.stopPropagation()}
        onKeyDown={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div style={{ padding: '16px 20px', borderBottom: '1px solid var(--p-color-border)' }}>
          <s-stack gap="base" justifyContent="space-between" alignItems="center" direction="inline">
            <s-heading>Code Preview</s-heading>
            <s-button variant="tertiary" onClick={onClose}>Close</s-button>
          </s-stack>
        </div>

        {/* Prompt info */}
        <div style={{ padding: '12px 20px', backgroundColor: 'var(--p-color-bg-surface-secondary)' }}>
          <s-text color="subdued">
            Prompt: {item.prompt.substring(0, 150)}{item.prompt.length > 150 ? '...' : ''}
          </s-text>
        </div>

        {/* Saved info */}
        {item.status === 'saved' && item.themeName && (
          <div style={{ padding: '8px 20px', backgroundColor: 'var(--p-color-bg-surface-secondary)' }}>
            <s-text color="subdued">
              Saved to: {item.themeName} / {item.fileName}.liquid
            </s-text>
          </div>
        )}

        {/* Code block */}
        <div style={{ flex: 1, overflow: 'auto', padding: '20px' }}>
          <pre
            style={{
              margin: 0,
              fontFamily: 'Monaco, Courier, monospace',
              fontSize: '13px',
              lineHeight: '1.6',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word'
            }}
          >
            {item.code}
          </pre>
        </div>

        {/* Actions */}
        <div style={{ padding: '16px 20px', borderTop: '1px solid var(--p-color-border)' }}>
          <s-stack gap="base" direction="inline">
            <s-button onClick={handleDownload} variant="secondary">Download</s-button>
            <s-button variant="primary" onClick={handleCopy}>
              {copySuccess ? 'Copied!' : 'Copy Code'}
            </s-button>
          </s-stack>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/sections/HistoryTable.tsx">
import type { Section } from "@prisma/client";

export interface HistoryTableProps {
  items: Section[];
  onPreview: (item: Section) => void;
  onToggleFavorite: (id: string) => void;
  onDelete: (id: string) => void;
}

function formatDate(date: Date | string): string {
  return new Date(date).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Table component for history items using Polaris s-table
 */
export function HistoryTable({
  items,
  onPreview,
  onToggleFavorite,
  onDelete
}: HistoryTableProps) {
  return (
    <s-table>
      <s-table-header-row>
        <s-table-header listSlot="primary">Prompt</s-table-header>
        <s-table-header>Status</s-table-header>
        <s-table-header>Options</s-table-header>
        <s-table-header>Date</s-table-header>
        <s-table-header>Actions</s-table-header>
      </s-table-header-row>
      <s-table-body>
        {items.map((item) => (
          <s-table-row key={item.id}>
            <s-table-cell>
              <s-stack gap="small" direction="inline" alignItems="center">
                {item.isFavorite && <s-badge tone="warning">Fav</s-badge>}
                <s-text>
                  {item.prompt.length > 80
                    ? `${item.prompt.substring(0, 80)}...`
                    : item.prompt}
                </s-text>
              </s-stack>
            </s-table-cell>
            <s-table-cell>
              {item.status === "saved" ? (
                <s-badge tone="success">Saved</s-badge>
              ) : (
                <s-badge tone="neutral">Generated</s-badge>
              )}
            </s-table-cell>
            <s-table-cell>
              <s-stack gap="small" direction="inline">
                {item.tone && <s-badge>{item.tone}</s-badge>}
                {item.style && <s-badge>{item.style}</s-badge>}
                {!item.tone && !item.style && <s-text color="subdued">-</s-text>}
              </s-stack>
            </s-table-cell>
            <s-table-cell>
              <s-text color="subdued">
                {formatDate(item.createdAt)}
              </s-text>
            </s-table-cell>
            <s-table-cell>
              <s-stack gap="small" direction="inline" alignItems="end">
                <s-button onClick={() => onPreview(item)}>Preview</s-button>
                <s-button onClick={() => onToggleFavorite(item.id)}>
                  {item.isFavorite ? "Unfav" : "Fav"}
                </s-button>
                <s-button tone="critical" onClick={() => onDelete(item.id)}>Delete</s-button>
              </s-stack>
            </s-table-cell>
          </s-table-row>
        ))}
      </s-table-body>
    </s-table>
  );
}
</file>

<file path="app/components/sections/SectionsEmptyState.tsx">
interface SectionsEmptyStateProps {
  hasFilters: boolean;
  onClearFilters: () => void;
  onCreateNew: () => void;
}

/**
 * Empty state component for sections page following Shopify Index pattern
 */
export function SectionsEmptyState({
  hasFilters,
  onClearFilters,
  onCreateNew
}: SectionsEmptyStateProps) {
  if (hasFilters) {
    return (
      <s-section accessibilityLabel="Empty state section">
        <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
          <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
            <s-stack alignItems="center">
              <s-heading>No matching sections</s-heading>
              <s-paragraph>
                No sections match your current filters. Try adjusting or clearing your filters.
              </s-paragraph>
            </s-stack>
            <s-button-group>
              <s-button slot="secondary-actions" onClick={onClearFilters}>
                Clear filters
              </s-button>
              <s-button slot="primary-action" variant="primary" onClick={onCreateNew}>
                Create new section
              </s-button>
            </s-button-group>
          </s-grid>
        </s-grid>
      </s-section>
    );
  }

  return (
    <s-section accessibilityLabel="Empty state section">
      <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
        <s-box maxInlineSize="200px" maxBlockSize="200px">
          <s-image
            aspectRatio="1/0.5"
            src="https://cdn.shopify.com/static/images/polaris/patterns/callout.png"
            alt="A stylized graphic representing AI section creation"
          />
        </s-box>
        <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
          <s-stack alignItems="center">
            <s-heading>Create your first section</s-heading>
            <s-paragraph>
              Create AI-powered Liquid sections for your Shopify theme. Describe what you want
              and let AI generate production-ready code.
            </s-paragraph>
          </s-stack>
          <s-button-group>
            <s-button
              slot="secondary-actions"
              accessibilityLabel="Learn more about AI section creation"
              href="/app"
            >
              Learn more
            </s-button>
            <s-button
              slot="primary-action"
              variant="primary"
              accessibilityLabel="Create your first AI section"
              onClick={onCreateNew}
            >
              Create Section
            </s-button>
          </s-button-group>
        </s-grid>
      </s-grid>
    </s-section>
  );
}
</file>

<file path="app/components/shared/Banner.tsx">
import type { ReactNode } from 'react';

export interface BannerProps {
  tone?: 'info' | 'success' | 'warning' | 'critical';
  heading?: string;
  dismissible?: boolean;
  onDismiss?: () => void;
  children?: ReactNode;
}

/**
 * Wrapper for Polaris s-banner web component
 * Displays feedback messages with appropriate styling
 */
export function Banner({
  tone = 'info',
  heading,
  dismissible = false,
  onDismiss,
  children
}: BannerProps) {
  return (
    <s-banner
      tone={tone}
      heading={heading}
      dismissible={dismissible}
      onDismiss={onDismiss}
    >
      {children}
    </s-banner>
  );
}

/**
 * Pre-configured success banner
 * Used for displaying successful operations
 */
export function SuccessBanner({ message }: { message: string }) {
  return (
    <Banner tone="success" heading="Success" dismissible>
      {message}
    </Banner>
  );
}

/**
 * Pre-configured error banner
 * Used for displaying error messages
 */
export function ErrorBanner({ message }: { message: string }) {
  return (
    <Banner tone="critical" heading="Error">
      {message}
    </Banner>
  );
}
</file>

<file path="app/components/shared/EmptyState.tsx">
interface EmptyStateProps {
  heading: string;
  description: string;
  primaryAction: {
    label: string;
    onClick: () => void;
  };
  secondaryAction?: {
    label: string;
    onClick: () => void;
  };
  image?: string;
}

/**
 * Reusable empty state component following Polaris patterns
 */
export function EmptyState({
  heading,
  description,
  primaryAction,
  secondaryAction,
  image
}: EmptyStateProps) {
  return (
    <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
      {image && (
        <s-box maxInlineSize="200px" maxBlockSize="200px">
          <s-image aspectRatio="1/0.5" src={image} alt="" />
        </s-box>
      )}
      <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
        <s-stack alignItems="center">
          <s-heading>{heading}</s-heading>
          <s-paragraph>{description}</s-paragraph>
        </s-stack>
        <s-button-group>
          {secondaryAction && (
            <s-button onClick={secondaryAction.onClick}>
              {secondaryAction.label}
            </s-button>
          )}
          <s-button variant="primary" onClick={primaryAction.onClick}>
            {primaryAction.label}
          </s-button>
        </s-button-group>
      </s-grid>
    </s-grid>
  );
}
</file>

<file path="app/data/default-templates.ts">
/**
 * Default Section Templates
 *
 * Pre-built templates organized by category for the AI Section Generator.
 * Templates can include:
 * - prompt: AI prompt for generating variations (required)
 * - code: Pre-built Liquid code for instant use (optional)
 */

export interface DefaultTemplate {
  title: string;
  description: string;
  category: string;
  icon: string;
  prompt: string;
  code?: string; // Pre-built Liquid code for "Use As-Is" functionality
}


export const TEMPLATE_CATEGORIES = [
  { value: "", label: "All Categories" },
  { value: "hero", label: "Hero" },
  { value: "features", label: "Features" },
  { value: "testimonials", label: "Testimonials" },
  { value: "pricing", label: "Pricing" },
  { value: "cta", label: "Call to Action" },
  { value: "faq", label: "FAQ" },
  { value: "team", label: "Team" },
  { value: "gallery", label: "Gallery" },
  { value: "content", label: "Content" },
  { value: "footer", label: "Footer" },
] as const;

export const DEFAULT_TEMPLATES: DefaultTemplate[] = [
  // ============================================
  // HERO SECTIONS (12 templates)
  // ============================================
  {
    title: "Hero with Background Image",
    description: "Full-width hero with background image, headline, and CTA button",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with a full-width background image, centered headline text with a subheading, and a prominent call-to-action button. Include overlay for text readability.",
    code: `{% comment %}
  Hero with Background Image
  A full-width hero section with background image, overlay, headline, and CTA
{% endcomment %}

{% schema %}
{
  "name": "Hero with Background",
  "settings": [
    {
      "type": "image_picker",
      "id": "background_image",
      "label": "Background Image"
    },
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Welcome to Our Store"
    },
    {
      "type": "textarea",
      "id": "subheading",
      "label": "Subheading",
      "default": "Discover amazing products crafted with care"
    },
    {
      "type": "text",
      "id": "button_text",
      "label": "Button Text",
      "default": "Shop Now"
    },
    {
      "type": "url",
      "id": "button_link",
      "label": "Button Link"
    },
    {
      "type": "range",
      "id": "overlay_opacity",
      "label": "Overlay Opacity",
      "min": 0,
      "max": 100,
      "step": 10,
      "default": 40
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text Color",
      "default": "#ffffff"
    }
  ],
  "presets": [
    {
      "name": "Hero with Background"
    }
  ]
}
{% endschema %}

<style>
  .hero-bg-section {
    position: relative;
    min-height: 80vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background-size: cover;
    background-position: center;
  }

  .hero-bg-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, calc({{ section.settings.overlay_opacity }} / 100));
  }

  .hero-bg-content {
    position: relative;
    z-index: 1;
    text-align: center;
    padding: 2rem;
    max-width: 800px;
    color: {{ section.settings.text_color }};
  }

  .hero-bg-heading {
    font-size: clamp(2rem, 5vw, 4rem);
    font-weight: 700;
    margin-bottom: 1rem;
    line-height: 1.2;
  }

  .hero-bg-subheading {
    font-size: clamp(1rem, 2vw, 1.5rem);
    margin-bottom: 2rem;
    opacity: 0.9;
  }

  .hero-bg-button {
    display: inline-block;
    padding: 1rem 2.5rem;
    background: {{ section.settings.text_color }};
    color: #000;
    text-decoration: none;
    font-weight: 600;
    border-radius: 4px;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .hero-bg-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
</style>

<section
  class="hero-bg-section"
  style="background-image: url('{{ section.settings.background_image | image_url: width: 1920 }}');"
>
  <div class="hero-bg-overlay"></div>
  <div class="hero-bg-content">
    <h1 class="hero-bg-heading">{{ section.settings.heading }}</h1>
    <p class="hero-bg-subheading">{{ section.settings.subheading }}</p>
    {% if section.settings.button_text != blank %}
      <a href="{{ section.settings.button_link }}" class="hero-bg-button">
        {{ section.settings.button_text }}
      </a>
    {% endif %}
  </div>
</section>`,
  },
  {
    title: "Hero with Video Background",
    description: "Eye-catching hero with looping video background",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with a looping video background. Include a dark overlay, large headline, brief description, and a CTA button. Video should be muted and autoplay.",
  },

  {
    title: "Split Hero",
    description: "Two-column hero with text on one side and image on the other",
    category: "hero",
    icon: "",
    prompt: "Create a split hero section with two equal columns. Left side has headline, description text, and CTA button. Right side displays a large product or feature image.",
    code: `{% comment %}
  Split Hero
  Two-column hero with text on left and image on right
{% endcomment %}

{% schema %}
{
  "name": "Split Hero",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Elevate Your Style"
    },
    {
      "type": "textarea",
      "id": "description",
      "label": "Description",
      "default": "Discover our collection of premium products designed for the modern lifestyle."
    },
    {
      "type": "text",
      "id": "button_text",
      "label": "Button Text",
      "default": "Explore Collection"
    },
    {
      "type": "url",
      "id": "button_link",
      "label": "Button Link"
    },
    {
      "type": "image_picker",
      "id": "image",
      "label": "Hero Image"
    },
    {
      "type": "color",
      "id": "bg_color",
      "label": "Background Color",
      "default": "#f8f9fa"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text Color",
      "default": "#1a1a1a"
    },
    {
      "type": "color",
      "id": "button_color",
      "label": "Button Color",
      "default": "#1a1a1a"
    }
  ],
  "presets": [
    {
      "name": "Split Hero"
    }
  ]
}
{% endschema %}

<style>
  .split-hero {
    display: grid;
    grid-template-columns: 1fr 1fr;
    min-height: 80vh;
    background: {{ section.settings.bg_color }};
  }

  @media (max-width: 768px) {
    .split-hero {
      grid-template-columns: 1fr;
    }
  }

  .split-hero__content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 4rem;
    color: {{ section.settings.text_color }};
  }

  .split-hero__heading {
    font-size: clamp(2rem, 4vw, 3.5rem);
    font-weight: 700;
    margin-bottom: 1.5rem;
    line-height: 1.1;
  }

  .split-hero__description {
    font-size: 1.125rem;
    line-height: 1.7;
    margin-bottom: 2rem;
    opacity: 0.8;
  }

  .split-hero__button {
    display: inline-block;
    padding: 1rem 2rem;
    background: {{ section.settings.button_color }};
    color: #fff;
    text-decoration: none;
    font-weight: 600;
    border-radius: 4px;
    transition: opacity 0.2s;
    width: fit-content;
  }

  .split-hero__button:hover {
    opacity: 0.9;
  }

  .split-hero__image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
</style>

<section class="split-hero">
  <div class="split-hero__content">
    <h1 class="split-hero__heading">{{ section.settings.heading }}</h1>
    <p class="split-hero__description">{{ section.settings.description }}</p>
    {% if section.settings.button_text != blank %}
      <a href="{{ section.settings.button_link }}" class="split-hero__button">
        {{ section.settings.button_text }}
      </a>
    {% endif %}
  </div>
  <div class="split-hero__media">
    {% if section.settings.image %}
      <img
        src="{{ section.settings.image | image_url: width: 1200 }}"
        alt="{{ section.settings.heading }}"
        class="split-hero__image"
        loading="lazy"
      >
    {% else %}
      {{ 'lifestyle-1' | placeholder_svg_tag: 'split-hero__image' }}
    {% endif %}
  </div>
</section>`,
  },
  {
    title: "Minimal Hero",
    description: "Clean, text-focused hero with subtle styling",
    category: "hero",
    icon: "",
    prompt: "Create a minimal hero section with clean typography. Large headline centered, brief tagline below, and a simple text link or button. White background with ample whitespace.",
  },
  {
    title: "Hero with Product Showcase",
    description: "Hero featuring a product image with details and buy button",
    category: "hero",
    icon: "",
    prompt: "Create a hero section showcasing a featured product. Include product image, product title, short description, price, and Add to Cart button. Modern e-commerce style.",
  },
  {
    title: "Animated Hero",
    description: "Hero with subtle CSS animations and transitions",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with subtle CSS animations. Fade-in text, floating elements, and smooth hover effects on buttons. Modern and engaging without being distracting.",
  },
  {
    title: "Hero with Countdown",
    description: "Urgency-driven hero with countdown timer",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with a countdown timer for sales or launches. Include headline, countdown display (days, hours, minutes, seconds), and CTA button.",
  },
  {
    title: "Hero with Search",
    description: "Hero section with prominent search functionality",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with a large search bar as the main focus. Include a compelling headline above and category links or popular searches below.",
  },
  {
    title: "Gradient Hero",
    description: "Modern hero with vibrant gradient background",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with a vibrant gradient background. Use modern color combinations, white text, and a contrasting CTA button. Clean and contemporary feel.",
  },
  {
    title: "Hero with Form",
    description: "Hero section with embedded signup or contact form",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with an inline email signup form. Include headline, brief value proposition, email input field, and submit button. Clean two-column layout.",
  },
  {
    title: "Parallax Hero",
    description: "Hero with parallax scrolling effect",
    category: "hero",
    icon: "",
    prompt: "Create a hero section with parallax scrolling effect on the background image. Centered headline and CTA that stay fixed while background moves at different speed.",
  },
  {
    title: "Hero Carousel",
    description: "Rotating hero with multiple slides",
    category: "hero",
    icon: "",
    prompt: "Create a hero carousel with multiple slides. Each slide has background image, headline, description, and CTA. Include navigation arrows and dot indicators.",
  },

  // ============================================
  // FEATURES SECTIONS (12 templates)
  // ============================================
  {
    title: "Feature Grid",
    description: "3-column grid showcasing key features with icons",
    category: "features",
    icon: "",
    prompt: "Create a features section with a 3-column grid. Each feature has an icon, title, and description. Include a section headline. Clean, professional layout.",
    code: `{% comment %}
  Feature Grid
  3-column grid showcasing key features with icons
{% endcomment %}

{% schema %}
{
  "name": "Feature Grid",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Section Heading",
      "default": "Why Choose Us"
    },
    {
      "type": "textarea",
      "id": "subheading",
      "label": "Section Subheading",
      "default": "Everything you need to succeed"
    },
    {
      "type": "color",
      "id": "bg_color",
      "label": "Background Color",
      "default": "#ffffff"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text Color",
      "default": "#1a1a1a"
    }
  ],
  "blocks": [
    {
      "type": "feature",
      "name": "Feature",
      "settings": [
        {
          "type": "text",
          "id": "icon",
          "label": "Icon (emoji)",
          "default": ""
        },
        {
          "type": "text",
          "id": "title",
          "label": "Title",
          "default": "Feature Title"
        },
        {
          "type": "textarea",
          "id": "description",
          "label": "Description",
          "default": "Brief description of this amazing feature."
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Feature Grid",
      "blocks": [
        {
          "type": "feature",
          "settings": {
            "icon": "",
            "title": "Fast Performance",
            "description": "Lightning-fast loading speeds for the best user experience."
          }
        },
        {
          "type": "feature",
          "settings": {
            "icon": "",
            "title": "Secure & Reliable",
            "description": "Enterprise-grade security to keep your data safe."
          }
        },
        {
          "type": "feature",
          "settings": {
            "icon": "",
            "title": "Premium Quality",
            "description": "Crafted with attention to every detail."
          }
        }
      ]
    }
  ]
}
{% endschema %}

<style>
  .feature-grid {
    padding: 5rem 2rem;
    background: {{ section.settings.bg_color }};
    color: {{ section.settings.text_color }};
  }

  .feature-grid__container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .feature-grid__header {
    text-align: center;
    margin-bottom: 4rem;
  }

  .feature-grid__heading {
    font-size: clamp(1.75rem, 3vw, 2.5rem);
    font-weight: 700;
    margin-bottom: 1rem;
  }

  .feature-grid__subheading {
    font-size: 1.125rem;
    opacity: 0.7;
    max-width: 600px;
    margin: 0 auto;
  }

  .feature-grid__items {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 2.5rem;
  }

  .feature-grid__item {
    text-align: center;
    padding: 2rem;
  }

  .feature-grid__icon {
    font-size: 3rem;
    margin-bottom: 1.5rem;
  }

  .feature-grid__title {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 0.75rem;
  }

  .feature-grid__description {
    font-size: 1rem;
    line-height: 1.6;
    opacity: 0.8;
  }
</style>

<section class="feature-grid">
  <div class="feature-grid__container">
    <div class="feature-grid__header">
      <h2 class="feature-grid__heading">{{ section.settings.heading }}</h2>
      {% if section.settings.subheading != blank %}
        <p class="feature-grid__subheading">{{ section.settings.subheading }}</p>
      {% endif %}
    </div>

    <div class="feature-grid__items">
      {% for block in section.blocks %}
        <div class="feature-grid__item" {{ block.shopify_attributes }}>
          <div class="feature-grid__icon">{{ block.settings.icon }}</div>
          <h3 class="feature-grid__title">{{ block.settings.title }}</h3>
          <p class="feature-grid__description">{{ block.settings.description }}</p>
        </div>
      {% endfor %}
    </div>
  </div>
</section>`,
  },
  {
    title: "Feature Cards",
    description: "Features displayed in elegant card format",
    category: "features",
    icon: "",
    prompt: "Create a features section with card-style layout. Each card has subtle shadow, icon, title, and description. Cards should have hover effects. 3 or 4 column layout.",
  },
  {
    title: "Icon Features List",
    description: "Vertical list of features with icons",
    category: "features",
    icon: "",
    prompt: "Create a features section as a vertical list. Each feature has an icon on the left, title, and description on the right. Alternating or stacked layout.",
  },
  {
    title: "Features with Image",
    description: "Features list alongside a large image",
    category: "features",
    icon: "",
    prompt: "Create a features section with a two-column layout. One column has a large image, the other has a stacked list of features with icons and descriptions.",
  },
  {
    title: "Comparison Table",
    description: "Feature comparison across different options",
    category: "features",
    icon: "",
    prompt: "Create a feature comparison table section. Compare 3 products or plans across multiple features. Use checkmarks and X marks. Highlight recommended option.",
  },
  {
    title: "Numbered Features",
    description: "Features with step numbers or sequence",
    category: "features",
    icon: "",
    prompt: "Create a features section with numbered items. Each feature has a large number, title, and description. Use as a process or how-it-works section.",
  },
  {
    title: "Features Tabs",
    description: "Tabbed interface showing different feature sets",
    category: "features",
    icon: "",
    prompt: "Create a features section with tab navigation. Each tab reveals different feature content with image and details. Interactive and space-efficient.",
  },
  {
    title: "Animated Features",
    description: "Features that animate in on scroll",
    category: "features",
    icon: "",
    prompt: "Create a features section where items animate in as user scrolls. Staggered fade-in effect for each feature card. Modern and engaging.",
  },
  {
    title: "Features with Stats",
    description: "Features combined with impressive statistics",
    category: "features",
    icon: "",
    prompt: "Create a features section that combines feature descriptions with key statistics. Large numbers for stats with feature explanations. Trust-building layout.",
  },
  {
    title: "Bento Grid Features",
    description: "Modern bento box style feature layout",
    category: "features",
    icon: "",
    prompt: "Create a features section using bento grid layout. Mix of different sized cards creating visual interest. Some cards larger than others with images and text.",
  },
  {
    title: "Features Timeline",
    description: "Features presented as timeline or roadmap",
    category: "features",
    icon: "",
    prompt: "Create a features section as a vertical timeline. Each feature is a milestone with icon, title, and description. Connected by a vertical line.",
  },
  {
    title: "Hover Features",
    description: "Interactive features with hover reveal",
    category: "features",
    icon: "",
    prompt: "Create a features grid where additional content reveals on hover. Base state shows icon and title, hover reveals full description. Engaging interaction.",
  },

  // ============================================
  // TESTIMONIALS SECTIONS (12 templates)
  // ============================================
  {
    title: "Testimonial Cards",
    description: "Customer testimonials in card format",
    category: "testimonials",
    icon: "",
    prompt: "Create a testimonials section with card layout. Each card has customer quote, photo, name, and title/company. 3-column grid with subtle shadows.",
  },
  {
    title: "Testimonial Slider",
    description: "Rotating carousel of testimonials",
    category: "testimonials",
    icon: "",
    prompt: "Create a testimonial carousel that auto-rotates. Large quote text, customer photo, name and title. Navigation dots and arrows. Elegant center-stage design.",
  },
  {
    title: "Video Testimonials",
    description: "Testimonials with video thumbnails",
    category: "testimonials",
    icon: "",
    prompt: "Create a video testimonials section. Grid of video thumbnails with play buttons, customer names below. Click to play functionality.",
  },
  {
    title: "Quote Block",
    description: "Large single testimonial quote",
    category: "testimonials",
    icon: "",
    prompt: "Create a large single-quote testimonial section. Oversized quotation marks, prominent quote text, customer photo and details. Impactful and focused.",
  },
  {
    title: "Reviews Grid",
    description: "Product reviews with star ratings",
    category: "testimonials",
    icon: "",
    prompt: "Create a reviews section with star ratings. Each review has stars, review text, reviewer name, and date. Show average rating at top. E-commerce style.",
  },
  {
    title: "Logo Cloud with Quotes",
    description: "Company logos with testimonial quotes",
    category: "testimonials",
    icon: "",
    prompt: "Create a section showing client logos with associated testimonial quotes. Logos at top, clicking or hovering reveals their quote. B2B focused.",
  },
  {
    title: "Testimonial Masonry",
    description: "Masonry-style testimonial layout",
    category: "testimonials",
    icon: "",
    prompt: "Create a testimonial section with masonry layout. Different height cards based on quote length. Pinterest-style arrangement. Visual variety.",
  },
  {
    title: "Before & After Testimonials",
    description: "Transformation stories with results",
    category: "testimonials",
    icon: "",
    prompt: "Create testimonials focused on transformations. Before/after stats or images, customer story, and results achieved. Great for fitness, coaching, services.",
  },
  {
    title: "Social Proof Bar",
    description: "Compact testimonial ticker or bar",
    category: "testimonials",
    icon: "",
    prompt: "Create a compact social proof bar with scrolling testimonials. Continuous horizontal scroll showing short quotes and names. Subtle but effective.",
  },
  {
    title: "Testimonial with Metrics",
    description: "Testimonials paired with success metrics",
    category: "testimonials",
    icon: "",
    prompt: "Create testimonials that highlight specific results. Quote plus key metric achieved (e.g., '200% increase'). Data-driven social proof.",
  },
  {
    title: "Featured Testimonial",
    description: "Full-width featured customer story",
    category: "testimonials",
    icon: "",
    prompt: "Create a full-width featured testimonial section. Large customer photo on one side, detailed quote and story on the other. Premium feel.",
  },
  {
    title: "Testimonial Wall",
    description: "Dense wall of many testimonials",
    category: "testimonials",
    icon: "",
    prompt: "Create a testimonial wall showing many short quotes in a dense grid. Small cards with quote snippets. Hover to expand. Shows volume of happy customers.",
  },

  // ============================================
  // PRICING SECTIONS (10 templates)
  // ============================================
  {
    title: "Pricing Cards",
    description: "Classic 3-tier pricing comparison",
    category: "pricing",
    icon: "",
    prompt: "Create a 3-tier pricing section with cards. Each card has plan name, price, feature list, and CTA button. Highlight the middle/recommended plan.",
  },
  {
    title: "Pricing Table",
    description: "Detailed feature comparison table",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing comparison table. Plans as columns, features as rows. Checkmarks for included features. Clear and detailed comparison.",
  },
  {
    title: "Toggle Pricing",
    description: "Monthly/yearly toggle pricing display",
    category: "pricing",
    icon: "",
    prompt: "Create pricing cards with monthly/yearly toggle. Toggle switch at top changes all prices. Show savings percentage for yearly. Interactive.",
  },
  {
    title: "Single Plan Pricing",
    description: "Focus on one main pricing option",
    category: "pricing",
    icon: "1",
    prompt: "Create a single-plan pricing section. One prominent card with price, all features listed, strong CTA. Great for simple pricing structures.",
  },
  {
    title: "Pricing with Calculator",
    description: "Interactive pricing calculator",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section with usage calculator. Sliders or inputs for usage metrics, dynamic price display. Great for usage-based pricing.",
  },
  {
    title: "Freemium Pricing",
    description: "Free vs paid plan comparison",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section comparing Free and Paid plans. Emphasize value of paid with feature comparison. Clear upgrade path.",
  },
  {
    title: "Enterprise Pricing",
    description: "Custom enterprise plan with contact form",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section with standard plans plus Enterprise custom option. Enterprise shows 'Contact Us' instead of price. B2B focused.",
  },
  {
    title: "Per-Seat Pricing",
    description: "Team-based pricing with seat counter",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section with per-seat model. Number input for team size, price updates dynamically. Common for SaaS tools.",
  },
  {
    title: "Pricing FAQ",
    description: "Pricing cards with FAQ section",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section with cards at top and frequently asked questions about pricing below. Addresses common concerns.",
  },
  {
    title: "Limited Time Pricing",
    description: "Promotional pricing with discount",
    category: "pricing",
    icon: "",
    prompt: "Create a pricing section showing limited-time discount. Strikethrough original prices, show savings. Optional countdown timer. Urgency-driven.",
  },

  // ============================================
  // CTA SECTIONS (12 templates)
  // ============================================
  {
    title: "Newsletter Signup",
    description: "Email subscription with compelling copy",
    category: "cta",
    icon: "",
    prompt: "Create a newsletter signup section. Compelling headline about value, email input, subscribe button. Clean and focused design.",
  },
  {
    title: "Contact CTA",
    description: "Encourage users to get in touch",
    category: "cta",
    icon: "",
    prompt: "Create a contact CTA section. Headline, brief text about getting in touch, and prominent contact button or phone number. Professional.",
  },
  {
    title: "Download CTA",
    description: "Promote app or resource download",
    category: "cta",
    icon: "",
    prompt: "Create a download CTA section. Promote app download with app store badges, or resource download with preview image and download button.",
  },
  {
    title: "Announcement Bar",
    description: "Top-of-page announcement banner",
    category: "cta",
    icon: "",
    prompt: "Create a slim announcement bar for top of page. Short text about sale, new product, or announcement with link. Dismissible. Eye-catching color.",
  },
  {
    title: "Full-Width CTA",
    description: "Bold full-width call to action",
    category: "cta",
    icon: "",
    prompt: "Create a full-width CTA section with bold background color. Large headline, subtext, and prominent button. High-impact and attention-grabbing.",
  },
  {
    title: "Split CTA",
    description: "Two-column CTA with image",
    category: "cta",
    icon: "",
    prompt: "Create a split CTA section. One side has compelling image, other has headline, text, and action button. Balanced layout.",
  },
  {
    title: "Floating CTA",
    description: "Sticky floating action button",
    category: "cta",
    icon: "",
    prompt: "Create a floating CTA button that stays visible while scrolling. Bottom-right position, icon, text on hover. Non-intrusive but always accessible.",
  },
  {
    title: "Exit Intent CTA",
    description: "Popup-style CTA for engagement",
    category: "cta",
    icon: "",
    prompt: "Create a CTA overlay/popup section. Compelling offer, email capture, and close button. Could be triggered on exit intent or scroll depth.",
  },
  {
    title: "Multi-Step CTA",
    description: "Progressive CTA with steps",
    category: "cta",
    icon: "",
    prompt: "Create a multi-step CTA form. Step 1: email, Step 2: preferences, Step 3: confirm. Progress indicator. Increased commitment technique.",
  },
  {
    title: "Social CTA",
    description: "Encourage social media follows",
    category: "cta",
    icon: "",
    prompt: "Create a social media CTA section. Encourage follows with social platform icons, follower counts, and compelling reason to follow.",
  },
  {
    title: "Quiz CTA",
    description: "Interactive quiz or assessment CTA",
    category: "cta",
    icon: "",
    prompt: "Create a CTA for a quiz or assessment. Engaging headline like 'Find Your Perfect...' with start button. Curiosity-driven engagement.",
  },
  {
    title: "Trial CTA",
    description: "Free trial signup CTA",
    category: "cta",
    icon: "",
    prompt: "Create a free trial CTA section. Highlight trial benefits, no credit card messaging, and clear start trial button. SaaS focused.",
  },

  // ============================================
  // FAQ SECTIONS (10 templates)
  // ============================================
  {
    title: "Accordion FAQ",
    description: "Expandable accordion-style questions",
    category: "faq",
    icon: "",
    prompt: "Create an FAQ section with accordion items. Click question to expand/collapse answer. Plus/minus icons. Clean and space-efficient.",
  },
  {
    title: "Two-Column FAQ",
    description: "Questions arranged in two columns",
    category: "faq",
    icon: "",
    prompt: "Create a two-column FAQ layout. Questions and answers visible without clicking. Good for fewer questions. Clean grid layout.",
  },
  {
    title: "Searchable FAQ",
    description: "FAQ with search functionality",
    category: "faq",
    icon: "",
    prompt: "Create an FAQ section with search bar at top. Filter questions as user types. Helpful for large FAQ sets.",
  },
  {
    title: "Categorized FAQ",
    description: "FAQ organized by category tabs",
    category: "faq",
    icon: "",
    prompt: "Create an FAQ section with category tabs. Different question sets per category (Shipping, Returns, Products, etc.). Organized and easy to navigate.",
  },
  {
    title: "FAQ with Contact",
    description: "FAQ section with contact fallback",
    category: "faq",
    icon: "",
    prompt: "Create FAQ section with contact option at bottom. 'Still have questions? Contact us' with email or chat button. Complete solution.",
  },
  {
    title: "Visual FAQ",
    description: "FAQ with icons or illustrations",
    category: "faq",
    icon: "",
    prompt: "Create an FAQ section where each question has an associated icon. Visual interest while remaining informative. Icon grid layout.",
  },
  {
    title: "Timeline FAQ",
    description: "FAQ presented as process timeline",
    category: "faq",
    icon: "",
    prompt: "Create FAQ as a timeline/journey. Questions follow a process order (ordering, shipping, delivery, returns). Visual flow.",
  },
  {
    title: "Single Topic FAQ",
    description: "Focused FAQ on one topic",
    category: "faq",
    icon: "",
    prompt: "Create a focused FAQ section on one topic (e.g., Shipping FAQ only). Deep coverage of single area. Sidebar navigation optional.",
  },
  {
    title: "FAQ Cards",
    description: "Questions in card format",
    category: "faq",
    icon: "",
    prompt: "Create FAQ as clickable cards. Each card shows question, click reveals answer modal or expands card. Modern interaction.",
  },
  {
    title: "Chatbot FAQ",
    description: "FAQ styled like chat interface",
    category: "faq",
    icon: "",
    prompt: "Create FAQ styled as a chat conversation. Questions as user messages, answers as bot responses. Friendly and approachable.",
  },

  // ============================================
  // TEAM SECTIONS (10 templates)
  // ============================================
  {
    title: "Team Grid",
    description: "Team members in photo grid",
    category: "team",
    icon: "",
    prompt: "Create a team section with photo grid. Each member has photo, name, title. 3 or 4 column layout. Clean and professional.",
  },
  {
    title: "Team Cards",
    description: "Team members with detailed cards",
    category: "team",
    icon: "",
    prompt: "Create team cards with photo, name, role, short bio, and social links. Hover effects on cards. Detailed but clean.",
  },
  {
    title: "Team Carousel",
    description: "Rotating team member display",
    category: "team",
    icon: "",
    prompt: "Create a team carousel for large teams. Scroll through members horizontally. Each has photo, name, role. Navigation arrows.",
  },
  {
    title: "Executive Team",
    description: "Leadership team spotlight",
    category: "team",
    icon: "",
    prompt: "Create an executive team section. Larger photos, names, titles, and brief bios. Premium look for leadership page.",
  },
  {
    title: "Team with Skills",
    description: "Team members with skill displays",
    category: "team",
    icon: "",
    prompt: "Create team section showing member skills. Photo, name, role, and skill bars or tags. Good for agencies and studios.",
  },
  {
    title: "Minimal Team",
    description: "Simple team member list",
    category: "team",
    icon: "",
    prompt: "Create a minimal team section. Small photos or avatars, names and roles only. Text-focused, clean design.",
  },
  {
    title: "Team with Quote",
    description: "Team members with personal quotes",
    category: "team",
    icon: "",
    prompt: "Create team section where each member has a personal quote or motto. Photo, name, role, and quote. Personal touch.",
  },
  {
    title: "Department Teams",
    description: "Team organized by department",
    category: "team",
    icon: "",
    prompt: "Create team section organized by department. Section headers for each team, members below. Good for larger organizations.",
  },
  {
    title: "Team Hover Cards",
    description: "Interactive team cards with hover reveal",
    category: "team",
    icon: "",
    prompt: "Create team cards where additional info reveals on hover. Base shows photo and name, hover shows bio and links. Interactive.",
  },
  {
    title: "Founder Story",
    description: "Focus on founder or CEO",
    category: "team",
    icon: "",
    prompt: "Create a founder spotlight section. Large photo, detailed bio, company story, and personal message. About page hero.",
  },

  // ============================================
  // GALLERY SECTIONS (12 templates)
  // ============================================
  {
    title: "Product Gallery",
    description: "Grid showcase of products",
    category: "gallery",
    icon: "",
    prompt: "Create a product gallery grid. Product images with name and price on hover. 4-column layout. Link to product pages.",
  },
  {
    title: "Masonry Gallery",
    description: "Pinterest-style image layout",
    category: "gallery",
    icon: "",
    prompt: "Create a masonry-style image gallery. Mixed image sizes creating dynamic layout. Lightbox on click. Modern and artistic.",
  },
  {
    title: "Lightbox Gallery",
    description: "Gallery with fullscreen lightbox",
    category: "gallery",
    icon: "",
    prompt: "Create an image gallery with lightbox functionality. Grid of thumbnails, click for fullscreen view with navigation arrows.",
  },
  {
    title: "Before & After Gallery",
    description: "Comparison slider images",
    category: "gallery",
    icon: "",
    prompt: "Create a before/after comparison gallery. Slider to reveal before vs after images. Great for transformations, results.",
  },
  {
    title: "Instagram Feed",
    description: "Instagram-style photo grid",
    category: "gallery",
    icon: "",
    prompt: "Create an Instagram-style gallery section. Square images in grid, link to Instagram. Include follow CTA. Social proof.",
  },
  {
    title: "Video Gallery",
    description: "Grid of video thumbnails",
    category: "gallery",
    icon: "",
    prompt: "Create a video gallery with thumbnail grid. Play button overlays, click to play in modal or inline. Clean video showcase.",
  },
  {
    title: "Portfolio Gallery",
    description: "Work samples with categories",
    category: "gallery",
    icon: "",
    prompt: "Create a portfolio gallery with category filters. Filter buttons to show different work types. Thumbnail grid with hover details.",
  },
  {
    title: "Lookbook Gallery",
    description: "Fashion lookbook style layout",
    category: "gallery",
    icon: "",
    prompt: "Create a lookbook-style gallery. Full-width images alternating with grids. Fashion and lifestyle focused. Editorial feel.",
  },
  {
    title: "Gallery Grid",
    description: "Simple uniform image grid",
    category: "gallery",
    icon: "",
    prompt: "Create a simple uniform image gallery grid. Same-sized images in clean rows. Hover effect for interaction. Classic layout.",
  },
  {
    title: "Gallery Carousel",
    description: "Sliding image carousel",
    category: "gallery",
    icon: "",
    prompt: "Create an image carousel/slider. Large images with navigation arrows and dots. Auto-advance optional. Featured images.",
  },
  {
    title: "Filtered Gallery",
    description: "Gallery with filter options",
    category: "gallery",
    icon: "",
    prompt: "Create a filterable gallery. Filter buttons by category, animated filtering. Grid of images. Good for diverse content.",
  },
  {
    title: "Gallery with Captions",
    description: "Images with detailed captions",
    category: "gallery",
    icon: "",
    prompt: "Create a gallery where each image has a caption below or on hover. Title and description for each item. Informative.",
  },

  // ============================================
  // CONTENT SECTIONS (12 templates)
  // ============================================
  {
    title: "Blog Grid",
    description: "Grid of blog post cards",
    category: "content",
    icon: "",
    prompt: "Create a blog posts grid. Each card has featured image, title, excerpt, date, and read more link. 3-column layout.",
  },
  {
    title: "Article Cards",
    description: "Featured article showcase",
    category: "content",
    icon: "",
    prompt: "Create article cards with large feature image on top, title, excerpt, author info, and read time. Clean blog layout.",
  },
  {
    title: "Rich Text Section",
    description: "Formatted content area",
    category: "content",
    icon: "",
    prompt: "Create a rich text content section. Heading, formatted paragraphs, block quotes, and inline images. About page or story content.",
  },
  {
    title: "Stats Section",
    description: "Key numbers and statistics",
    category: "content",
    icon: "",
    prompt: "Create a statistics section with large numbers. 4 key metrics with labels. Animated counting effect optional. Trust-building.",
  },
  {
    title: "Timeline Section",
    description: "Chronological history display",
    category: "content",
    icon: "",
    prompt: "Create a timeline section for company history or milestones. Vertical line with dated events alternating sides. Storytelling.",
  },
  {
    title: "Logo Cloud",
    description: "Partner or client logos display",
    category: "content",
    icon: "",
    prompt: "Create a logo cloud section. Row of client/partner logos. Grayscale with color on hover optional. 'Trusted by' headline.",
  },
  {
    title: "Marquee Logos",
    description: "Scrolling logos banner",
    category: "content",
    icon: "",
    prompt: "Create a scrolling logo marquee. Continuous horizontal scroll of partner logos. Smooth infinite animation. Social proof.",
  },
  {
    title: "Quote Block",
    description: "Large inspirational quote",
    category: "content",
    icon: "",
    prompt: "Create a large quote section. Oversized quote text with attribution. Decorative quotation marks. Statement piece.",
  },
  {
    title: "Latest News",
    description: "Recent news or updates",
    category: "content",
    icon: "",
    prompt: "Create a latest news section. List of recent updates with dates, titles, and excerpts. Compact or detailed layout options.",
  },
  {
    title: "Mission Statement",
    description: "Company mission and values",
    category: "content",
    icon: "",
    prompt: "Create a mission statement section. Headline, mission paragraph, and optional value icons below. Inspiring and purposeful.",
  },
  {
    title: "Collapsible Content",
    description: "Expandable content sections",
    category: "content",
    icon: "",
    prompt: "Create collapsible content sections. Headers that expand to reveal content. Good for organizing lengthy information.",
  },
  {
    title: "Media Embed",
    description: "Video or podcast embed section",
    category: "content",
    icon: "",
    prompt: "Create a media embed section. Featured video or podcast player with title and description. Full-width or contained.",
  },

  // ============================================
  // FOOTER SECTIONS (10 templates)
  // ============================================
  {
    title: "Multi-Column Footer",
    description: "Classic footer with link columns",
    category: "footer",
    icon: "",
    prompt: "Create a multi-column footer. Logo, 3-4 link columns (Shop, About, Support, etc.), and copyright. Dark or light theme.",
  },
  {
    title: "Simple Footer",
    description: "Minimal one-line footer",
    category: "footer",
    icon: "",
    prompt: "Create a minimal footer with logo, essential links inline, and copyright. Single row, clean and simple.",
  },
  {
    title: "Footer with Newsletter",
    description: "Footer including email signup",
    category: "footer",
    icon: "",
    prompt: "Create a footer with newsletter signup section at top, then link columns, then social and copyright. Complete footer.",
  },
  {
    title: "Social Links Footer",
    description: "Footer emphasizing social media",
    category: "footer",
    icon: "",
    prompt: "Create a footer with prominent social media icons. Large social links, essential site links, copyright. Social-focused.",
  },
  {
    title: "Contact Footer",
    description: "Footer with contact information",
    category: "footer",
    icon: "",
    prompt: "Create a footer with contact details. Address, phone, email prominently displayed. Link columns and social icons too.",
  },
  {
    title: "Footer with Map",
    description: "Footer including location map",
    category: "footer",
    icon: "",
    prompt: "Create a footer with embedded map section. Map on one side, contact info and links on other. Local business focused.",
  },
  {
    title: "Mega Footer",
    description: "Comprehensive large footer",
    category: "footer",
    icon: "",
    prompt: "Create a mega footer with many sections. Newsletter, multiple link columns, contact, social, legal links a, payment icons. Comprehensive.",
  },
  {
    title: "Minimal Dark Footer",
    description: "Dark theme minimal footer",
    category: "footer",
    icon: "",
    prompt: "Create a minimal dark-themed footer. Dark background, light text. Logo, essential links, social icons, copyright. Elegant.",
  },
  {
    title: "Footer with App Download",
    description: "Footer promoting mobile app",
    category: "footer",
    icon: "",
    prompt: "Create a footer featuring app download. App store badges prominently displayed, plus standard footer links and social.",
  },
  {
    title: "Animated Footer",
    description: "Footer with subtle animations",
    category: "footer",
    icon: "",
    prompt: "Create a footer with subtle animations. Hover effects on links, animated social icons. Modern and engaging.",
  },
];

// Helper to get templates by category
export function getTemplatesByCategory(category: string): DefaultTemplate[] {
  if (!category) return DEFAULT_TEMPLATES;
  return DEFAULT_TEMPLATES.filter(t => t.category === category);
}

// Category display info
export const CATEGORY_INFO: Record<string, { label: string; description: string; icon: string }> = {
  hero: {
    label: "Hero",
    description: "Main banner and intro sections",
    icon: "",
  },
  features: {
    label: "Features",
    description: "Product and service highlights",
    icon: "",
  },
  testimonials: {
    label: "Testimonials",
    description: "Customer reviews and social proof",
    icon: "",
  },
  pricing: {
    label: "Pricing",
    description: "Pricing tables and plan comparisons",
    icon: "",
  },
  cta: {
    label: "Call to Action",
    description: "Conversion-focused sections",
    icon: "",
  },
  faq: {
    label: "FAQ",
    description: "Frequently asked questions",
    icon: "",
  },
  team: {
    label: "Team",
    description: "Team member showcases",
    icon: "",
  },
  gallery: {
    label: "Gallery",
    description: "Image and media collections",
    icon: "",
  },
  content: {
    label: "Content",
    description: "Rich text and blog sections",
    icon: "",
  },
  footer: {
    label: "Footer",
    description: "Footer variations",
    icon: "",
  },
};
</file>

<file path="app/routes/_index/route.tsx">
import type { LoaderFunctionArgs } from "react-router";
import { redirect, Form, useLoaderData } from "react-router";

import { login } from "../../shopify.server";

import styles from "./styles.module.css";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);

  if (url.searchParams.get("shop")) {
    throw redirect(`/app?${url.searchParams.toString()}`);
  }

  return { showForm: Boolean(login) };
};

export default function App() {
  const { showForm } = useLoaderData<typeof loader>();

  return (
    <div className={styles.index}>
      <div className={styles.content}>
        <h1 className={styles.heading}>A short heading about [your app]</h1>
        <p className={styles.text}>
          A tagline about [your app] that describes your value proposition.
        </p>
        {showForm && (
          <Form className={styles.form} method="post" action="/auth/login">
            <label className={styles.label}>
              <span>Shop domain</span>
              <input className={styles.input} type="text" name="shop" />
              <span>e.g: my-shop-domain.myshopify.com</span>
            </label>
            <button className={styles.button} type="submit">
              Log in
            </button>
          </Form>
        )}
        <ul className={styles.list}>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="app/routes/_index/styles.module.css">
.index {
  align-items: center;
  display: flex;
  justify-content: center;
  height: 100%;
  width: 100%;
  text-align: center;
  padding: 1rem;
}

.heading,
.text {
  padding: 0;
  margin: 0;
}

.text {
  font-size: 1.2rem;
  padding-bottom: 2rem;
}

.content {
  display: grid;
  gap: 2rem;
}

.form {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin: 0 auto;
  gap: 1rem;
}

.label {
  display: grid;
  gap: 0.2rem;
  max-width: 20rem;
  text-align: left;
  font-size: 1rem;
}

.input {
  padding: 0.4rem;
}

.button {
  padding: 0.4rem;
}

.list {
  list-style: none;
  padding: 0;
  padding-top: 3rem;
  margin: 0;
  display: flex;
  gap: 2rem;
}

.list > li {
  max-width: 20rem;
  text-align: left;
}

@media only screen and (max-width: 50rem) {
  .list {
    display: block;
  }

  .list > li {
    padding-bottom: 1rem;
  }
}
</file>

<file path="app/routes/auth.login/error.server.tsx">
import type { LoginError } from "@shopify/shopify-app-react-router/server";
import { LoginErrorType } from "@shopify/shopify-app-react-router/server";

interface LoginErrorMessage {
  shop?: string;
}

export function loginErrorMessage(loginErrors: LoginError): LoginErrorMessage {
  if (loginErrors?.shop === LoginErrorType.MissingShop) {
    return { shop: "Please enter your shop domain to log in" };
  } else if (loginErrors?.shop === LoginErrorType.InvalidShop) {
    return { shop: "Please enter a valid shop domain to log in" };
  }

  return {};
}
</file>

<file path="app/routes/api.files.tsx">
/**
 * API Route: Files
 * Provides endpoint for fetching Shopify store images
 */

import type { LoaderFunctionArgs } from "react-router";
import { authenticate } from "../shopify.server";
import { filesService } from "../services/files.server";

export async function loader({ request }: LoaderFunctionArgs) {
  // Authenticate the request
  await authenticate.admin(request);

  // Parse query parameters
  const url = new URL(request.url);
  const first = parseInt(url.searchParams.get("first") || "20", 10);
  const after = url.searchParams.get("after") || null;
  const query = url.searchParams.get("query") || "";

  try {
    const result = await filesService.getFiles(request, {
      first: Math.min(first, 50), // Cap at 50 to prevent abuse
      after,
      query,
    });

    return Response.json(result);
  } catch (error) {
    console.error("Files API error:", error);
    return Response.json(
      {
        files: [],
        pageInfo: { hasNextPage: false, endCursor: null },
        error: error instanceof Error ? error.message : "Failed to fetch files",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/routes/app.additional.tsx">
export default function AdditionalPage() {
  return (
    <s-page heading="Additional page">
      <s-section heading="Multiple pages">
        <s-paragraph>
          The app template comes with an additional page which demonstrates how
          to create multiple pages within app navigation using{" "}
          <s-link
            href="https://shopify.dev/docs/apps/tools/app-bridge"
            target="_blank"
          >
            App Bridge
          </s-link>
          .
        </s-paragraph>
        <s-paragraph>
          To create your own page and have it show up in the app navigation, add
          a page inside <code>app/routes</code>, and a link to it in the{" "}
          <code>&lt;ui-nav-menu&gt;</code> component found in{" "}
          <code>app/routes/app.jsx</code>.
        </s-paragraph>
      </s-section>
      <s-section slot="aside" heading="Resources">
        <s-unordered-list>
          <s-list-item>
            <s-link
              href="https://shopify.dev/docs/apps/design-guidelines/navigation#app-nav"
              target="_blank"
            >
              App nav best practices
            </s-link>
          </s-list-item>
        </s-unordered-list>
      </s-section>
    </s-page>
  );
}
</file>

<file path="app/routes/app.api.resource.tsx">
/**
 * API Route: Fetch Shopify resource data for preview
 * Handles authenticated requests to fetch products, collections, articles
 */

import type { ActionFunctionArgs, LoaderFunctionArgs } from 'react-router';
import { authenticate } from '../shopify.server';
import { shopifyDataAdapter } from '../services/adapters/shopify-data-adapter';

/**
 * POST /app/api/resource
 * Fetch resource data by type and ID
 */
export async function action({ request }: ActionFunctionArgs) {
  await authenticate.admin(request);

  const formData = await request.formData();
  const resourceType = formData.get('type') as string;
  const resourceId = formData.get('id') as string;

  if (!resourceType || !resourceId) {
    return Response.json(
      { error: 'Missing type or id parameter' },
      { status: 400 }
    );
  }

  try {
    let data = null;

    switch (resourceType) {
      case 'product':
        data = await shopifyDataAdapter.getProduct(request, resourceId);
        break;
      case 'collection':
        data = await shopifyDataAdapter.getCollection(request, resourceId);
        break;
      case 'article':
        data = await shopifyDataAdapter.getArticle(request, resourceId);
        break;
      case 'shop':
        data = await shopifyDataAdapter.getShop(request);
        break;
      default:
        return Response.json(
          { error: `Unknown resource type: ${resourceType}` },
          { status: 400 }
        );
    }

    if (!data) {
      return Response.json(
        { error: `${resourceType} not found` },
        { status: 404 }
      );
    }

    return Response.json({ data });
  } catch (error) {
    console.error(`Error fetching ${resourceType}:`, error);
    return Response.json(
      { error: `Failed to fetch ${resourceType}` },
      { status: 500 }
    );
  }
}

/**
 * GET /app/api/resource?type=product&id=123
 * Alternative GET endpoint for resource fetching
 */
export async function loader({ request }: LoaderFunctionArgs) {
  await authenticate.admin(request);

  const url = new URL(request.url);
  const resourceType = url.searchParams.get('type');
  const resourceId = url.searchParams.get('id');

  if (!resourceType) {
    return Response.json(
      { error: 'Missing type parameter' },
      { status: 400 }
    );
  }

  try {
    let data = null;

    switch (resourceType) {
      case 'product':
        if (!resourceId) {
          return Response.json({ error: 'Missing id parameter' }, { status: 400 });
        }
        data = await shopifyDataAdapter.getProduct(request, resourceId);
        break;
      case 'collection':
        if (!resourceId) {
          return Response.json({ error: 'Missing id parameter' }, { status: 400 });
        }
        data = await shopifyDataAdapter.getCollection(request, resourceId);
        break;
      case 'article':
        if (!resourceId) {
          return Response.json({ error: 'Missing id parameter' }, { status: 400 });
        }
        data = await shopifyDataAdapter.getArticle(request, resourceId);
        break;
      case 'shop':
        data = await shopifyDataAdapter.getShop(request);
        break;
      default:
        return Response.json(
          { error: `Unknown resource type: ${resourceType}` },
          { status: 400 }
        );
    }

    if (!data) {
      return Response.json(
        { error: `${resourceType} not found` },
        { status: 404 }
      );
    }

    return Response.json({ data });
  } catch (error) {
    console.error(`Error fetching ${resourceType}:`, error);
    return Response.json(
      { error: `Failed to fetch ${resourceType}` },
      { status: 500 }
    );
  }
}
</file>

<file path="app/routes/auth.$.tsx">
import type { HeadersFunction, LoaderFunctionArgs } from "react-router";
import { authenticate } from "../shopify.server";
import { boundary } from "@shopify/shopify-app-react-router/server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  await authenticate.admin(request);

  return null;
};

export const headers: HeadersFunction = (headersArgs) => {
  return boundary.headers(headersArgs);
};
</file>

<file path="app/routes/webhooks.app.scopes_update.tsx">
import type { ActionFunctionArgs } from "react-router";
import { authenticate } from "../shopify.server";
import db from "../db.server";

export const action = async ({ request }: ActionFunctionArgs) => {
    const { payload, session, topic, shop } = await authenticate.webhook(request);
    console.log(`Received ${topic} webhook for ${shop}`);

    const current = payload.current as string[];
    if (session) {
        await db.session.update({   
            where: {
                id: session.id
            },
            data: {
                scope: current.toString(),
            },
        });
    }
    return new Response();
};
</file>

<file path="app/routes/webhooks.app.uninstalled.tsx">
import type { ActionFunctionArgs } from "react-router";
import { authenticate } from "../shopify.server";
import db from "../db.server";

export const action = async ({ request }: ActionFunctionArgs) => {
  const { shop, session, topic } = await authenticate.webhook(request);

  console.log(`Received ${topic} webhook for ${shop}`);

  // Webhook requests can trigger multiple times and after an app has already been uninstalled.
  // If this webhook already ran, the session may have been deleted previously.
  if (session) {
    await db.session.deleteMany({ where: { shop } });
  }

  return new Response();
};
</file>

<file path="app/services/adapters/shopify-data-adapter.ts">
import type {
  MockProduct,
  MockCollection,
  MockArticle,
  MockShop
} from '../../components/preview/mockData/types';
import { shopifyDataService } from '../shopify-data.server';

/**
 * Adapter interface for Shopify data fetching
 */
export interface ShopifyDataAdapterInterface {
  getProduct(request: Request, productId: string): Promise<MockProduct | null>;
  getCollection(request: Request, collectionId: string): Promise<MockCollection | null>;
  getArticle(request: Request, articleId: string): Promise<MockArticle | null>;
  getShop(request: Request): Promise<MockShop | null>;
  clearCache(): void;
}

/**
 * Shopify Data Service Adapter
 * Provides a consistent interface to the Shopify data fetching service
 */
class ShopifyDataAdapter implements ShopifyDataAdapterInterface {
  /**
   * Fetch a product by ID
   * @param request - The current request for authentication
   * @param productId - Product ID (can be numeric or GID format)
   */
  async getProduct(request: Request, productId: string): Promise<MockProduct | null> {
    return shopifyDataService.getProduct(request, productId);
  }

  /**
   * Fetch a collection by ID
   * @param request - The current request for authentication
   * @param collectionId - Collection ID (can be numeric or GID format)
   */
  async getCollection(request: Request, collectionId: string): Promise<MockCollection | null> {
    return shopifyDataService.getCollection(request, collectionId);
  }

  /**
   * Fetch an article by ID
   * @param request - The current request for authentication
   * @param articleId - Article ID (can be numeric or GID format)
   */
  async getArticle(request: Request, articleId: string): Promise<MockArticle | null> {
    return shopifyDataService.getArticle(request, articleId);
  }

  /**
   * Fetch shop data
   * @param request - The current request for authentication
   */
  async getShop(request: Request): Promise<MockShop | null> {
    return shopifyDataService.getShop(request);
  }

  /**
   * Clear all cached data
   */
  clearCache(): void {
    shopifyDataService.clearCache();
  }
}

export const shopifyDataAdapter = new ShopifyDataAdapter();
</file>

<file path="app/services/flags/flag-utils.ts">
import { featureFlags, FeatureFlagKey, type FlagValue } from './feature-flags';

// Re-export for convenience
export { FeatureFlagKey } from './feature-flags';

class FeatureFlagManager {
  private overrides: Map<string, FlagValue> = new Map();

  /**
   * Get flag value with environment variable override
   */
  getFlag(key: FeatureFlagKey): FlagValue {
    // Check for override first
    if (this.overrides.has(key)) {
      return this.overrides.get(key)!;
    }

    // Check environment variable
    const envKey = `FLAG_${key.toUpperCase()}`;
    const envValue = process.env[envKey];
    if (envValue !== undefined) {
      return this.parseEnvValue(envValue);
    }

    // Return default
    return featureFlags[key].defaultValue;
  }

  /**
   * Check if flag is enabled (boolean flags only)
   */
  isEnabled(key: FeatureFlagKey): boolean {
    const value = this.getFlag(key);
    return value === true || value === 'true';
  }

  /**
   * Override flag value at runtime (for testing)
   */
  setOverride(key: FeatureFlagKey, value: FlagValue): void {
    this.overrides.set(key, value);
  }

  /**
   * Clear all overrides
   */
  clearOverrides(): void {
    this.overrides.clear();
  }

  /**
   * Get all flags with current values
   */
  getAllFlags(): Record<string, FlagValue> {
    const result: Record<string, FlagValue> = {};
    Object.keys(featureFlags).forEach((key) => {
      result[key] = this.getFlag(key as FeatureFlagKey);
    });
    return result;
  }

  /**
   * Log all active flags
   */
  logFlags(): void {
    if (!this.isEnabled(FeatureFlagKey.VERBOSE_LOGGING)) {
      return;
    }

    console.log('=== Feature Flags ===');
    Object.entries(featureFlags).forEach(([key, flag]) => {
      const value = this.getFlag(key as FeatureFlagKey);
      const isDefault = value === flag.defaultValue;
      console.log(`  ${flag.key}: ${value} ${isDefault ? '(default)' : '(overridden)'}`);
    });
    console.log('====================');
  }

  private parseEnvValue(value: string): FlagValue {
    // Parse boolean
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;

    // Parse number
    const num = Number(value);
    if (!isNaN(num)) return num;

    // Return as string
    return value;
  }
}

export const flagManager = new FeatureFlagManager();

/**
 * Convenience function to check if a boolean flag is enabled
 * @param key - The feature flag key to check
 * @returns true if the flag is enabled, false otherwise
 */
export const isEnabled = (key: FeatureFlagKey) => flagManager.isEnabled(key);

/**
 * Convenience function to get a flag value
 * @param key - The feature flag key to retrieve
 * @returns The current value of the flag (boolean, string, or number)
 */
export const getFlag = (key: FeatureFlagKey) => flagManager.getFlag(key);
</file>

<file path="app/services/files.server.ts">
/**
 * Files API Service
 * Fetches files/images from Shopify using GraphQL Files API
 */

import { authenticate } from "../shopify.server";

// Types
export interface ShopifyFile {
  id: string;
  alt: string | null;
  createdAt: string;
  image: {
    url: string;
    width: number;
    height: number;
  } | null;
  filename?: string;
}

export interface FilesQueryResult {
  files: ShopifyFile[];
  pageInfo: {
    hasNextPage: boolean;
    endCursor: string | null;
  };
}

interface FilesQueryResponse {
  data?: {
    files?: {
      edges: Array<{
        node: {
          id: string;
          alt?: string | null;
          createdAt: string;
          image?: {
            url: string;
            width: number;
            height: number;
          } | null;
          originalSource?: {
            url: string;
          };
        };
        cursor: string;
      }>;
      pageInfo: {
        hasNextPage: boolean;
        endCursor: string | null;
      };
    };
  };
  errors?: Array<{ message: string }>;
}

const FILES_QUERY = `#graphql
  query getFiles($first: Int!, $after: String, $query: String) {
    files(first: $first, after: $after, query: $query, sortKey: CREATED_AT, reverse: true) {
      edges {
        node {
          ... on MediaImage {
            id
            alt
            createdAt
            image {
              url
              width
              height
            }
          }
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`;

export class FilesService {
  /**
   * Fetch images from Shopify Files
   */
  async getFiles(
    request: Request,
    options: {
      first?: number;
      after?: string | null;
      query?: string;
    } = {}
  ): Promise<FilesQueryResult> {
    const { admin } = await authenticate.admin(request);

    const { first = 20, after = null, query = "" } = options;

    // Build query string - filter to images only
    let searchQuery = "media_type:IMAGE";
    if (query.trim()) {
      searchQuery = `${query.trim()} AND media_type:IMAGE`;
    }

    const response = await admin.graphql(FILES_QUERY, {
      variables: {
        first,
        after,
        query: searchQuery,
      },
    });

    const data = (await response.json()) as FilesQueryResponse;

    if (data.errors?.length) {
      console.error("Files query errors:", data.errors);
      throw new Error(data.errors[0].message);
    }

    const edges = data.data?.files?.edges || [];
    const pageInfo = data.data?.files?.pageInfo || {
      hasNextPage: false,
      endCursor: null,
    };

    // Transform edges to files array, filtering out non-image results
    const files: ShopifyFile[] = edges
      .filter((edge) => edge.node.image?.url) // Only include nodes with images
      .map((edge) => {
        const node = edge.node;
        // Extract filename from URL or use ID
        const urlParts = node.image?.url?.split("/") || [];
        const filename = urlParts[urlParts.length - 1]?.split("?")[0] || node.id;

        return {
          id: node.id,
          alt: node.alt || null,
          createdAt: node.createdAt,
          image: node.image || null,
          filename,
        };
      });

    return {
      files,
      pageInfo,
    };
  }
}

// Singleton instance
export const filesService = new FilesService();
</file>

<file path="app/services/settings.server.ts">
import prisma from "../db.server";
import type { ShopSettings } from "@prisma/client";

/**
 * Settings service for managing shop-level settings (onboarding, preferences)
 */
export const settingsService = {
  /**
   * Get shop settings
   */
  async get(shop: string): Promise<ShopSettings | null> {
    return prisma.shopSettings.findUnique({ where: { shop } });
  },

  /**
   * Mark history as viewed (for onboarding step)
   */
  async markHistoryViewed(shop: string): Promise<ShopSettings> {
    return prisma.shopSettings.upsert({
      where: { shop },
      update: { hasViewedHistory: true },
      create: { shop, hasViewedHistory: true },
    });
  },

  /**
   * Dismiss onboarding guide
   */
  async dismissOnboarding(shop: string): Promise<ShopSettings> {
    return prisma.shopSettings.upsert({
      where: { shop },
      update: { onboardingDismissed: true },
      create: { shop, onboardingDismissed: true },
    });
  },
};
</file>

<file path="app/services/template-seeder.server.ts">
import prisma from "../db.server";
import { DEFAULT_TEMPLATES, type DefaultTemplate } from "../data/default-templates";

/**
 * Template Seeder Service
 *
 * Seeds default section templates for a shop on first access.
 * Prevents duplicate seeding by checking if shop already has templates.
 */
export const templateSeeder = {
  /**
   * Check if shop has any templates
   */
  async hasTemplates(shop: string): Promise<boolean> {
    const count = await prisma.sectionTemplate.count({
      where: { shop },
    });
    return count > 0;
  },

  /**
   * Seed default templates for a shop
   * Only seeds if shop has no existing templates
   */
  async seedDefaultTemplates(shop: string): Promise<{ seeded: boolean; count: number }> {
    // Check if already seeded
    const hasExisting = await this.hasTemplates(shop);
    if (hasExisting) {
      return { seeded: false, count: 0 };
    }

    // Seed all default templates
    const templates = DEFAULT_TEMPLATES.map((template: DefaultTemplate) => ({
      shop,
      title: template.title,
      description: template.description,
      category: template.category,
      icon: template.icon,
      prompt: template.prompt,
      code: template.code || null, // Include pre-built code if available
      isFavorite: false,
    }));

    await prisma.sectionTemplate.createMany({
      data: templates,
    });

    return { seeded: true, count: templates.length };
  },

  /**
   * Reset templates to defaults
   * Deletes all existing templates and reseeds
   */
  async resetToDefaults(shop: string): Promise<{ count: number }> {
    // Delete all existing templates for shop
    await prisma.sectionTemplate.deleteMany({
      where: { shop },
    });

    // Seed default templates
    const templates = DEFAULT_TEMPLATES.map((template: DefaultTemplate) => ({
      shop,
      title: template.title,
      description: template.description,
      category: template.category,
      icon: template.icon,
      prompt: template.prompt,
      code: template.code || null, // Include pre-built code if available
      isFavorite: false,
    }));

    await prisma.sectionTemplate.createMany({
      data: templates,
    });

    return { count: templates.length };
  },

  /**
   * Get count of default templates
   */
  getDefaultTemplateCount(): number {
    return DEFAULT_TEMPLATES.length;
  },

  /**
   * Get default templates (for reference/preview)
   */
  getDefaultTemplates(): DefaultTemplate[] {
    return DEFAULT_TEMPLATES;
  },
};
</file>

<file path="app/services/template.server.ts">
import prisma from "../db.server";
import type { SectionTemplate } from "@prisma/client";

export interface CreateTemplateInput {
  shop: string;
  title: string;
  description: string;
  category: string;
  icon: string;
  prompt: string;
  code?: string;
}

export interface UpdateTemplateInput {
  title?: string;
  description?: string;
  category?: string;
  icon?: string;
  prompt?: string;
  code?: string;
  isFavorite?: boolean;
}

/**
 * Template service for managing section templates
 */
export const templateService = {
  /**
   * Create a new template
   */
  async create(input: CreateTemplateInput): Promise<SectionTemplate> {
    return prisma.sectionTemplate.create({
      data: {
        shop: input.shop,
        title: input.title,
        description: input.description,
        category: input.category,
        icon: input.icon,
        prompt: input.prompt,
        code: input.code,
      },
    });
  },

  /**
   * Update a template
   */
  async update(id: string, shop: string, input: UpdateTemplateInput): Promise<SectionTemplate | null> {
    const existing = await prisma.sectionTemplate.findFirst({
      where: { id, shop },
    });

    if (!existing) return null;

    return prisma.sectionTemplate.update({
      where: { id },
      data: input,
    });
  },

  /**
   * Get all templates for a shop
   */
  async getByShop(
    shop: string,
    options: { category?: string; favoritesOnly?: boolean } = {}
  ): Promise<SectionTemplate[]> {
    const { category, favoritesOnly } = options;

    return prisma.sectionTemplate.findMany({
      where: {
        shop,
        ...(category && { category }),
        ...(favoritesOnly && { isFavorite: true }),
      },
      orderBy: { createdAt: "desc" },
    });
  },

  /**
   * Get single template by ID
   */
  async getById(id: string, shop: string): Promise<SectionTemplate | null> {
    return prisma.sectionTemplate.findFirst({
      where: { id, shop },
    });
  },

  /**
   * Toggle favorite status
   */
  async toggleFavorite(id: string, shop: string): Promise<SectionTemplate | null> {
    const existing = await prisma.sectionTemplate.findFirst({
      where: { id, shop },
    });

    if (!existing) return null;

    return prisma.sectionTemplate.update({
      where: { id },
      data: { isFavorite: !existing.isFavorite },
    });
  },

  /**
   * Delete template
   */
  async delete(id: string, shop: string): Promise<boolean> {
    const existing = await prisma.sectionTemplate.findFirst({
      where: { id, shop },
    });

    if (!existing) return false;

    await prisma.sectionTemplate.delete({ where: { id } });
    return true;
  },

  /**
   * Duplicate template
   */
  async duplicate(id: string, shop: string): Promise<SectionTemplate | null> {
    const existing = await prisma.sectionTemplate.findFirst({
      where: { id, shop },
    });

    if (!existing) return null;

    return prisma.sectionTemplate.create({
      data: {
        shop: existing.shop,
        title: `${existing.title} (Copy)`,
        description: existing.description,
        category: existing.category,
        icon: existing.icon,
        prompt: existing.prompt,
        code: existing.code,
        isFavorite: false,
      },
    });
  },
};
</file>

<file path="app/types/index.ts">
/**
 * Central export for all type definitions
 */

// Shopify API Types
export type {
  Theme,
  ThemeEdge,
  ThemesQueryResponse,
  ThemeFile,
  ThemeFileMetadata,
  UserError,
  ThemeFilesUpsertResponse,
  ServiceResult,
} from './shopify-api.types';

// Service Types
export type {
  AIGenerationOptions,
  AIGenerationResult,
  AIServiceInterface,
  ThemeServiceInterface,
  GeneratedSectionRecord,
  GenerateActionData,
  SaveActionData,
} from './service.types';
</file>

<file path="app/types/shopify-api.types.ts">
/**
 * Shopify Admin GraphQL API Response Types
 * These types match the structure of Shopify GraphQL API responses
 */

// Theme Types
export interface Theme {
  id: string;
  name: string;
  role: 'MAIN' | 'UNPUBLISHED' | 'DEVELOPMENT';
  createdAt?: string;
  updatedAt?: string;
}

export interface ThemeEdge {
  node: Theme;
}

export interface ThemesQueryResponse {
  data?: {
    themes?: {
      edges: ThemeEdge[];
    };
  };
  errors?: Array<{ message: string }>;
}

// Theme File Types
export interface ThemeFile {
  filename: string;
  body?: {
    type: 'TEXT';
    value: string;
  };
}

export interface ThemeFileMetadata {
  filename: string;
  size?: number;
  contentType?: string;
  checksum?: string;
}

export interface UserError {
  message: string;
  field?: string[];
}

export interface ThemeFilesUpsertResponse {
  data?: {
    themeFilesUpsert?: {
      upsertedThemeFiles?: ThemeFileMetadata[];
      userErrors?: UserError[];
    };
  };
  errors?: Array<{ message: string }>;
}

// Generic Service Response
export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}
</file>

<file path="app/db.server.ts">
import { PrismaClient } from "@prisma/client";

declare global {
  // eslint-disable-next-line no-var
  var prismaGlobal: PrismaClient;
}

if (process.env.NODE_ENV !== "production") {
  if (!global.prismaGlobal) {
    global.prismaGlobal = new PrismaClient();
  }
}

const prisma = global.prismaGlobal ?? new PrismaClient();

export default prisma;
</file>

<file path="app/entry.server.tsx">
import { PassThrough } from "stream";
import { renderToPipeableStream } from "react-dom/server";
import { ServerRouter } from "react-router";
import { createReadableStreamFromReadable } from "@react-router/node";
import { type EntryContext } from "react-router";
import { isbot } from "isbot";
import { addDocumentResponseHeaders } from "./shopify.server";

export const streamTimeout = 5000;

export default async function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  reactRouterContext: EntryContext
) {
  addDocumentResponseHeaders(request, responseHeaders);
  const userAgent = request.headers.get("user-agent");
  const callbackName = isbot(userAgent ?? '')
    ? "onAllReady"
    : "onShellReady";

  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <ServerRouter
        context={reactRouterContext}
        url={request.url}
      />,
      {
        [callbackName]: () => {
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          console.error(error);
        },
      }
    );

    // Automatically timeout the React renderer after 6 seconds, which ensures
    // React has enough time to flush down the rejected boundary contents
    setTimeout(abort, streamTimeout + 1000);
  });
}
</file>

<file path="app/root.tsx">
import { Links, Meta, Outlet, Scripts, ScrollRestoration } from "react-router";

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <link rel="preconnect" href="https://cdn.shopify.com/" />
        <link
          rel="stylesheet"
          href="https://cdn.shopify.com/static/fonts/inter/v4/styles.css"
        />
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
</file>

<file path="app/routes.ts">
import { flatRoutes } from "@react-router/fs-routes";

export default flatRoutes();
</file>

<file path="app/shopify.server.ts">
import "@shopify/shopify-app-react-router/adapters/node";
import {
  ApiVersion,
  AppDistribution,
  shopifyApp,
} from "@shopify/shopify-app-react-router/server";
import { PrismaSessionStorage } from "@shopify/shopify-app-session-storage-prisma";
import prisma from "./db.server";

const shopify = shopifyApp({
  apiKey: process.env.SHOPIFY_API_KEY,
  apiSecretKey: process.env.SHOPIFY_API_SECRET || "",
  apiVersion: ApiVersion.October25,
  scopes: process.env.SCOPES?.split(","),
  appUrl: process.env.SHOPIFY_APP_URL || "",
  authPathPrefix: "/auth",
  sessionStorage: new PrismaSessionStorage(prisma),
  distribution: AppDistribution.AppStore,
  ...(process.env.SHOP_CUSTOM_DOMAIN
    ? { customShopDomains: [process.env.SHOP_CUSTOM_DOMAIN] }
    : {}),
});

export default shopify;
export const apiVersion = ApiVersion.October25;
export const addDocumentResponseHeaders = shopify.addDocumentResponseHeaders;
export const authenticate = shopify.authenticate;
export const unauthenticated = shopify.unauthenticated;
export const login = shopify.login;
export const registerWebhooks = shopify.registerWebhooks;
export const sessionStorage = shopify.sessionStorage;
</file>

<file path="prisma/seed-plans.ts">
/**
 * Seed script for plan configurations
 * Run with: npx tsx prisma/seed-plans.ts
 */

import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

const plans = [
  {
    planName: "starter",
    displayName: "Starter",
    description: "Perfect for solo merchants and freelancers",
    basePrice: 19.0,
    includedQuota: 50,
    overagePrice: 0.5,
    cappedAmount: 30.0,
    features: [
      "50 AI section generations per month",
      "$0.50 per additional section",
      "Save sections to any theme",
      "Generation history",
      "Section templates",
      "Email support",
    ],
    badge: null,
    sortOrder: 1,
    isActive: true,
  },
  {
    planName: "growth",
    displayName: "Growth",
    description: "Best for small agencies and power users",
    basePrice: 49.0,
    includedQuota: 200,
    overagePrice: 0.4,
    cappedAmount: 100.0,
    features: [
      "200 AI section generations per month",
      "$0.40 per additional section",
      "Everything in Starter",
      "Priority support",
      "Advanced templates",
      "Usage analytics",
    ],
    badge: "Popular",
    sortOrder: 2,
    isActive: true,
  },
  {
    planName: "professional",
    displayName: "Professional",
    description: "For enterprise agencies and SaaS platforms",
    basePrice: 149.0,
    includedQuota: 800,
    overagePrice: 0.3,
    cappedAmount: 300.0,
    features: [
      "800 AI section generations per month",
      "$0.30 per additional section",
      "Everything in Growth",
      "Dedicated support",
      "Custom templates",
      "API access (coming soon)",
      "Priority feature requests",
    ],
    badge: "Best Value",
    sortOrder: 3,
    isActive: true,
  },
];

async function main() {
  console.log("Seeding plan configurations...");

  for (const plan of plans) {
    const result = await prisma.planConfiguration.upsert({
      where: { planName: plan.planName },
      update: plan,
      create: plan,
    });

    console.log(` ${result.displayName} plan: $${result.basePrice}/mo, ${result.includedQuota} sections included`);
  }

  console.log("\nPlan configurations seeded successfully!");
}

main()
  .catch((error) => {
    console.error("Error seeding plans:", error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="public/images/onboarding/generate-section.svg">
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Code Editor Window -->
  <rect x="10" y="15" width="90" height="70" rx="6" fill="#7C6AE8" stroke="#5B4BC7" stroke-width="2"/>

  <!-- Window Title Bar -->
  <rect x="10" y="15" width="90" height="14" rx="6" fill="#5B4BC7"/>
  <rect x="10" y="23" width="90" height="6" fill="#5B4BC7"/>

  <!-- Window Buttons -->
  <circle cx="20" cy="22" r="3" fill="#FF6B6B"/>
  <circle cx="30" cy="22" r="3" fill="#FFD93D"/>
  <circle cx="40" cy="22" r="3" fill="#6BCB77"/>

  <!-- Code Lines -->
  <rect x="18" y="38" width="35" height="4" rx="2" fill="#A5F3C0"/>
  <rect x="18" y="46" width="50" height="4" rx="2" fill="#E0E7FF"/>
  <rect x="26" y="54" width="40" height="4" rx="2" fill="#93C5FD"/>
  <rect x="26" y="62" width="55" height="4" rx="2" fill="#A5F3C0"/>
  <rect x="18" y="70" width="30" height="4" rx="2" fill="#E0E7FF"/>

  <!-- Magic Sparkle -->
  <path d="M95 10L97 16L103 18L97 20L95 26L93 20L87 18L93 16L95 10Z" fill="#FFD93D"/>
  <circle cx="102" cy="12" r="2" fill="#FFD93D"/>
  <circle cx="88" cy="8" r="1.5" fill="#FFD93D"/>

  <!-- Cursor/Wand -->
  <rect x="75" y="50" width="3" height="15" rx="1" fill="#FFD93D" transform="rotate(-30 75 50)"/>

  <!-- Bottom decoration -->
  <rect x="25" y="95" width="20" height="3" rx="1.5" fill="#C4B5FD"/>
  <rect x="50" y="95" width="30" height="3" rx="1.5" fill="#C4B5FD"/>
  <rect x="85" y="95" width="10" height="3" rx="1.5" fill="#C4B5FD"/>
</svg>
</file>

<file path="public/images/onboarding/save-template.svg">
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Back Document -->
  <rect x="35" y="10" width="60" height="75" rx="4" fill="#E0E7FF" stroke="#A5B4FC" stroke-width="2"/>
  <rect x="43" y="22" width="35" height="4" rx="2" fill="#A5B4FC"/>
  <rect x="43" y="30" width="44" height="4" rx="2" fill="#C4B5FD"/>
  <rect x="43" y="38" width="30" height="4" rx="2" fill="#A5B4FC"/>

  <!-- Middle Document -->
  <rect x="28" y="18" width="60" height="75" rx="4" fill="#F0FDF4" stroke="#86EFAC" stroke-width="2"/>
  <rect x="36" y="30" width="35" height="4" rx="2" fill="#86EFAC"/>
  <rect x="36" y="38" width="44" height="4" rx="2" fill="#BBF7D0"/>
  <rect x="36" y="46" width="30" height="4" rx="2" fill="#86EFAC"/>

  <!-- Front Folder -->
  <path d="M15 45 L15 100 Q15 105 20 105 L85 105 Q90 105 90 100 L90 55 Q90 50 85 50 L50 50 L45 45 L20 45 Q15 45 15 50 Z" fill="#4ADE80" stroke="#22C55E" stroke-width="2"/>

  <!-- Folder Tab -->
  <path d="M20 45 L45 45 L50 50 L20 50 Q15 50 15 45 Z" fill="#22C55E"/>

  <!-- Bookmark -->
  <path d="M75 40 L75 65 L80 60 L85 65 L85 40 Z" fill="#8B5CF6"/>

  <!-- Star Badge -->
  <circle cx="70" cy="80" r="12" fill="#FEF3C7" stroke="#FCD34D" stroke-width="2"/>
  <path d="M70 72L72 77H77L73 80L75 85L70 82L65 85L67 80L63 77H68L70 72Z" fill="#FCD34D"/>
</svg>
</file>

<file path="public/images/onboarding/view-history.svg">
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Clock Circle -->
  <circle cx="60" cy="55" r="45" fill="#FEF3C7" stroke="#F59E0B" stroke-width="3"/>

  <!-- Clock Inner Circle -->
  <circle cx="60" cy="55" r="38" fill="white" stroke="#FCD34D" stroke-width="2"/>

  <!-- Hour Markers -->
  <rect x="58" y="20" width="4" height="8" rx="2" fill="#F59E0B"/>
  <rect x="58" y="82" width="4" height="8" rx="2" fill="#F59E0B"/>
  <rect x="20" y="53" width="8" height="4" rx="2" fill="#F59E0B"/>
  <rect x="92" y="53" width="8" height="4" rx="2" fill="#F59E0B"/>

  <!-- Clock Hands -->
  <rect x="58" y="35" width="4" height="22" rx="2" fill="#7C3AED"/>
  <rect x="58" y="50" width="20" height="4" rx="2" fill="#7C3AED" transform="rotate(30 60 55)"/>

  <!-- Center Dot -->
  <circle cx="60" cy="55" r="4" fill="#7C3AED"/>

  <!-- History List Items -->
  <rect x="5" y="100" width="30" height="6" rx="3" fill="#C4B5FD"/>
  <rect x="40" y="100" width="40" height="6" rx="3" fill="#E0E7FF"/>
  <rect x="85" y="100" width="25" height="6" rx="3" fill="#C4B5FD"/>

  <!-- Timeline dots -->
  <circle cx="15" cy="108" r="3" fill="#8B5CF6"/>
  <circle cx="55" cy="108" r="3" fill="#A78BFA"/>
  <circle cx="95" cy="108" r="3" fill="#8B5CF6"/>

  <!-- Magnifying Glass -->
  <circle cx="95" cy="75" r="12" fill="white" stroke="#22C55E" stroke-width="3"/>
  <rect x="103" y="83" width="4" height="15" rx="2" fill="#22C55E" transform="rotate(45 103 83)"/>

  <!-- Eye in magnifying glass -->
  <circle cx="95" cy="75" r="5" fill="#22C55E"/>
  <circle cx="95" cy="75" r="2" fill="white"/>
</svg>
</file>

<file path=".dockerignore">
.cache
build
node_modules
</file>

<file path=".editorconfig">
# editorconfig.org
root = true

[*]
charset = utf-8
indent_size = 2
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true

# Markdown syntax specifies that trailing whitespaces can be meaningful,
# so lets not trim those. e.g. 2 trailing spaces = linebreak (<br />)
# See https://daringfireball.net/projects/markdown/syntax#p
[*.md]
trim_trailing_whitespace = false
</file>

<file path=".eslintignore">
node_modules
build
public/build
*/*.yml
.shopify
</file>

<file path=".graphqlrc.ts">
import fs from "fs";
import { ApiVersion } from "@shopify/shopify-app-react-router/server";
import { shopifyApiProject, ApiType } from "@shopify/api-codegen-preset";
import type { IGraphQLConfig } from "graphql-config";

function getConfig() {
  const config: IGraphQLConfig = {
    projects: {
      default: shopifyApiProject({
        apiType: ApiType.Admin,
        apiVersion: ApiVersion.October25,
        documents: ["./app/**/*.{js,ts,jsx,tsx}", "./app/.server/**/*.{js,ts,jsx,tsx}"],
        outputDir: "./app/types",
      }),
    },
  };

  let extensions: string[] = [];
  try {
    extensions = fs.readdirSync("./extensions");
  } catch {
    // ignore if no extensions
  }

  for (const entry of extensions) {
    const extensionPath = `./extensions/${entry}`;
    const schema = `${extensionPath}/schema.graphql`;
    if (!fs.existsSync(schema)) {
      continue;
    }
    config.projects[entry] = {
      schema,
      documents: [`${extensionPath}/**/*.graphql`],
    };
  }

  return config;
}

const config = getConfig();

export default config;
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "shopify-dev-mcp": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "@shopify/dev-mcp@latest"],
      "env": {
        "POLARIS_UNIFIED": "true",
        "LIQUID": "true"
      }
    }
  }
}
</file>

<file path=".npmrc">
engine-strict=true
shamefully-hoist=true
</file>

<file path=".prettierignore">
package.json
.shadowenv.d
.vscode
node_modules
prisma
public
.shopify
</file>

<file path=".repomixignore">
docs/*
plans/*
assets/*
dist/*
coverage/*
build/*
ios/*
android/*
tests/*
__tests__/*
__pycache__/*
node_modules/*

.opencode/*
.claude/*
.serena/*
.pnpm-store/*
.github/*
.dart_tool/*
.idea/*
.husky/*
.venv/*
</file>

<file path="CHANGELOG.md">
# @shopify/shopify-app-template-react-router

## 2025.10.10

- [#95](https://github.com/Shopify/shopify-app-template-react-router/pull/95) Swap the product link for [admin intents](https://shopify.dev/docs/apps/build/admin/admin-intents).

## 2025.10.02

- [#81](https://github.com/Shopify/shopify-app-template-react-router/pull/81) Add shopify global to eslint for ui extensions

## 2025.10.01

- [#79](https://github.com/Shopify/shopify-app-template-react-router/pull/78) Update API version to 2025-10.
- [#77](https://github.com/Shopify/shopify-app-template-react-router/pull/77) Update `@shopify/shopify-app-react-router` to V1.
- [#73](https://github.com/Shopify/shopify-app-template-react-router/pull/73/files) Rename @shopify/app-bridge-ui-types to @shopify/polaris-types

## 2025.08.30

- [#70](https://github.com/Shopify/shopify-app-template-react-router/pull/70/files) Upgrade `@shopify/app-bridge-ui-types` from 0.2.1 to 0.3.1.

## 2025.08.17

- [#58](https://github.com/Shopify/shopify-app-template-react-router/pull/58) Update Shopify & React Router dependencies.  Use Shopify React Router in graphqlrc, not shopify-api
- [#57](https://github.com/Shopify/shopify-app-template-react-router/pull/57) Update Webhook API version in `shopify.app.toml` to `2025-07`
- [#56](https://github.com/Shopify/shopify-app-template-react-router/pull/56) Remove local CLI from package.json in favor of global CLI installation
- [#53](https://github.com/Shopify/shopify-app-template-react-router/pull/53) Add the Shopify Dev MCP to the template

## 2025.08.16

- [#52](https://github.com/Shopify/shopify-app-template-react-router/pull/52) Use `ApiVersion.July25` rather than `LATEST_API_VERSION` in `.graphqlrc`.

## 2025.07.24

- [14](https://github.com/Shopify/shopify-app-template-react-router/pull/14/files) Add [App Bridge web components](https://shopify.dev/docs/api/app-home/app-bridge-web-components) to the template.

## July 2025

Forked the [shopify-app-template repo](https://github.com/Shopify/shopify-app-template-remix)

# @shopify/shopify-app-template-remix

## 2025.03.18

-[#998](https://github.com/Shopify/shopify-app-template-remix/pull/998) Update to Vite 6

## 2025.03.01

- [#982](https://github.com/Shopify/shopify-app-template-remix/pull/982) Add Shopify Dev Assistant extension to the VSCode extension recommendations

## 2025.01.31

- [#952](https://github.com/Shopify/shopify-app-template-remix/pull/952) Update to Shopify App API v2025-01

## 2025.01.23

- [#923](https://github.com/Shopify/shopify-app-template-remix/pull/923) Update `@shopify/shopify-app-session-storage-prisma` to v6.0.0

## 2025.01.8

- [#923](https://github.com/Shopify/shopify-app-template-remix/pull/923) Enable GraphQL autocomplete for Javascript

## 2024.12.19

- [#904](https://github.com/Shopify/shopify-app-template-remix/pull/904) bump `@shopify/app-bridge-react` to latest
-
## 2024.12.18

- [875](https://github.com/Shopify/shopify-app-template-remix/pull/875) Add Scopes Update Webhook
## 2024.12.05

- [#910](https://github.com/Shopify/shopify-app-template-remix/pull/910) Install `openssl` in Docker image to fix Prisma (see [#25817](https://github.com/prisma/prisma/issues/25817#issuecomment-2538544254))
- [#907](https://github.com/Shopify/shopify-app-template-remix/pull/907) Move `@remix-run/fs-routes` to `dependencies` to fix Docker image build
- [#899](https://github.com/Shopify/shopify-app-template-remix/pull/899) Disable v3_singleFetch flag
- [#898](https://github.com/Shopify/shopify-app-template-remix/pull/898) Enable the `removeRest` future flag so new apps aren't tempted to use the REST Admin API.

## 2024.12.04

- [#891](https://github.com/Shopify/shopify-app-template-remix/pull/891) Enable remix future flags.

## 2024.11.26

- [888](https://github.com/Shopify/shopify-app-template-remix/pull/888) Update restResources version to 2024-10

## 2024.11.06

- [881](https://github.com/Shopify/shopify-app-template-remix/pull/881) Update to the productCreate mutation to use the new ProductCreateInput type

## 2024.10.29

- [876](https://github.com/Shopify/shopify-app-template-remix/pull/876) Update shopify-app-remix to v3.4.0 and shopify-app-session-storage-prisma to v5.1.5

## 2024.10.02

- [863](https://github.com/Shopify/shopify-app-template-remix/pull/863) Update to Shopify App API v2024-10 and shopify-app-remix v3.3.2

## 2024.09.18

- [850](https://github.com/Shopify/shopify-app-template-remix/pull/850) Removed "~" import alias

## 2024.09.17

- [842](https://github.com/Shopify/shopify-app-template-remix/pull/842) Move webhook processing to individual routes

## 2024.08.19

Replaced deprecated `productVariantUpdate` with `productVariantsBulkUpdate`

## v2024.08.06

Allow `SHOP_REDACT` webhook to process without admin context

## v2024.07.16

Started tracking changes and releases using calver
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Role & Responsibilities

Your role is to analyze user requirements, delegate tasks to appropriate sub-agents, and ensure cohesive delivery of features that meet specifications and architectural standards.

## Workflows

- Primary workflow: `./.claude/workflows/primary-workflow.md`
- Development rules: `./.claude/workflows/development-rules.md`
- Orchestration protocols: `./.claude/workflows/orchestration-protocol.md`
- Documentation management: `./.claude/workflows/documentation-management.md`
- And other workflows: `./.claude/workflows/*`

**IMPORTANT:** Analyze the skills catalog and activate the skills that are needed for the task during the process.
**IMPORTANT:** You must follow strictly the development rules in `./.claude/workflows/development-rules.md` file.
**IMPORTANT:** Before you plan or proceed any implementation, always read the `./README.md` file first to get context.
**IMPORTANT:** Sacrifice grammar for the sake of concision when writing reports.
**IMPORTANT:** In reports, list any unresolved questions at the end, if any.
**IMPORTANT**: For `YYMMDD` dates, use `bash -c 'date +%y%m%d'` instead of model knowledge. Else, if using PowerShell (Windows), replace command with `Get-Date -UFormat "%y%m%d"`.

## Documentation Management

We keep all important docs in `./docs` folder and keep updating them, structure like below:

```
./docs
 project-overview-pdr.md
 code-standards.md
 codebase-summary.md
 design-guidelines.md
 deployment-guide.md
 system-architecture.md
 project-roadmap.md
```

**IMPORTANT:** *MUST READ* and *MUST COMPLY* all *INSTRUCTIONS* in project `./CLAUDE.md`, especially *WORKFLOWS* section is *CRITICALLY IMPORTANT*, this rule is *MANDATORY. NON-NEGOTIABLE. NO EXCEPTIONS. MUST REMEMBER AT ALL TIMES!!!*
</file>

<file path="Dockerfile">
FROM node:20-alpine
RUN apk add --no-cache openssl

EXPOSE 3000

WORKDIR /app

ENV NODE_ENV=production

COPY package.json package-lock.json* ./

RUN npm ci --omit=dev && npm cache clean --force

COPY . .

RUN npm run build

CMD ["npm", "run", "docker-start"]
</file>

<file path="env.d.ts">
/// <reference types="vite/client" />
/// <reference types="@react-router/node" />
</file>

<file path="jest.setup.cjs">
require('@testing-library/jest-dom');
require('whatwg-fetch');
const { TextEncoder, TextDecoder } = require('util');

// Polyfill for jsdom
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;

// Mock environment variables
process.env.SERVICE_MODE = 'mock';
process.env.FLAG_VERBOSE_LOGGING = 'false';
process.env.FLAG_USE_MOCK_THEMES = 'true';
process.env.FLAG_USE_MOCK_AI = 'true';

// Suppress console output in tests
global.console = {
  ...console,
  log: jest.fn(),
  warn: jest.fn(),
};
</file>

<file path="vite.config.ts">
import { reactRouter } from "@react-router/dev/vite";
import { defineConfig, type UserConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

// Related: https://github.com/remix-run/remix/issues/2835#issuecomment-1144102176
// Replace the HOST env var with SHOPIFY_APP_URL so that it doesn't break the Vite server.
// The CLI will eventually stop passing in HOST,
// so we can remove this workaround after the next major release.
if (
  process.env.HOST &&
  (!process.env.SHOPIFY_APP_URL ||
    process.env.SHOPIFY_APP_URL === process.env.HOST)
) {
  process.env.SHOPIFY_APP_URL = process.env.HOST;
  delete process.env.HOST;
}

const host = new URL(process.env.SHOPIFY_APP_URL || "http://localhost")
  .hostname;

let hmrConfig;
if (host === "localhost") {
  hmrConfig = {
    protocol: "ws",
    host: "localhost",
    port: 64999,
    clientPort: 64999,
  };
} else {
  hmrConfig = {
    protocol: "wss",
    host: host,
    port: parseInt(process.env.FRONTEND_PORT!) || 8002,
    clientPort: 443,
  };
}

export default defineConfig({
  server: {
    allowedHosts: [host],
    cors: {
      preflightContinue: true,
    },
    port: Number(process.env.PORT || 3000),
    hmr: hmrConfig,
    fs: {
      // See https://vitejs.dev/config/server-options.html#server-fs-allow for more information
      allow: ["app", "node_modules"],
    },
  },
  plugins: [
    reactRouter(),
    tsconfigPaths(),
  ],
  build: {
    assetsInlineLimit: 0,
  },
  optimizeDeps: {
    include: ["@shopify/app-bridge-react"],
  },
}) satisfies UserConfig;
</file>

<file path="app/components/billing/PlanCard.tsx">
/**
 * Individual plan card component
 * Displays pricing, features, and selection CTA
 */

import { useState } from "react";
import type { PlanConfig } from "../../types/billing";

interface PlanCardProps {
  plan: PlanConfig;
  isCurrentPlan: boolean;
  onSelect: () => void;
}

export function PlanCard({ plan, isCurrentPlan, onSelect }: PlanCardProps) {
  const [expanded, setExpanded] = useState(false);

  // Determine badge tone
  const badgeTone =
    plan.badge === "Popular"
      ? "success"
      : plan.badge === "Best Value"
        ? "warning"
        : "info";

  return (
    <s-box
      border="base"
      borderRadius="base"
      padding="base"
      background={plan.badge ? "subdued" : "base"}
    >
      <s-grid gap="base">
        <s-stack direction="inline" gap="large small-300">
          {/* Plan Name */}
          <s-heading>{plan.displayName}</s-heading>
          {/* Badge (Popular/Best Value) */}
          {plan.badge && <s-badge tone={badgeTone}>{plan.badge}</s-badge>}
        </s-stack>

        {/* Pricing */}
        <s-grid gap="small-100">
          <s-text type="strong" fontVariantNumeric="tabular-nums">
            ${plan.basePrice}/month
          </s-text>
        </s-grid>

        {/* Features List */}
        <s-grid gap="small-100">
          {plan.features.slice(0, 3).map((feature, i) => (
            <s-grid
              key={i}
              gridTemplateColumns="auto 1fr"
              gap="small-100"
              alignItems="center"
            >
              <s-text> {feature}</s-text>
            </s-grid>
          ))}

          {/* Progressive Disclosure: More Features */}
          {plan.features.length > 3 && (
            <>
              <s-box display={expanded ? "auto" : "none"}>
                <s-grid gap="small-100">
                  {plan.features.slice(3).map((feature, i) => (
                    <s-grid
                      key={i}
                      gridTemplateColumns="auto 1fr"
                      gap="small-100"
                      alignItems="center"
                    >
                      <s-text> {feature}</s-text>
                    </s-grid>
                  ))}
                </s-grid>
              </s-box>
              <s-button
                variant="tertiary"
                onClick={() => setExpanded(!expanded)}
                accessibilityLabel={
                  expanded
                    ? "Show less features"
                    : `Show ${plan.features.length - 3} more features`
                }
              >
                {expanded
                  ? "Show less"
                  : `Show ${plan.features.length - 3} more`}
              </s-button>
            </>
          )}
        </s-grid>

        {/* CTA Button */}
        <s-box>
          <s-button
            variant={plan.badge ? "primary" : "secondary"}
            onClick={onSelect}
            disabled={isCurrentPlan}
            accessibilityLabel={
              isCurrentPlan
                ? `Current plan: ${plan.displayName}`
                : `Select ${plan.displayName} plan`
            }
          >
            {isCurrentPlan ? "Current Plan" : `Select ${plan.displayName}`}
          </s-button>
        </s-box>
      </s-grid>
    </s-box>
  );
}
</file>

<file path="app/components/generate/EmptyState.tsx">
export interface EmptyStateProps {
  heading: string;
  message: string;
  icon?: string;
  action?: {
    label: string;
    onClick: () => void;
  };
}

/**
 * Empty state for preview column
 * Displayed when no code generated yet
 * Follows Shopify's empty state pattern
 */
export function EmptyState({
  heading,
  message,
  icon = '',
  action
}: EmptyStateProps) {
  return (
    <s-box
      padding="large-200"
      background="subdued"
      borderRadius="base"
    >
      <s-stack gap="base" direction="block" alignItems="center">
        <s-text>{icon}</s-text>
        <s-heading>{heading}</s-heading>
        <s-paragraph color="subdued">{message}</s-paragraph>
        {action && (
          <s-button onClick={action.onClick} variant="secondary">
            {action.label}
          </s-button>
        )}
      </s-stack>
    </s-box>
  );
}
</file>

<file path="app/components/generate/LoadingState.tsx">
export interface LoadingStateProps {
  message: string;
  subMessage?: string;
  size?: 'base' | 'large' | 'large-100';
}

/**
 * Loading state with spinner and message
 * Used during generation or save operations
 * Uses proper Polaris components
 */
export function LoadingState({
  message,
  subMessage,
  size = 'large'
}: LoadingStateProps) {
  return (
    <s-box padding="large-200">
      <s-stack gap="base" direction="block" alignItems="center">
        <s-spinner size={size} accessibilityLabel="Loading" />
        <s-paragraph color="subdued">{message}</s-paragraph>
        {subMessage && (
          <s-text color="subdued">{subMessage}</s-text>
        )}
      </s-stack>
    </s-box>
  );
}
</file>

<file path="app/components/generate/SectionTypeSelector.tsx">
/**
 * Section Type Selector Component
 * Toggle between "Customizable" and "Production-Ready" section modes
 */

export type SectionType = "customizable" | "production-ready";

export interface SectionTypeSelectorProps {
  value: SectionType;
  onChange: (type: SectionType) => void;
  disabled?: boolean;
}

/**
 * Button group for selecting section generation mode
 * - Customizable: Full schema with settings for theme editor customization
 * - Production-Ready: Static content ready to use immediately
 */
export function SectionTypeSelector({
  value,
  onChange,
  disabled = false,
}: SectionTypeSelectorProps) {
  return (
    <s-select
      label="Section Type"
      value={value}
      onChange={(e: Event) => {
        const target = e.target as HTMLSelectElement;
        onChange(target.value as SectionType);
      }}
      disabled={disabled || undefined}
      details={
        value === "customizable"
          ? "Full schema with settings for theme editor customization"
          : "Static content ready to use immediately, no customization needed"
      }
    >
      <s-option value="customizable">Customizable</s-option>
      <s-option value="production-ready">Production-Ready</s-option>
    </s-select>
  );
}
</file>

<file path="app/components/home/FeatureNav.tsx">
import { Fragment } from "react";

const FEATURES = [
  {
    title: "Create Sections",
    description: "AI-powered Liquid code from natural language",
    href: "/app/sections/new",
    icon: "wand",
  },
  {
    title: "Template Library",
    description: "Save and reuse your best prompts",
    href: "/app/templates",
    icon: "file-list",
  },
  {
    title: "Section History",
    description: "Track all your generated sections",
    href: "/app/sections",
    icon: "clock",
  },
] as const;

export function FeatureNav() {
  return (
    <s-section heading="Features">
      <s-box border="base" borderRadius="base">
        {FEATURES.map((feature, i) => (
          <Fragment key={feature.title}>
            <s-clickable href={feature.href} padding="base">
              <s-grid
                gridTemplateColumns="auto 1fr auto"
                alignItems="center"
                gap="base"
              >
                <s-icon type={feature.icon} />
                <s-box>
                  <s-text type="strong">{feature.title}</s-text>
                  <s-paragraph color="subdued">{feature.description}</s-paragraph>
                </s-box>
                <s-icon type="chevron-right" color="subdued" />
              </s-grid>
            </s-clickable>
            {i < FEATURES.length - 1 && (
              <s-box paddingInline="base">
                <s-divider />
              </s-box>
            )}
          </Fragment>
        ))}
      </s-box>
    </s-section>
  );
}
</file>

<file path="app/components/home/SetupGuide.tsx">
import { Fragment, useState } from "react";
import { useFetcher, useNavigate } from "react-router";

interface OnboardingState {
  hasGeneratedSection: boolean;
  hasSavedTemplate: boolean;
  hasViewedHistory: boolean;
  isDismissed: boolean;
}

interface SetupGuideProps {
  onboarding: OnboardingState;
}

const SETUP_STEPS = [
  {
    id: "generate",
    title: "Create your first section",
    description:
      "Describe what you want in natural language and get production-ready Liquid code for your Shopify theme.",
    href: "/app/sections/new",
    completionKey: "hasGeneratedSection" as const,
    actionLabel: "Create section",
    image: "/images/onboarding/generate-section.svg",
    imageAlt: "AI code generation illustration",
  },
  {
    id: "template",
    title: "Save a template for reuse",
    description:
      "Save your best prompts as templates so you can quickly generate similar sections in the future.",
    href: "/app/templates",
    completionKey: "hasSavedTemplate" as const,
    actionLabel: "View templates",
    image: "/images/onboarding/save-template.svg",
    imageAlt: "Template saving illustration",
  },
  {
    id: "history",
    title: "Check your section history",
    description:
      "View all the sections you've created, mark favorites, and quickly access previous work.",
    href: "/app/sections",
    completionKey: "hasViewedHistory" as const,
    actionLabel: "View sections",
    image: "/images/onboarding/view-history.svg",
    imageAlt: "History review illustration",
  },
];

export function SetupGuide({ onboarding }: SetupGuideProps) {
  const fetcher = useFetcher();
  const navigate = useNavigate();
  const [isExpanded, setIsExpanded] = useState(true);
  const [expandedSteps, setExpandedSteps] = useState<Record<string, boolean>>({
    generate: true, // First step expanded by default
  });

  // Don't show if dismissed
  if (onboarding.isDismissed) return null;

  // Calculate completion
  const completedCount = SETUP_STEPS.filter(
    (s) => onboarding[s.completionKey]
  ).length;
  const allComplete = completedCount === SETUP_STEPS.length;

  // Don't show if all complete
  if (allComplete) return null;

  const handleDismiss = () => {
    fetcher.submit({ intent: "dismissOnboarding" }, { method: "post" });
  };

  const toggleStep = (stepId: string) => {
    setExpandedSteps((prev) => ({
      ...prev,
      [stepId]: !prev[stepId],
    }));
  };

  return (
    <s-section>
      <s-grid gap="base">
        {/* Header */}
        <s-grid gap="small-200">
          <s-grid
            gridTemplateColumns="1fr auto auto"
            gap="small-300"
            alignItems="center"
          >
            <s-heading>Setup Guide</s-heading>
            <s-button
              accessibilityLabel="Dismiss Guide"
              onClick={handleDismiss}
              variant="tertiary"
              tone="neutral"
              icon="x"
            />
            <s-button
              accessibilityLabel="Toggle setup guide"
              onClick={() => setIsExpanded(!isExpanded)}
              variant="tertiary"
              tone="neutral"
              icon={isExpanded ? "chevron-up" : "chevron-down"}
            />
          </s-grid>
          <s-paragraph>
            Complete these steps to get the most out of AI Section Generator.
          </s-paragraph>
          <s-paragraph color="subdued">
            {completedCount} of {SETUP_STEPS.length} steps completed
          </s-paragraph>
        </s-grid>

        {/* Steps Container */}
        <s-box
          borderRadius="base"
          border="base"
          background="base"
          display={isExpanded ? "auto" : "none"}
        >
          {SETUP_STEPS.map((step, i) => {
            const completed = onboarding[step.completionKey];
            const stepExpanded = expandedSteps[step.id];

            return (
              <Fragment key={step.id}>
                <s-box>
                  {/* Step Header */}
                  <s-grid
                    gridTemplateColumns="1fr auto"
                    gap="base"
                    padding="small"
                  >
                    <s-checkbox
                      label={step.title}
                      checked={completed}
                    />
                    <s-button
                      accessibilityLabel={`Toggle ${step.title} details`}
                      onClick={() => toggleStep(step.id)}
                      variant="tertiary"
                      icon={stepExpanded ? "chevron-up" : "chevron-down"}
                    />
                  </s-grid>

                  {/* Step Details (Expandable) */}
                  <s-box
                    padding="small"
                    paddingBlockStart="none"
                    display={stepExpanded ? "auto" : "none"}
                  >
                    <s-box padding="base" background="subdued" borderRadius="base">
                      <s-grid
                        gridTemplateColumns="1fr auto"
                        gap="base"
                        alignItems="center"
                      >
                        <s-grid gap="small-200">
                          <s-paragraph>{step.description}</s-paragraph>
                          <s-stack direction="inline" gap="small-200">
                            <s-button
                              variant="primary"
                              onClick={() => navigate(step.href)}
                            >
                              {step.actionLabel}
                            </s-button>
                          </s-stack>
                        </s-grid>
                        <s-box minInlineSize="100px" maxInlineSize="100px">
                          <s-image
                            src={step.image}
                            alt={step.imageAlt}
                          />
                        </s-box>
                      </s-grid>
                    </s-box>
                  </s-box>
                </s-box>

                {/* Divider between steps */}
                {i < SETUP_STEPS.length - 1 && <s-divider />}
              </Fragment>
            );
          })}
        </s-box>
      </s-grid>
    </s-section>
  );
}
</file>

<file path="app/components/preview/drops/base/ShopifyDrop.ts">
import { Drop } from 'liquidjs';

/**
 * Base class for all Shopify drop classes
 * Extends LiquidJS Drop to provide property access control for Liquid templates
 */
export abstract class ShopifyDrop extends Drop {
  /**
   * Safely get property value with optional default
   */
  protected safeGet<T>(obj: Record<string, unknown> | undefined | null, key: string, defaultValue?: T): T | undefined {
    if (!obj) return defaultValue;
    const value = obj[key];
    return (value !== undefined && value !== null ? value : defaultValue) as T | undefined;
  }

  /**
   * Check if property exists and is not null/undefined
   */
  protected hasProperty(obj: Record<string, unknown> | undefined | null, key: string): boolean {
    if (!obj) return false;
    return obj[key] !== undefined && obj[key] !== null;
  }

  /**
   * Default implementation of liquidMethodMissing
   * Override in subclasses for custom behavior
   */
  liquidMethodMissing(_key: string): unknown {
    return undefined;
  }
}
</file>

<file path="app/components/preview/drops/CollectionDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import { ProductDrop } from './ProductDrop';
import { ImageDrop } from './ImageDrop';
import type { MockCollection } from '../mockData/types';

/**
 * Drop class for collection objects
 * Provides Liquid-compatible access to collection properties
 */
export class CollectionDrop extends ShopifyDrop {
  private collection: MockCollection;
  private _products: ProductDrop[] | null = null;

  constructor(collection: MockCollection) {
    super();
    this.collection = collection;
  }

  get id(): number {
    return this.collection.id;
  }

  get title(): string {
    return this.collection.title;
  }

  get handle(): string {
    return this.collection.handle;
  }

  get description(): string {
    return this.collection.description;
  }

  get url(): string {
    return this.collection.url;
  }

  get products_count(): number {
    return this.collection.products_count;
  }

  get image(): ImageDrop | null {
    return this.collection.image
      ? new ImageDrop(this.collection.image)
      : null;
  }

  get products(): ProductDrop[] {
    if (!this._products) {
      this._products = this.collection.products.map(p => new ProductDrop(p));
    }
    return this._products;
  }

  /**
   * Get all unique tags from products in this collection
   */
  get all_tags(): string[] {
    const tagSet = new Set<string>();
    this.collection.products.forEach(p => {
      p.tags.forEach(t => tagSet.add(t));
    });
    return Array.from(tagSet).sort();
  }

  /**
   * Get all unique product types
   */
  get all_types(): string[] {
    const typeSet = new Set<string>();
    this.collection.products.forEach(p => {
      if (p.type) typeSet.add(p.type);
    });
    return Array.from(typeSet).sort();
  }

  /**
   * Get all unique vendors
   */
  get all_vendors(): string[] {
    const vendorSet = new Set<string>();
    this.collection.products.forEach(p => {
      if (p.vendor) vendorSet.add(p.vendor);
    });
    return Array.from(vendorSet).sort();
  }

  /**
   * Default sort order
   */
  get default_sort_by(): string {
    return 'best-selling';
  }

  /**
   * Current sort option
   */
  get sort_by(): string {
    return this.default_sort_by;
  }

  /**
   * Available sort options
   */
  get sort_options(): Array<{ name: string; value: string }> {
    return [
      { name: 'Best Selling', value: 'best-selling' },
      { name: 'Alphabetically, A-Z', value: 'title-ascending' },
      { name: 'Alphabetically, Z-A', value: 'title-descending' },
      { name: 'Price, low to high', value: 'price-ascending' },
      { name: 'Price, high to low', value: 'price-descending' },
      { name: 'Date, old to new', value: 'created-ascending' },
      { name: 'Date, new to old', value: 'created-descending' }
    ];
  }

  // Phase 2: Missing properties

  /** Featured image - alias for image */
  get featured_image(): ImageDrop | null {
    return this.image;
  }

  /** Current vendor filter */
  get current_vendor(): string { return ''; }

  /** Current type filter */
  get current_type(): string { return ''; }

  /** Collection filters - placeholder */
  get filters(): unknown[] { return []; }

  /** Template suffix */
  get template_suffix(): string { return ''; }

  /** Metafields object - placeholder for custom data */
  get metafields(): Record<string, unknown> {
    return {};
  }

  /** Publication date */
  get published_at(): string {
    return new Date().toISOString();
  }

  liquidMethodMissing(key: string): unknown {
    const data = this.collection as unknown as Record<string, unknown>;
    return data[key];
  }
}
</file>

<file path="app/components/preview/drops/ImageDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { MockImage } from '../mockData/types';

/**
 * Drop class for image objects
 * Provides Liquid-compatible access to image properties
 */
export class ImageDrop extends ShopifyDrop {
  private image: MockImage;

  constructor(image: MockImage) {
    super();
    this.image = image;
  }

  get src(): string {
    return this.image.src;
  }

  get url(): string {
    return this.image.src;
  }

  get alt(): string {
    return this.image.alt;
  }

  get width(): number {
    return this.image.width;
  }

  get height(): number {
    return this.image.height;
  }

  /**
   * Get image URL with size modifier (simplified implementation)
   * In Shopify, this would resize the image
   */
  img_url(_size?: string): string {
    // In real Shopify, size could be "100x100", "medium", "large", etc.
    // For preview, we just return the original URL
    return this.image.src;
  }

  /**
   * Get aspect ratio
   */
  get aspect_ratio(): number {
    return this.image.width / this.image.height;
  }

  liquidMethodMissing(propertyName: string): unknown {
    const data = this.image as unknown as Record<string, unknown>;
    return data[propertyName];
  }
}
</file>

<file path="app/components/preview/drops/ProductDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import { VariantDrop } from './VariantDrop';
import { ImageDrop } from './ImageDrop';
import type { MockProduct } from '../mockData/types';

/**
 * Drop class for product objects
 * Provides Liquid-compatible access to product properties
 */
export class ProductDrop extends ShopifyDrop {
  private product: MockProduct;
  private _variants: VariantDrop[] | null = null;
  private _images: ImageDrop[] | null = null;

  constructor(product: MockProduct) {
    super();
    this.product = product;
  }

  // Basic properties
  get id(): number {
    return this.product.id;
  }

  get title(): string {
    return this.product.title;
  }

  get handle(): string {
    return this.product.handle;
  }

  get description(): string {
    return this.product.description;
  }

  get vendor(): string {
    return this.product.vendor;
  }

  get type(): string {
    return this.product.type;
  }

  get url(): string {
    return this.product.url;
  }

  // Price properties (in cents for Shopify convention)
  get price(): number {
    return this.product.price;
  }

  get price_min(): number {
    return this.product.price_min;
  }

  get price_max(): number {
    return this.product.price_max;
  }

  get compare_at_price(): number | null {
    return this.product.compare_at_price;
  }

  get compare_at_price_min(): number | null {
    return this.product.compare_at_price;
  }

  get compare_at_price_max(): number | null {
    return this.product.compare_at_price;
  }

  // Availability
  get available(): boolean {
    return this.product.available;
  }

  get inventory_quantity(): number {
    return this.product.inventory_quantity;
  }

  // Images
  get featured_image(): ImageDrop | null {
    return this.product.featured_image
      ? new ImageDrop(this.product.featured_image)
      : null;
  }

  get images(): ImageDrop[] {
    if (!this._images) {
      this._images = this.product.images.map(img => new ImageDrop(img));
    }
    return this._images;
  }

  get first_available_image(): ImageDrop | null {
    return this.images.length > 0 ? this.images[0] : null;
  }

  // Variants
  get variants(): VariantDrop[] {
    if (!this._variants) {
      this._variants = this.product.variants.map(v => new VariantDrop(v));
    }
    return this._variants;
  }

  get selected_variant(): VariantDrop | null {
    // Default to first available variant
    const variant = this.product.variants.find(v => v.available)
      || this.product.variants[0];
    return variant ? new VariantDrop(variant) : null;
  }

  get selected_or_first_available_variant(): VariantDrop | null {
    return this.selected_variant;
  }

  get first_available_variant(): VariantDrop | null {
    const variant = this.product.variants.find(v => v.available);
    return variant ? new VariantDrop(variant) : null;
  }

  get has_only_default_variant(): boolean {
    return this.product.variants.length === 1
      && this.product.variants[0].title === 'Default Title';
  }

  // Tags and options
  get tags(): string[] {
    return this.product.tags;
  }

  get options(): string[] {
    return this.product.options;
  }

  get options_with_values(): Array<{ name: string; values: string[] }> {
    // Build options with values from variants
    const optionsMap = new Map<string, Set<string>>();

    this.product.options.forEach(optionName => {
      optionsMap.set(optionName, new Set());
    });

    this.product.variants.forEach(variant => {
      if (variant.option1 && this.product.options[0]) {
        optionsMap.get(this.product.options[0])?.add(variant.option1);
      }
      if (variant.option2 && this.product.options[1]) {
        optionsMap.get(this.product.options[1])?.add(variant.option2);
      }
      if (variant.option3 && this.product.options[2]) {
        optionsMap.get(this.product.options[2])?.add(variant.option3);
      }
    });

    return Array.from(optionsMap.entries()).map(([name, valuesSet]) => ({
      name,
      values: Array.from(valuesSet)
    }));
  }

  // Liquid helper properties
  get on_sale(): boolean {
    return this.product.compare_at_price !== null
      && this.product.compare_at_price > this.product.price;
  }

  get price_varies(): boolean {
    return this.product.price_min !== this.product.price_max;
  }

  get compare_at_price_varies(): boolean {
    // Simplified: we only have min compare price
    return false;
  }

  // Content accessor for description
  get content(): string {
    return this.product.description;
  }

  // Phase 2: Missing properties

  /** Metafields object - placeholder for custom data */
  get metafields(): Record<string, unknown> {
    return {};
  }

  /** Media array - includes images */
  get media(): ImageDrop[] {
    return this.images;
  }

  /** Featured media - same as featured image */
  get featured_media(): ImageDrop | null {
    return this.featured_image;
  }

  /** Whether product is a gift card */
  get gift_card(): boolean { return false; }
  get 'gift_card?'(): boolean { return false; }

  /** Publication date */
  get published_at(): string {
    return new Date().toISOString();
  }

  /** Creation date */
  get created_at(): string {
    return new Date().toISOString();
  }

  /** Whether product requires a selling plan */
  get requires_selling_plan(): boolean { return false; }

  /** Selling plan groups */
  get selling_plan_groups(): unknown[] { return []; }

  /** Whether product has quantity price breaks */
  get quantity_price_breaks_configured(): boolean { return false; }
  get 'quantity_price_breaks_configured?'(): boolean { return false; }

  /** Template suffix */
  get template_suffix(): string { return ''; }

  // Dynamic property access
  liquidMethodMissing(key: string): unknown {
    const data = this.product as unknown as Record<string, unknown>;
    return data[key];
  }
}
</file>

<file path="app/components/preview/drops/ShopDrop.ts">
import { ShopifyDrop } from './base/ShopifyDrop';
import type { MockShop } from '../mockData/types';

/**
 * Drop class for shop objects
 * Provides Liquid-compatible access to shop properties
 */
export class ShopDrop extends ShopifyDrop {
  private shop: MockShop;

  constructor(shop: MockShop) {
    super();
    this.shop = shop;
  }

  get name(): string {
    return this.shop.name;
  }

  get email(): string {
    return this.shop.email;
  }

  get domain(): string {
    return this.shop.domain;
  }

  get url(): string {
    return this.shop.url;
  }

  get secure_url(): string {
    return this.shop.url.startsWith('https://') ? this.shop.url : `https://${this.shop.url}`;
  }

  get currency(): string {
    return this.shop.currency;
  }

  get money_format(): string {
    return this.shop.money_format;
  }

  get money_with_currency_format(): string {
    return `${this.shop.money_format} ${this.shop.currency}`;
  }

  get description(): string {
    return this.shop.description;
  }

  /**
   * Whether prices include taxes
   */
  get taxes_included(): boolean {
    return false;
  }

  /**
   * Whether customer accounts are enabled
   */
  get customer_accounts_enabled(): boolean {
    return true;
  }

  /**
   * Whether customer accounts are optional
   */
  get customer_accounts_optional(): boolean {
    return true;
  }

  /**
   * Shop address (placeholder)
   */
  get address(): {
    address1: string;
    address2: string;
    city: string;
    province: string;
    country: string;
    zip: string;
  } {
    return {
      address1: '',
      address2: '',
      city: '',
      province: '',
      country: '',
      zip: ''
    };
  }

  /**
   * Shop phone (placeholder)
   */
  get phone(): string {
    return '';
  }

  /**
   * Enabled payment types (placeholder)
   */
  get enabled_payment_types(): string[] {
    return ['visa', 'mastercard', 'american_express', 'paypal'];
  }

  /**
   * Shop locale
   */
  get locale(): string {
    return 'en';
  }

  // Phase 2: Missing properties

  /** Shop brand (placeholder) */
  get brand(): { logo: null; colors: Record<string, unknown>; short_description: string } {
    return {
      logo: null,
      colors: {},
      short_description: this.shop.description
    };
  }

  /** Metafields object - placeholder for custom data */
  get metafields(): Record<string, unknown> {
    return {};
  }

  /** Shop policies */
  get policies(): Array<{ title: string; body: string; url: string }> {
    return [];
  }

  /** Refund policy */
  get refund_policy(): { title: string; body: string; url: string } | null {
    return null;
  }

  /** Privacy policy */
  get privacy_policy(): { title: string; body: string; url: string } | null {
    return null;
  }

  /** Shipping policy */
  get shipping_policy(): { title: string; body: string; url: string } | null {
    return null;
  }

  /** Terms of service */
  get terms_of_service(): { title: string; body: string; url: string } | null {
    return null;
  }

  /** Subscription policy */
  get subscription_policy(): { title: string; body: string; url: string } | null {
    return null;
  }

  /** Published locales */
  get published_locales(): Array<{ iso_code: string; primary: boolean }> {
    return [{ iso_code: 'en', primary: true }];
  }

  /** Total products count (placeholder) */
  get products_count(): number {
    return 0;
  }

  /** Total collections count (placeholder) */
  get collections_count(): number {
    return 0;
  }

  /** Available product types */
  get types(): string[] {
    return [];
  }

  /** Available vendors */
  get vendors(): string[] {
    return [];
  }

  /** Permanent domain */
  get permanent_domain(): string {
    return this.shop.domain;
  }

  liquidMethodMissing(key: string): unknown {
    const data = this.shop as unknown as Record<string, unknown>;
    return data[key];
  }
}
</file>

<file path="app/components/preview/hooks/useResourceDetection.ts">
import { useMemo } from 'react';

/**
 * Resource needs detected from Liquid code
 */
export interface ResourceNeeds {
  needsProduct: boolean;
  needsCollection: boolean;
  needsArticle: boolean;
  needsBlog: boolean;
  needsCart: boolean;
}

/**
 * Analyze Liquid code to detect required resources
 * Looks for Liquid variable access patterns like {{ product.title }}
 */
export function useResourceDetection(liquidCode: string): ResourceNeeds {
  return useMemo(() => {
    if (!liquidCode) {
      return {
        needsProduct: false,
        needsCollection: false,
        needsArticle: false,
        needsBlog: false,
        needsCart: false
      };
    }

    // Patterns to detect resource usage in Liquid templates
    // Product patterns: {{ product.title }}, {% for variant in product.variants %}
    const productPattern = /\{\{-?\s*product\./i;
    const productForPattern = /{%\s*for\s+\w+\s+in\s+product\./i;

    // Collection patterns: {{ collection.title }}, {% for product in collection.products %}
    // Also detect: collections['handle'], collections[settings.collection], collections.all
    const collectionPattern = /\{\{-?\s*collection\./i;
    const collectionForPattern = /{%\s*for\s+\w+\s+in\s+collection\.products/i;
    const collectionsAccessPattern = /collections\[/i;
    const collectionsPropertyPattern = /collections\.\w+/i;

    const articlePattern = /\{\{-?\s*article\./i;
    const blogPattern = /\{\{-?\s*blog\./i;
    const cartPattern = /\{\{-?\s*cart\./i;

    // Detect if template iterates over products (common pattern in product grids)
    const productLoopPattern = /{%\s*for\s+product\s+in\s+/i;

    return {
      needsProduct: productPattern.test(liquidCode) || productForPattern.test(liquidCode) || productLoopPattern.test(liquidCode),
      needsCollection: collectionPattern.test(liquidCode) || collectionForPattern.test(liquidCode) || collectionsAccessPattern.test(liquidCode) || collectionsPropertyPattern.test(liquidCode),
      needsArticle: articlePattern.test(liquidCode),
      needsBlog: blogPattern.test(liquidCode),
      needsCart: cartPattern.test(liquidCode)
    };
  }, [liquidCode]);
}

/**
 * Get a human-readable summary of detected resources
 */
export function getResourceSummary(needs: ResourceNeeds): string {
  const resources: string[] = [];

  if (needs.needsProduct) resources.push('Product');
  if (needs.needsCollection) resources.push('Collection');
  if (needs.needsArticle) resources.push('Article');
  if (needs.needsBlog) resources.push('Blog');
  if (needs.needsCart) resources.push('Cart');

  if (resources.length === 0) {
    return 'No specific resources detected';
  }

  return `Detected: ${resources.join(', ')}`;
}
</file>

<file path="app/components/preview/mockData/index.ts">
export * from './types';
</file>

<file path="app/components/preview/settings/CheckboxSetting.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface CheckboxSettingProps {
  setting: SchemaSetting;
  value: boolean;
  onChange: (value: boolean) => void;
  disabled?: boolean;
}

/**
 * CheckboxSetting - Renders boolean toggle using Polaris Web Components
 */
export function CheckboxSetting({ setting, value, onChange, disabled }: CheckboxSettingProps) {
  // Use native Event type for Polaris Web Components
  const handleChange = (e: Event) => {
    const target = e.currentTarget as HTMLInputElement;
    onChange(target.checked);
  };

  return (
    <s-checkbox
      label={setting.label}
      checked={value || undefined}
      disabled={disabled || undefined}
      details={setting.info}
      onChange={handleChange}
    />
  );
}
</file>

<file path="app/components/preview/settings/CollectionListSetting.tsx">
/**
 * CollectionListSetting Component
 * Renders multi-select resource picker for collection_list type
 * Supports limit configuration (max 50, default 50)
 */

import type { SchemaSetting } from '../schema/SchemaTypes';
import { ResourceSelector, type SelectedResource } from '../ResourceSelector';

export interface CollectionListSettingProps {
  setting: SchemaSetting;
  value: string; // JSON stringified array of IDs
  onChange: (id: string, value: string) => void;
  disabled?: boolean;
  selectedResources?: SelectedResource[];
  onResourcesSelect?: (settingId: string, resources: SelectedResource[]) => void;
  loading?: boolean;
}

export function CollectionListSetting({
  setting,
  value: _value,
  onChange,
  disabled,
  selectedResources = [],
  onResourcesSelect,
  loading
}: CollectionListSettingProps) {
  const limit = setting.limit ?? 50;

  const handleSelectMultiple = (resources: SelectedResource[]) => {
    // Enforce limit
    const limitedResources = resources.slice(0, limit);

    // Update settings value with JSON array of IDs
    const ids = limitedResources.map(r => r.id);
    onChange(setting.id, JSON.stringify(ids));

    // Notify parent about full resource selection
    onResourcesSelect?.(setting.id, limitedResources);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <span style={{ fontWeight: 500 }}>{setting.label}</span>
        <span style={{ fontSize: '12px', color: '#6d7175' }}>
          {selectedResources.length}/{limit} selected
        </span>
      </div>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <ResourceSelector
        resourceType="collection"
        multiple={true}
        onSelect={() => {}} // Required but unused for multiple
        onSelectMultiple={handleSelectMultiple}
        selectedResources={selectedResources}
        disabled={disabled || selectedResources.length >= limit}
        loading={loading}
      />

      {selectedResources.length >= limit && (
        <span style={{ fontSize: '12px', color: '#d72c0d' }}>
          Maximum {limit} collections reached
        </span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/NumberSetting.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface NumberSettingProps {
  setting: SchemaSetting;
  value: number;
  onChange: (value: number) => void;
  disabled?: boolean;
}

/**
 * NumberSetting - Renders number inputs using Polaris Web Components
 * Supports: number (input field), range (styled slider)
 */
export function NumberSetting({ setting, value, onChange, disabled }: NumberSettingProps) {
  const isRange = setting.type === 'range';

  // Use native Event type for Polaris Web Components
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(parseFloat(target.value) || 0);
  };

  if (isRange) {
    const minVal = setting.min ?? 0;
    const maxVal = setting.max ?? 100;
    const percentage = ((value - minVal) / (maxVal - minVal)) * 100;

    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontWeight: 500 }}>{setting.label}</span>
          <span style={{
            backgroundColor: '#f6f6f7',
            padding: '2px 8px',
            borderRadius: '4px',
            fontSize: '13px',
            fontWeight: 500
          }}>
            {value}{setting.unit || ''}
          </span>
        </div>

        {/* Styled range container */}
        <div style={{ position: 'relative', padding: '8px 0' }}>
          <input
            type="range"
            min={minVal}
            max={maxVal}
            step={setting.step ?? 1}
            value={value}
            disabled={disabled}
            onChange={(e) => onChange(parseFloat(e.target.value) || 0)}
            style={{
              width: '100%',
              height: '4px',
              borderRadius: '2px',
              background: `linear-gradient(to right, #000 0%, #000 ${percentage}%, #e1e3e5 ${percentage}%, #e1e3e5 100%)`,
              appearance: 'none',
              WebkitAppearance: 'none',
              cursor: disabled ? 'not-allowed' : 'pointer',
              opacity: disabled ? 0.5 : 1,
            }}
          />
          <style>{`
            input[type="range"]::-webkit-slider-thumb {
              -webkit-appearance: none;
              width: 16px;
              height: 16px;
              border-radius: 50%;
              background: #000;
              cursor: pointer;
              border: 2px solid #fff;
              box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }
            input[type="range"]::-moz-range-thumb {
              width: 16px;
              height: 16px;
              border-radius: 50%;
              background: #000;
              cursor: pointer;
              border: 2px solid #fff;
              box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }
            input[type="range"]:disabled::-webkit-slider-thumb {
              cursor: not-allowed;
            }
            input[type="range"]:disabled::-moz-range-thumb {
              cursor: not-allowed;
            }
          `}</style>
        </div>

        {/* Min/Max labels */}
        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', color: '#6d7175' }}>
          <span>{minVal}{setting.unit || ''}</span>
          <span>{maxVal}{setting.unit || ''}</span>
        </div>

        {setting.info && (
          <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
        )}
      </div>
    );
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <s-number-field
        label={setting.label}
        value={String(value)}
        min={setting.min}
        max={setting.max}
        step={setting.step ?? 1}
        disabled={disabled || undefined}
        onInput={handleInput}
      />
      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/ProductListSetting.tsx">
/**
 * ProductListSetting Component
 * Renders multi-select resource picker for product_list type
 * Supports limit configuration (max 50, default 50)
 */

import type { SchemaSetting } from '../schema/SchemaTypes';
import { ResourceSelector, type SelectedResource } from '../ResourceSelector';

export interface ProductListSettingProps {
  setting: SchemaSetting;
  value: string; // JSON stringified array of IDs
  onChange: (id: string, value: string) => void;
  disabled?: boolean;
  selectedResources?: SelectedResource[];
  onResourcesSelect?: (settingId: string, resources: SelectedResource[]) => void;
  loading?: boolean;
}

export function ProductListSetting({
  setting,
  value: _value,
  onChange,
  disabled,
  selectedResources = [],
  onResourcesSelect,
  loading
}: ProductListSettingProps) {
  const limit = setting.limit ?? 50;

  const handleSelectMultiple = (resources: SelectedResource[]) => {
    // Enforce limit
    const limitedResources = resources.slice(0, limit);

    // Update settings value with JSON array of IDs
    const ids = limitedResources.map(r => r.id);
    onChange(setting.id, JSON.stringify(ids));

    // Notify parent about full resource selection
    onResourcesSelect?.(setting.id, limitedResources);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <span style={{ fontWeight: 500 }}>{setting.label}</span>
        <span style={{ fontSize: '12px', color: '#6d7175' }}>
          {selectedResources.length}/{limit} selected
        </span>
      </div>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <ResourceSelector
        resourceType="product"
        multiple={true}
        onSelect={() => {}} // Required but unused for multiple
        onSelectMultiple={handleSelectMultiple}
        selectedResources={selectedResources}
        disabled={disabled || selectedResources.length >= limit}
        loading={loading}
      />

      {selectedResources.length >= limit && (
        <span style={{ fontSize: '12px', color: '#d72c0d' }}>
          Maximum {limit} products reached
        </span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/SelectSetting.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface SelectSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

/**
 * SelectSetting - Renders dropdown or segmented control based on options
 * Per Shopify: Use SegmentedControl for 5 ungrouped options, Dropdown otherwise
 */
export function SelectSetting({ setting, value, onChange, disabled }: SelectSettingProps) {
  const options = setting.options || [];

  // Check if any options have groups
  const hasGroups = options.some(opt => opt.group);

  // Use segmented control for 5 ungrouped options
  const useSegmented = options.length <= 5 && options.length > 1 && !hasGroups;

  if (useSegmented) {
    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <span style={{ fontWeight: 500 }}>{setting.label}</span>

        <div style={{
          display: 'flex',
          border: '1px solid #c9cccf',
          borderRadius: '4px',
          overflow: 'hidden',
          width: 'fit-content'
        }}>
          {options.map((opt, index) => (
            <button
              key={opt.value}
              type="button"
              onClick={() => !disabled && onChange(opt.value)}
              disabled={disabled}
              style={{
                padding: '6px 12px',
                border: 'none',
                borderRight: index < options.length - 1 ? '1px solid #c9cccf' : 'none',
                backgroundColor: value === opt.value ? '#000' : '#fff',
                color: value === opt.value ? '#fff' : '#202223',
                cursor: disabled ? 'not-allowed' : 'pointer',
                fontWeight: 500,
                fontSize: '13px',
                opacity: disabled ? 0.5 : 1,
                transition: 'background-color 0.15s, color 0.15s',
              }}
            >
              {opt.label}
            </button>
          ))}
        </div>

        {setting.info && (
          <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
        )}
      </div>
    );
  }

  // Default: dropdown select
  const handleChange = (e: Event) => {
    const target = e.target as HTMLSelectElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <s-select
        label={setting.label}
        value={value}
        disabled={disabled || undefined}
        onChange={handleChange}
      >
        {options.map((opt) => (
          <option key={opt.value} value={opt.value}>
            {opt.label}
          </option>
        ))}
      </s-select>
      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/TextSetting.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface TextSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

/**
 * TextSetting - Renders text inputs using Polaris Web Components
 * Supports: text, textarea, richtext, url, html types
 */
export function TextSetting({ setting, value, onChange, disabled }: TextSettingProps) {
  const isMultiline = setting.type === 'textarea' || setting.type === 'richtext' || setting.type === 'html';

  // Use native Event type for Polaris Web Components
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement | HTMLTextAreaElement;
    onChange(target.value);
  };

  if (isMultiline) {
    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <s-text-area
          label={setting.label}
          value={value}
          placeholder={setting.placeholder}
          disabled={disabled || undefined}
          rows={4}
          onInput={handleInput}
        />
        {setting.info && (
          <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
        )}
      </div>
    );
  }

  if (setting.type === 'url') {
    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <s-text-field
          label={setting.label}
          value={value}
          placeholder={setting.placeholder}
          disabled={disabled || undefined}
          onInput={handleInput}
        />
        {setting.info && (
          <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
        )}
      </div>
    );
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <s-text-field
        label={setting.label}
        value={value}
        placeholder={setting.placeholder}
        disabled={disabled || undefined}
        details={setting.info}
        onInput={handleInput}
      />
    </div>
  );
}
</file>

<file path="app/components/preview/ResourceSelector.tsx">
/**
 * Resource Selector Component
 * Uses Shopify App Bridge ResourcePicker for selecting products, collections, articles
 */

import { useState, useCallback } from 'react';
import { useAppBridge } from '@shopify/app-bridge-react';
import { SelectedResourceDisplay } from './SelectedResourceDisplay';

export type ResourceType = 'product' | 'collection' | 'variant';

export interface SelectedResource {
  id: string;
  title: string;
  image?: string;
}

interface ResourceSelectorProps {
  resourceType: ResourceType;
  onSelect: (resourceId: string | null, resource: SelectedResource | null) => void;
  onSelectMultiple?: (resources: SelectedResource[]) => void;
  selectedResource?: SelectedResource | null;
  selectedResources?: SelectedResource[];
  multiple?: boolean;
  disabled?: boolean;
  loading?: boolean;
}

/**
 * ResourceSelector - Opens App Bridge ResourcePicker modal
 * Provides product/collection selection with native Shopify admin UX
 */
export function ResourceSelector({
  resourceType,
  onSelect,
  onSelectMultiple,
  selectedResource,
  selectedResources = [],
  multiple = false,
  disabled,
  loading
}: ResourceSelectorProps) {
  const shopify = useAppBridge();
  const [isOpening, setIsOpening] = useState(false);

  const resourceTypeLabel = {
    product: 'Product',
    collection: 'Collection',
    variant: 'Variant'
  }[resourceType];

  const pluralLabel = {
    product: 'Products',
    collection: 'Collections',
    variant: 'Variants'
  }[resourceType];

  const handleOpenPicker = useCallback(async () => {
    if (disabled || loading || isOpening) return;

    setIsOpening(true);
    try {
      // Use App Bridge resourcePicker API
      const selected = await shopify.resourcePicker({
        type: resourceType,
        multiple: multiple,
        action: 'select'
      });

      if (selected && selected.length > 0) {
        if (multiple && onSelectMultiple) {
          // Handle multiple selection
          const resources: SelectedResource[] = selected.map((resource) => {
            let imageUrl: string | undefined;
            if ('images' in resource && Array.isArray(resource.images) && resource.images.length > 0) {
              const firstImage = resource.images[0] as { originalSrc?: string; src?: string; url?: string };
              imageUrl = firstImage.originalSrc || firstImage.src || firstImage.url;
            } else if ('image' in resource && resource.image) {
              const img = resource.image as { originalSrc?: string; src?: string; url?: string };
              imageUrl = img.originalSrc || img.src || img.url;
            }
            return {
              id: resource.id,
              title: resource.title || 'Untitled',
              image: imageUrl
            };
          });
          onSelectMultiple(resources);
        } else {
          // Handle single selection
          const resource = selected[0];
          let imageUrl: string | undefined;
          if ('images' in resource && Array.isArray(resource.images) && resource.images.length > 0) {
            const firstImage = resource.images[0] as { originalSrc?: string; src?: string; url?: string };
            imageUrl = firstImage.originalSrc || firstImage.src || firstImage.url;
          } else if ('image' in resource && resource.image) {
            const img = resource.image as { originalSrc?: string; src?: string; url?: string };
            imageUrl = img.originalSrc || img.src || img.url;
          }

          const selectedResource: SelectedResource = {
            id: resource.id,
            title: resource.title || 'Untitled',
            image: imageUrl
          };

          onSelect(resource.id, selectedResource);
        }
      }
    } catch (error) {
      // User cancelled the picker - this is expected behavior
      if ((error as Error)?.message?.includes('cancel')) {
        return;
      }
      console.error('ResourcePicker error:', error);
    } finally {
      setIsOpening(false);
    }
  }, [shopify, resourceType, multiple, disabled, loading, isOpening, onSelect, onSelectMultiple]);

  const handleClear = useCallback(() => {
    if (multiple && onSelectMultiple) {
      onSelectMultiple([]);
    } else {
      onSelect(null, null);
    }
  }, [multiple, onSelect, onSelectMultiple]);

  // Determine display state
  const hasSelection = multiple ? selectedResources.length > 0 : !!selectedResource;
  const selectionCount = multiple ? selectedResources.length : (selectedResource ? 1 : 0);
  const buttonLabel = hasSelection
    ? (multiple ? `Change ${pluralLabel} (${selectionCount})` : `Change ${resourceTypeLabel}`)
    : (multiple ? `Select ${pluralLabel}` : `Select ${resourceTypeLabel}`);

  return (
    <s-stack gap="small" direction="inline">
      {/* Select/Change button */}
      <s-button
        variant="secondary"
        onClick={handleOpenPicker}
        disabled={disabled || loading || isOpening || undefined}
        loading={isOpening || loading || undefined}
      >
        {buttonLabel}
      </s-button>

      {/* Selected resource display (single) */}
      {!multiple && selectedResource && (
        <SelectedResourceDisplay
          title={selectedResource.title}
          image={selectedResource.image}
          onClear={handleClear}
          disabled={disabled || loading}
        />
      )}

      {/* Selected resources display (multiple) */}
      {multiple && selectedResources.length > 0 && (
        <div style={{ display: 'flex', gap: '4px', alignItems: 'center', flexWrap: 'wrap' }}>
          {selectedResources.slice(0, 3).map((res) => (
            <span key={res.id} style={{
              padding: '2px 8px',
              backgroundColor: '#e4e5e7',
              borderRadius: '4px',
              fontSize: '12px'
            }}>
              {res.title}
            </span>
          ))}
          {selectedResources.length > 3 && (
            <span style={{ fontSize: '12px', color: '#6d7175' }}>
              +{selectedResources.length - 3} more
            </span>
          )}
          <s-button
            variant="tertiary"
            onClick={handleClear}
            disabled={disabled || loading || undefined}
          >
            Clear
          </s-button>
        </div>
      )}
    </s-stack>
  );
}
</file>

<file path="app/components/sections/index.ts">
/**
 * Sections feature component exports
 */
export { HistoryTable } from './HistoryTable';
export { HistoryPreviewModal } from './HistoryPreviewModal';
export { SectionsEmptyState } from './SectionsEmptyState';
export { DeleteConfirmModal } from './DeleteConfirmModal';

export type { HistoryTableProps } from './HistoryTable';
export type { HistoryPreviewModalProps } from './HistoryPreviewModal';
</file>

<file path="app/components/shared/Card.tsx">
import type { ReactNode } from 'react';

export interface CardProps {
  title?: string;
  children: ReactNode;
  sectioned?: boolean;
}

/**
 * Wrapper for Polaris s-section web component
 * Provides consistent card layout and styling
 */
export function Card({ title, children }: CardProps) {
  return (
    <s-section heading={title}>
      {children}
    </s-section>
  );
}
</file>

<file path="app/components/shared/FilterButtonGroup.tsx">
interface FilterOption {
  value: string;
  label: string;
}

interface FilterButtonGroupProps {
  options: FilterOption[];
  value: string;
  onChange: (value: string) => void;
}

/**
 * Scrollable filter button group using Polaris button-group pattern
 * Handles overflow for many categories
 */
export function FilterButtonGroup({ options, value, onChange }: FilterButtonGroupProps) {
  return (
    <div
      style={{
        overflowX: 'auto',
        WebkitOverflowScrolling: 'touch',
        paddingBottom: '4px', // Space for scrollbar
      }}
    >
      <s-button-group gap="base">
        {options.map((opt) => (
          <s-button
            key={opt.value}
            variant={value === opt.value ? "primary" : "secondary"}
            onClick={() => onChange(opt.value)}
          >
            {opt.label}
          </s-button>
        ))}
      </s-button-group>
    </div>
  );
}
</file>

<file path="app/components/templates/index.ts">
export { TemplateGrid } from "./TemplateGrid";
export { TemplateCard } from "./TemplateCard";
export { TemplateEditorModal } from "./TemplateEditorModal";

export type { TemplateGridProps } from "./TemplateGrid";
export type { TemplateCardProps } from "./TemplateCard";
export type { TemplateEditorModalProps } from "./TemplateEditorModal";
</file>

<file path="app/components/index.ts">
/**
 * Barrel export file for all UI components
 * Provides centralized imports for shared and feature-specific components
 */

// Shared components
export { Button } from './shared/Button';
export { Card } from './shared/Card';
export { Banner, SuccessBanner, ErrorBanner } from './shared/Banner';

// Generate feature components - Layout
export { GenerateLayout } from './generate/GenerateLayout';
export { GenerateInputColumn } from './generate/GenerateInputColumn';
export { GeneratePreviewColumn } from './generate/GeneratePreviewColumn';

// Generate feature components - Individual
export { PromptInput } from './generate/PromptInput';
export { ThemeSelector } from './generate/ThemeSelector';
export { CodePreview } from './generate/CodePreview';
export { SectionNameInput } from './generate/SectionNameInput';
export { GenerateActions } from './generate/GenerateActions';
export { TemplateSuggestions } from './generate/TemplateSuggestions';
export { PromptExamples } from './generate/PromptExamples';
export { AdvancedOptions } from './generate/AdvancedOptions';
export { LoadingState } from './generate/LoadingState';
export { EmptyState } from './generate/EmptyState';

// Types
export type { ButtonProps } from './shared/Button';
export type { CardProps } from './shared/Card';
export type { BannerProps } from './shared/Banner';
export type { GenerateLayoutProps } from './generate/GenerateLayout';
export type { GenerateInputColumnProps } from './generate/GenerateInputColumn';
export type { GeneratePreviewColumnProps } from './generate/GeneratePreviewColumn';
export type { PromptInputProps } from './generate/PromptInput';
export type { ThemeSelectorProps } from './generate/ThemeSelector';
export type { CodePreviewProps } from './generate/CodePreview';
export type { SectionNameInputProps } from './generate/SectionNameInput';
export type { GenerateActionsProps } from './generate/GenerateActions';
export type { TemplateSuggestionsProps } from './generate/TemplateSuggestions';
export type { PromptExamplesProps } from './generate/PromptExamples';
export type { AdvancedOptionsProps, AdvancedOptionsState } from './generate/AdvancedOptions';
export type { LoadingStateProps } from './generate/LoadingState';
export type { EmptyStateProps } from './generate/EmptyState';
</file>

<file path="app/routes/auth.login/route.tsx">
import { AppProvider } from "@shopify/shopify-app-react-router/react";
import { useState } from "react";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import { Form, useActionData, useLoaderData } from "react-router";

import { login } from "../../shopify.server";
import { loginErrorMessage } from "./error.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const errors = loginErrorMessage(await login(request));

  return { errors };
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const errors = loginErrorMessage(await login(request));

  return {
    errors,
  };
};

export default function Auth() {
  const loaderData = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const [shop, setShop] = useState("");
  const { errors } = actionData || loaderData;

  const handleShopChange = (e: Event) => {
    const target = e.currentTarget as HTMLInputElement;
    setShop(target.value);
  };

  return (
    <AppProvider embedded={false}>
      <s-page>
        <Form method="post">
        <s-section heading="Log in">
          <s-text-field
            name="shop"
            label="Shop domain"
            details="example.myshopify.com"
            value={shop}
            onChange={handleShopChange}
            autocomplete="on"
            error={errors.shop}
          ></s-text-field>
          <s-button type="submit">Log in</s-button>
        </s-section>
        </Form>
      </s-page>
    </AppProvider>
  );
}
</file>

<file path="app/routes/webhooks.app.subscriptions_update.tsx">
/**
 * Webhook handler for APP_SUBSCRIPTIONS_UPDATE
 *
 * Triggered when subscription status changes (activated, cancelled, expired, etc.)
 */

import type { ActionFunctionArgs } from "react-router";
import { authenticate } from "../shopify.server";
import { updateSubscriptionStatus } from "../services/billing.server";
import type { SubscriptionUpdateWebhook, SubscriptionStatus } from "../types/billing";

export const action = async ({ request }: ActionFunctionArgs) => {
  // Declare variables outside try block for error logging access
  let shop: string | undefined;
  let app_subscription: SubscriptionUpdateWebhook["app_subscription"] | undefined;

  try {
    // authenticate.webhook() validates HMAC signature automatically
    const { topic, shop: webhookShop, admin, payload } = await authenticate.webhook(request);
    shop = webhookShop;

    // Validate topic
    if (topic !== "APP_SUBSCRIPTIONS_UPDATE") {
      console.error("[Webhook] Invalid topic:", topic);
      return new Response("Invalid webhook topic", { status: 400 });
    }

    const webhookPayload = payload as SubscriptionUpdateWebhook;
    app_subscription = webhookPayload.app_subscription;

    // Validate payload structure
    if (!app_subscription || !app_subscription.admin_graphql_api_id) {
      console.error("[Webhook] Invalid payload structure");
      return new Response("Invalid payload", { status: 400 });
    }

    console.log(`[Webhook] APP_SUBSCRIPTIONS_UPDATE for ${shop}:`, {
      subscriptionId: app_subscription.admin_graphql_api_id,
      status: app_subscription.status,
      currentPeriodEnd: app_subscription.current_period_end,
    });

    // Import billing service for GraphQL fallback
    const { fetchCurrentPeriodEnd } = await import("../services/billing.server");

    // Verify shop matches subscription (fetch from DB first)
    const prisma = (await import("../db.server")).default;
    const subscription = await prisma.subscription.findUnique({
      where: { shopifySubId: app_subscription.admin_graphql_api_id }
    });

    if (!subscription) {
      // Could be new subscription approval webhook
      console.log("[Webhook] Subscription not found in DB, checking for pending...");

      if (app_subscription.status.toLowerCase() === "active") {
        // Find most recent pending subscription for this shop
        const pendingSubscription = await prisma.subscription.findFirst({
          where: {
            shop,
            status: "pending",
          },
          orderBy: { createdAt: "desc" }
        });

        if (pendingSubscription) {
          console.log("[Webhook] Found pending subscription, updating to active:", {
            oldId: pendingSubscription.shopifySubId,
            newId: app_subscription.admin_graphql_api_id,
          });

          // Fetch currentPeriodEnd for new active subscription
          let currentPeriodEnd: Date | undefined;
          if (app_subscription.current_period_end) {
            currentPeriodEnd = new Date(app_subscription.current_period_end);
          } else if (admin) {
            const fetchedDate = await fetchCurrentPeriodEnd(admin, app_subscription.admin_graphql_api_id);
            currentPeriodEnd = fetchedDate ?? undefined;
          }

          // Update pending record with actual Shopify ID
          await prisma.subscription.update({
            where: { id: pendingSubscription.id },
            data: {
              shopifySubId: app_subscription.admin_graphql_api_id,
              status: "active",
              currentPeriodEnd: currentPeriodEnd ?? pendingSubscription.currentPeriodEnd,
              usageThisCycle: 0,
              overagesThisCycle: 0,
            }
          });

          console.log("[Webhook] Successfully activated pending subscription");
          return new Response("Webhook processed", { status: 200 });
        }
      }

      console.error("[Webhook] Subscription not found:", app_subscription.admin_graphql_api_id);
      return new Response("Subscription not found", { status: 404 });
    }

    if (subscription.shop !== shop) {
      console.error("[Webhook] Shop mismatch:", {
        webhookShop: shop,
        subscriptionShop: subscription.shop
      });
      return new Response("Shop validation failed", { status: 400 });
    }

    // Handle currentPeriodEnd safely
    let currentPeriodEnd: Date | undefined;

    if (app_subscription.current_period_end) {
      // Webhook includes period end - use it
      currentPeriodEnd = new Date(app_subscription.current_period_end);
    } else if (app_subscription.status.toLowerCase() === "active" && admin) {
      // ACTIVE subscription but no period end - query Shopify
      console.log("[Webhook] Missing currentPeriodEnd, querying Shopify...");
      const fetchedDate = await fetchCurrentPeriodEnd(admin, app_subscription.admin_graphql_api_id);
      currentPeriodEnd = fetchedDate ?? undefined;
    }

    // Update subscription status in database (normalize to lowercase)
    await updateSubscriptionStatus(
      app_subscription.admin_graphql_api_id,
      app_subscription.status.toLowerCase() as SubscriptionStatus,
      currentPeriodEnd, // May be undefined - billing service handles it
    );

    // If status is active and current_period_end changed, it's a new billing cycle
    // Usage counters are automatically reset in updateSubscriptionStatus

    console.log(`[Webhook] Successfully processed for ${shop}`, {
      subscriptionId: app_subscription.admin_graphql_api_id,
      status: app_subscription.status,
      hadPeriodEnd: !!app_subscription.current_period_end,
      queriedShopify: !app_subscription.current_period_end && app_subscription.status.toLowerCase() === "active",
    });
    return new Response("Webhook processed", { status: 200 });
  } catch (error) {
    console.error("[Webhook] Error processing APP_SUBSCRIPTIONS_UPDATE:", {
      error: error instanceof Error ? error.message : error,
      shop,
      subscriptionId: app_subscription?.admin_graphql_api_id,
      status: app_subscription?.status,
    });
    return new Response("Error processing webhook", { status: 500 });
  }
};
</file>

<file path="app/services/flags/feature-flags.ts">
/**
 * Feature Flag System
 * Controls which features are enabled/disabled at runtime
 */

export type FlagValue = boolean | string | number;

export interface FeatureFlag {
  key: string;
  description: string;
  defaultValue: FlagValue;
  currentValue?: FlagValue;
}

export enum FeatureFlagKey {
  // Feature Flags
  ENABLE_SECTION_HISTORY = 'enable_section_history',
  ENABLE_TEMPLATE_LIBRARY = 'enable_template_library',
  ENABLE_AI_SETTINGS = 'enable_ai_settings',

  // Performance Flags
  CACHE_THEME_LIST = 'cache_theme_list',

  // Debug Flags
  VERBOSE_LOGGING = 'verbose_logging',
}

export const featureFlags: Record<FeatureFlagKey, FeatureFlag> = {
  [FeatureFlagKey.ENABLE_SECTION_HISTORY]: {
    key: FeatureFlagKey.ENABLE_SECTION_HISTORY,
    description: 'Enable section generation history feature',
    defaultValue: false // Not implemented yet
  },
  [FeatureFlagKey.ENABLE_TEMPLATE_LIBRARY]: {
    key: FeatureFlagKey.ENABLE_TEMPLATE_LIBRARY,
    description: 'Enable section template library',
    defaultValue: false // Not implemented yet
  },
  [FeatureFlagKey.ENABLE_AI_SETTINGS]: {
    key: FeatureFlagKey.ENABLE_AI_SETTINGS,
    description: 'Enable AI configuration settings (model, temperature)',
    defaultValue: false // Not implemented yet
  },
  [FeatureFlagKey.CACHE_THEME_LIST]: {
    key: FeatureFlagKey.CACHE_THEME_LIST,
    description: 'Cache theme list to reduce API calls',
    defaultValue: false // Future performance enhancement
  },
  [FeatureFlagKey.VERBOSE_LOGGING]: {
    key: FeatureFlagKey.VERBOSE_LOGGING,
    description: 'Enable detailed service logging',
    defaultValue: process.env.NODE_ENV !== 'production'
  }
};
</file>

<file path="app/services/shopify-data.server.ts">
import { authenticate } from "../shopify.server";
import type {
  MockProduct,
  MockProductVariant,
  MockCollection,
  MockArticle,
  MockShop,
  MockImage
} from "../components/preview/mockData/types";

/**
 * Cache entry with TTL support
 */
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

/**
 * Simple in-memory cache with TTL
 */
class SimpleCache {
  private cache = new Map<string, CacheEntry<unknown>>();

  set<T>(key: string, data: T, ttl: number): void {
    this.cache.set(key, { data, timestamp: Date.now(), ttl });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const age = Date.now() - entry.timestamp;
    if (age > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  clear(): void {
    this.cache.clear();
  }

  delete(key: string): void {
    this.cache.delete(key);
  }
}

// GraphQL Queries
const PRODUCT_QUERY = `#graphql
  query GetProduct($id: ID!) {
    product(id: $id) {
      id
      title
      handle
      description
      vendor
      productType
      priceRange {
        minVariantPrice { amount currencyCode }
        maxVariantPrice { amount currencyCode }
      }
      compareAtPriceRange {
        minVariantCompareAtPrice { amount }
      }
      totalInventory
      featuredImage {
        url
        altText
        width
        height
      }
      images(first: 10) {
        edges {
          node {
            url
            altText
            width
            height
          }
        }
      }
      tags
      options { name values }
      variants(first: 100) {
        edges {
          node {
            id
            title
            price
            compareAtPrice
            availableForSale
            inventoryQuantity
            sku
            selectedOptions { name value }
          }
        }
      }
    }
  }
`;

const COLLECTION_QUERY = `#graphql
  query GetCollection($id: ID!) {
    collection(id: $id) {
      id
      title
      handle
      description
      image {
        url
        altText
        width
        height
      }
      productsCount {
        count
      }
      products(first: 20) {
        edges {
          node {
            id
            title
            handle
            description
            vendor
            productType
            priceRange {
              minVariantPrice { amount }
              maxVariantPrice { amount }
            }
            compareAtPriceRange {
              minVariantCompareAtPrice { amount }
            }
            totalInventory
            featuredImage {
              url
              altText
              width
              height
            }
            images(first: 5) {
              edges {
                node {
                  url
                  altText
                  width
                  height
                }
              }
            }
            tags
            options { name values }
            variants(first: 10) {
              edges {
                node {
                  id
                  title
                  price
                  compareAtPrice
                  availableForSale
                  inventoryQuantity
                  sku
                  selectedOptions { name value }
                }
              }
            }
          }
        }
      }
    }
  }
`;

const ARTICLE_QUERY = `#graphql
  query GetArticle($id: ID!) {
    article(id: $id) {
      id
      title
      handle
      body
      summary
      author {
        name
      }
      publishedAt
      image {
        url
        altText
        width
        height
      }
      tags
      blog {
        id
        title
        handle
      }
    }
  }
`;

const SHOP_QUERY = `#graphql
  query GetShop {
    shop {
      name
      email
      primaryDomain {
        host
        url
      }
      currencyCode
      description
    }
  }
`;

// Response type helpers
interface GraphQLProductResponse {
  data?: {
    product?: {
      id: string;
      title: string;
      handle: string;
      description: string;
      vendor: string;
      productType: string;
      priceRange: {
        minVariantPrice: { amount: string; currencyCode: string };
        maxVariantPrice: { amount: string; currencyCode: string };
      };
      compareAtPriceRange?: {
        minVariantCompareAtPrice?: { amount: string };
      };
      totalInventory: number;
      featuredImage?: {
        url: string;
        altText?: string;
        width: number;
        height: number;
      };
      images: {
        edges: Array<{
          node: {
            url: string;
            altText?: string;
            width: number;
            height: number;
          };
        }>;
      };
      tags: string[];
      options: Array<{ name: string; values: string[] }>;
      variants: {
        edges: Array<{
          node: {
            id: string;
            title: string;
            price: string;
            compareAtPrice?: string;
            availableForSale: boolean;
            inventoryQuantity?: number;
            sku?: string;
            selectedOptions: Array<{ name: string; value: string }>;
          };
        }>;
      };
    };
  };
}

interface GraphQLCollectionResponse {
  data?: {
    collection?: {
      id: string;
      title: string;
      handle: string;
      description: string;
      image?: {
        url: string;
        altText?: string;
        width: number;
        height: number;
      };
      productsCount: { count: number };
      products: {
        edges: Array<{
          node: NonNullable<NonNullable<GraphQLProductResponse['data']>['product']>;
        }>;
      };
    };
  };
}

interface GraphQLArticleResponse {
  data?: {
    article?: {
      id: string;
      title: string;
      handle: string;
      body: string;
      summary?: string;
      author?: { name: string };
      publishedAt: string;
      image?: {
        url: string;
        altText?: string;
        width: number;
        height: number;
      };
      tags: string[];
      blog?: {
        id: string;
        title: string;
        handle: string;
      };
    };
  };
}

interface GraphQLShopResponse {
  data?: {
    shop?: {
      name: string;
      email: string;
      primaryDomain: {
        host: string;
        url: string;
      };
      currencyCode: string;
      description?: string;
    };
  };
}

// Transform functions
function transformImage(graphqlImage: { url: string; altText?: string; width: number; height: number } | undefined | null): MockImage {
  if (!graphqlImage) {
    return {
      src: 'https://cdn.shopify.com/s/files/1/0533/2089/files/placeholder-images-image_large.png',
      alt: 'Placeholder image',
      width: 600,
      height: 600
    };
  }
  return {
    src: graphqlImage.url,
    alt: graphqlImage.altText || '',
    width: graphqlImage.width || 600,
    height: graphqlImage.height || 600
  };
}

function extractNumericId(gid: string): number {
  const parts = gid.split('/');
  return parseInt(parts[parts.length - 1], 10) || 0;
}

function transformVariant(graphqlVariant: NonNullable<NonNullable<GraphQLProductResponse['data']>['product']>['variants']['edges'][0]['node']): MockProductVariant {
  const options = graphqlVariant.selectedOptions || [];
  return {
    id: extractNumericId(graphqlVariant.id),
    title: graphqlVariant.title,
    price: Math.round(parseFloat(graphqlVariant.price) * 100),
    available: graphqlVariant.availableForSale,
    inventory_quantity: graphqlVariant.inventoryQuantity || 0,
    sku: graphqlVariant.sku || '',
    option1: options[0]?.value || null,
    option2: options[1]?.value || null,
    option3: options[2]?.value || null
  };
}

function transformProduct(graphqlProduct: NonNullable<GraphQLProductResponse['data']>['product']): MockProduct | null {
  if (!graphqlProduct) return null;

  const priceMin = Math.round(parseFloat(graphqlProduct.priceRange.minVariantPrice.amount) * 100);
  const priceMax = Math.round(parseFloat(graphqlProduct.priceRange.maxVariantPrice.amount) * 100);
  const compareAtPrice = graphqlProduct.compareAtPriceRange?.minVariantCompareAtPrice?.amount
    ? Math.round(parseFloat(graphqlProduct.compareAtPriceRange.minVariantCompareAtPrice.amount) * 100)
    : null;

  return {
    id: extractNumericId(graphqlProduct.id),
    title: graphqlProduct.title,
    handle: graphqlProduct.handle,
    description: graphqlProduct.description || '',
    vendor: graphqlProduct.vendor || '',
    type: graphqlProduct.productType || '',
    price: priceMin,
    price_min: priceMin,
    price_max: priceMax,
    compare_at_price: compareAtPrice,
    available: graphqlProduct.variants.edges.some(e => e.node.availableForSale),
    inventory_quantity: graphqlProduct.totalInventory || 0,
    featured_image: transformImage(graphqlProduct.featuredImage),
    images: graphqlProduct.images.edges.map(e => transformImage(e.node)),
    tags: graphqlProduct.tags || [],
    options: graphqlProduct.options.map(o => o.name),
    variants: graphqlProduct.variants.edges.map(e => transformVariant(e.node)),
    url: `/products/${graphqlProduct.handle}`
  };
}

function transformCollection(graphqlCollection: NonNullable<GraphQLCollectionResponse['data']>['collection']): MockCollection | null {
  if (!graphqlCollection) return null;

  const products = graphqlCollection.products.edges
    .map(e => transformProduct(e.node))
    .filter((p): p is MockProduct => p !== null);

  return {
    id: extractNumericId(graphqlCollection.id),
    title: graphqlCollection.title,
    handle: graphqlCollection.handle,
    description: graphqlCollection.description || '',
    image: graphqlCollection.image ? transformImage(graphqlCollection.image) : null,
    products,
    products_count: graphqlCollection.productsCount?.count || products.length,
    url: `/collections/${graphqlCollection.handle}`
  };
}

function transformArticle(graphqlArticle: NonNullable<GraphQLArticleResponse['data']>['article']): MockArticle | null {
  if (!graphqlArticle) return null;

  return {
    id: extractNumericId(graphqlArticle.id),
    title: graphqlArticle.title,
    handle: graphqlArticle.handle,
    content: graphqlArticle.body || '',
    excerpt: graphqlArticle.summary || '',
    author: graphqlArticle.author?.name || 'Unknown',
    published_at: graphqlArticle.publishedAt,
    image: graphqlArticle.image ? transformImage(graphqlArticle.image) : null,
    tags: graphqlArticle.tags || [],
    url: graphqlArticle.blog
      ? `/blogs/${graphqlArticle.blog.handle}/${graphqlArticle.handle}`
      : `/blogs/news/${graphqlArticle.handle}`
  };
}

function transformShop(graphqlShop: NonNullable<GraphQLShopResponse['data']>['shop']): MockShop | null {
  if (!graphqlShop) return null;

  return {
    name: graphqlShop.name,
    email: graphqlShop.email || '',
    domain: graphqlShop.primaryDomain?.host || '',
    url: graphqlShop.primaryDomain?.url || '',
    currency: graphqlShop.currencyCode || 'USD',
    money_format: `$\${amount} ${graphqlShop.currencyCode || 'USD'}`,
    description: graphqlShop.description || ''
  };
}

/**
 * Service for fetching Shopify resource data via GraphQL
 */
export class ShopifyDataService {
  private cache = new SimpleCache();
  private readonly CACHE_TTL = 10 * 60 * 1000; // 10 minutes

  /**
   * Fetch a product by ID
   */
  async getProduct(request: Request, productId: string): Promise<MockProduct | null> {
    // Normalize product ID to GID format if needed
    const gid = productId.startsWith('gid://')
      ? productId
      : `gid://shopify/Product/${productId}`;

    const cacheKey = `product:${gid}`;
    const cached = this.cache.get<MockProduct>(cacheKey);
    if (cached) return cached;

    try {
      const { admin } = await authenticate.admin(request);
      const response = await admin.graphql(PRODUCT_QUERY, {
        variables: { id: gid }
      });

      const data = await response.json() as GraphQLProductResponse;
      if (!data.data?.product) return null;

      const product = transformProduct(data.data.product);
      if (product) {
        this.cache.set(cacheKey, product, this.CACHE_TTL);
      }

      return product;
    } catch (error) {
      console.error('[ShopifyDataService] Error fetching product:', error);
      return null;
    }
  }

  /**
   * Fetch a collection by ID
   */
  async getCollection(request: Request, collectionId: string): Promise<MockCollection | null> {
    const gid = collectionId.startsWith('gid://')
      ? collectionId
      : `gid://shopify/Collection/${collectionId}`;

    const cacheKey = `collection:${gid}`;
    const cached = this.cache.get<MockCollection>(cacheKey);
    if (cached) return cached;

    try {
      const { admin } = await authenticate.admin(request);
      const response = await admin.graphql(COLLECTION_QUERY, {
        variables: { id: gid }
      });

      const data = await response.json() as GraphQLCollectionResponse;
      if (!data.data?.collection) return null;

      const collection = transformCollection(data.data.collection);
      if (collection) {
        this.cache.set(cacheKey, collection, this.CACHE_TTL);
      }

      return collection;
    } catch (error) {
      console.error('[ShopifyDataService] Error fetching collection:', error);
      return null;
    }
  }

  /**
   * Fetch an article by ID
   */
  async getArticle(request: Request, articleId: string): Promise<MockArticle | null> {
    const gid = articleId.startsWith('gid://')
      ? articleId
      : `gid://shopify/Article/${articleId}`;

    const cacheKey = `article:${gid}`;
    const cached = this.cache.get<MockArticle>(cacheKey);
    if (cached) return cached;

    try {
      const { admin } = await authenticate.admin(request);
      const response = await admin.graphql(ARTICLE_QUERY, {
        variables: { id: gid }
      });

      const data = await response.json() as GraphQLArticleResponse;
      if (!data.data?.article) return null;

      const article = transformArticle(data.data.article);
      if (article) {
        this.cache.set(cacheKey, article, this.CACHE_TTL);
      }

      return article;
    } catch (error) {
      console.error('[ShopifyDataService] Error fetching article:', error);
      return null;
    }
  }

  /**
   * Fetch shop data
   */
  async getShop(request: Request): Promise<MockShop | null> {
    const cacheKey = 'shop';
    const cached = this.cache.get<MockShop>(cacheKey);
    if (cached) return cached;

    try {
      const { admin } = await authenticate.admin(request);
      const response = await admin.graphql(SHOP_QUERY);

      const data = await response.json() as GraphQLShopResponse;
      if (!data.data?.shop) return null;

      const shop = transformShop(data.data.shop);
      if (shop) {
        this.cache.set(cacheKey, shop, this.CACHE_TTL);
      }

      return shop;
    } catch (error) {
      console.error('[ShopifyDataService] Error fetching shop:', error);
      return null;
    }
  }

  /**
   * Clear all cached data
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Clear specific cache entry
   */
  invalidateCache(type: 'product' | 'collection' | 'article' | 'shop', id?: string): void {
    if (type === 'shop') {
      this.cache.delete('shop');
    } else if (id) {
      const gid = id.startsWith('gid://') ? id : `gid://shopify/${type.charAt(0).toUpperCase() + type.slice(1)}/${id}`;
      this.cache.delete(`${type}:${gid}`);
    }
  }
}

export const shopifyDataService = new ShopifyDataService();
</file>

<file path="app/services/usage-tracking.server.ts">
/**
 * Usage Tracking Service
 *
 * Handles quota checks, usage metering, and billing integration
 */

import type { AdminApiContext } from "@shopify/shopify-app-react-router/server";
import { checkQuota, recordUsage, getSubscription } from "./billing.server";
import type { QuotaCheck } from "../types/billing";

/**
 * Check if merchant can generate (has quota)
 */
export async function canGenerate(shop: string): Promise<{ allowed: boolean; quota: QuotaCheck; reason?: string }> {
  const quota = await checkQuota(shop);

  if (!quota.hasQuota) {
    return {
      allowed: false,
      quota,
      reason: "You've reached your generation limit for this billing cycle. Please upgrade your plan or wait for the next cycle.",
    };
  }

  // Check if approaching cap (90% used)
  if (quota.percentUsed >= 90) {
    console.warn(`[Usage] Shop ${shop} is at ${quota.percentUsed.toFixed(1)}% of their cap`);
  }

  return {
    allowed: true,
    quota,
  };
}

/**
 * Record generation usage after successful AI generation
 */
export async function trackGeneration(admin: AdminApiContext, shop: string, sectionId: string, prompt: string) {
  try {
    // Check if this is an overage generation
    const subscription = await getSubscription(shop);

    if (!subscription) {
      // Free tier - no billing
      console.log(`[Usage] Free tier generation for ${shop}`);
      return;
    }

    // Truncate prompt for description (max 100 chars)
    const description = `Section generation - ${prompt.substring(0, 80)}${prompt.length > 80 ? "..." : ""}`;

    // Record usage (will charge if overage)
    const result = await recordUsage(admin, {
      shop,
      sectionId,
      description,
    });

    console.log(`[Usage] Recorded usage for ${shop}:`, {
      sectionId,
      amount: result.amount,
      status: result.chargeStatus,
    });

    return result;
  } catch (error) {
    console.error(`[Usage] Failed to track generation for ${shop}:`, error);

    // Save for manual reconciliation
    const prisma = (await import("../db.server")).default;
    await prisma.failedUsageCharge.create({
      data: {
        shop,
        sectionId,
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      },
    });

    // Alert monitoring (TODO: integrate with Sentry/Datadog)
    // await alertMonitoring('usage_charge_failed', { shop, sectionId, error });

    // Don't throw - allow generation to succeed
  }
}

/**
 * Get usage summary for current billing cycle
 */
export async function getUsageSummary(shop: string) {
  const quota = await checkQuota(shop);
  const subscription = await getSubscription(shop);

  if (!subscription) {
    return {
      plan: "Free",
      usageThisCycle: 0,
      includedQuota: 5,
      overagesThisCycle: 0,
      percentUsed: 0,
      estimatedCharge: 0,
      daysUntilRenewal: null,
    };
  }

  const daysUntilRenewal = Math.ceil(
    (subscription.currentPeriodEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
  );

  const estimatedCharge = subscription.basePrice + subscription.overagesThisCycle * subscription.overagePrice;

  return {
    plan: subscription.planName,
    usageThisCycle: subscription.usageThisCycle,
    includedQuota: subscription.includedQuota,
    overagesThisCycle: subscription.overagesThisCycle,
    percentUsed: quota.percentUsed,
    estimatedCharge,
    daysUntilRenewal,
  };
}
</file>

<file path="app/types/billing.ts">
/**
 * Billing Types for AI Section Generator
 *
 * Hybrid subscription model: Base recurring charge + usage-based overages
 */

import type { Subscription, UsageRecord, PlanConfiguration } from "@prisma/client";

/**
 * Plan tier names
 */
export type PlanTier = "starter" | "growth" | "professional";

/**
 * Subscription status from Shopify
 */
export type SubscriptionStatus = "active" | "cancelled" | "expired" | "pending" | "frozen" | "declined";

/**
 * Usage charge status
 */
export type ChargeStatus = "pending" | "accepted" | "declined" | "error";

/**
 * Plan configuration with pricing and limits
 */
export interface PlanConfig {
  planName: PlanTier;
  displayName: string;
  description: string;
  basePrice: number; // USD
  includedQuota: number; // Generations per cycle
  overagePrice: number; // USD per additional generation
  cappedAmount: number; // Max total monthly charge (USD)
  features: string[];
  badge?: string; // "Popular", "Best Value"
  sortOrder: number;
  isActive: boolean;
}

/**
 * Subscription creation input
 */
export interface CreateSubscriptionInput {
  shop: string;
  planName: PlanTier;
  returnUrl: string; // Return URL after approval
  // Note: test mode is controlled by BILLING_TEST_MODE env variable
}

/**
 * Subscription creation result from Shopify
 */
export interface CreateSubscriptionResult {
  confirmationUrl: string; // Redirect merchant here for approval
  subscriptionId: string; // Shopify GraphQL subscription ID
}

/**
 * Usage record input
 */
export interface RecordUsageInput {
  shop: string;
  sectionId: string;
  description: string; // e.g., "Section generation - Hero banner"
  amount?: number; // If not provided, use plan's overage price
}

/**
 * Usage record result
 */
export interface RecordUsageResult {
  usageRecordId: string; // Local database ID
  shopifyChargeId: string | null; // Shopify usage charge ID
  amount: number; // Charge amount
  chargeStatus: ChargeStatus;
}

/**
 * Quota check result
 */
export interface QuotaCheck {
  hasQuota: boolean; // Can merchant generate?
  subscription: Subscription | null;
  usageThisCycle: number;
  includedQuota: number;
  overagesThisCycle: number;
  overagesRemaining: number; // How many overages left before cap
  percentUsed: number; // 0-100
  isInTrial: boolean;
  trialEndsAt: Date | null;
}

/**
 * Subscription upgrade/downgrade input
 */
export interface ChangeSubscriptionInput {
  shop: string;
  newPlanName: PlanTier;
  returnUrl: string;
}

/**
 * Webhook payload for APP_SUBSCRIPTIONS_UPDATE
 */
export interface SubscriptionUpdateWebhook {
  app_subscription: {
    admin_graphql_api_id: string; // e.g., gid://shopify/AppSubscription/123
    name: string;
    status: SubscriptionStatus;
    capped_amount: {
      amount: string;
      currency_code: string;
    };
    current_period_end?: string; // ISO 8601 - Optional, may not be included in webhook
    test: boolean;
  };
}

/**
 * Webhook payload for APPROACHING_CAPPED_AMOUNT
 */
export interface ApproachingCappedAmountWebhook {
  app_subscription: {
    admin_graphql_api_id: string;
    balance_used: {
      amount: string;
      currency_code: string;
    };
    capped_amount: {
      amount: string;
      currency_code: string;
    };
  };
}

/**
 * Billing cycle info
 */
export interface BillingCycle {
  start: Date;
  end: Date;
  isCurrent: boolean;
}

/**
 * Merchant billing summary
 */
export interface BillingSummary {
  subscription: Subscription | null;
  currentCycle: BillingCycle;
  quota: QuotaCheck;
  estimatedCharge: number; // Base + usage charges
  generationsThisCycle: number;
  overagesThisCycle: number;
  daysUntilRenewal: number;
}

// Re-export Prisma types for convenience
export type { Subscription, UsageRecord, PlanConfiguration };
</file>

<file path=".eslintrc.cjs">
/**
 * This is intended to be a basic starting point for linting in your app.
 * It relies on recommended configs out of the box for simplicity, but you can
 * and should modify this configuration to best suit your team's needs.
 */

/** @type {import('eslint').Linter.Config} */
module.exports = {
  root: true,
  parserOptions: {
    ecmaVersion: "latest",
    sourceType: "module",
    ecmaFeatures: {
      jsx: true,
    },
  },
  env: {
    browser: true,
    commonjs: true,
    es6: true,
  },
  ignorePatterns: ["!**/.server", "!**/.client"],

  // Base config
  extends: ["eslint:recommended"],

  overrides: [
    // React
    {
      files: ["**/*.{js,jsx,ts,tsx}"],
      plugins: ["react", "jsx-a11y"],
      extends: [
        "plugin:react/recommended",
        "plugin:react/jsx-runtime",
        "plugin:react-hooks/recommended",
        "plugin:jsx-a11y/recommended",
      ],
      settings: {
        react: {
          version: "detect",
        },
        formComponents: ["Form"],
        linkComponents: [
          { name: "Link", linkAttribute: "to" },
          { name: "NavLink", linkAttribute: "to" },
        ],
        "import/resolver": {
          typescript: {},
        },
      },
      rules: {
        "react/no-unknown-property": ["error", { ignore: ["variant"] }],
      },
    },

    // Typescript
    {
      files: ["**/*.{ts,tsx}"],
      plugins: ["@typescript-eslint", "import"],
      parser: "@typescript-eslint/parser",
      settings: {
        "import/internal-regex": "^~/",
        "import/resolver": {
          node: {
            extensions: [".ts", ".tsx"],
          },
          typescript: {
            alwaysTryTypes: true,
          },
        },
      },
      extends: [
        "plugin:@typescript-eslint/recommended",
        "plugin:import/recommended",
        "plugin:import/typescript",
      ],
      rules: {
        "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
      },
    },

    // Node
    {
      files: [
        ".eslintrc.cjs",
        "vite.config.{js,ts}",
        ".graphqlrc.{js,ts}",
        "shopify.server.{js,ts}",
        "**/*.server.{js,ts}",
      ],
      env: {
        node: true,
      },
    },
  ],
  globals: {
    shopify: "readonly"
  },
};
</file>

<file path=".gitignore">
node_modules

/.cache
/build
/app/build
/public/build/
/public/_dev
/app/public/build
/prisma/dev.sqlite
/prisma/dev.sqlite-journal
database.sqlite

.env
.env.*





/extensions/*/dist

# Ignore shopify files created during app dev
.shopify/*
.shopify.lock

# Hide files auto-generated by react router
.react-router/
.gemini/
coverage/
</file>

<file path="jest.config.cjs">
/** @type {import('jest').Config} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/app'],
  testMatch: ['**/__tests__/**/*.test.ts?(x)'],
  moduleNameMapper: {
    '^~/(.*)$': '<rootDir>/app/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.cjs'],
  collectCoverageFrom: [
    'app/**/*.{ts,tsx}',
    '!app/**/*.d.ts',
    '!app/**/__tests__/**',
    '!app/entry.*.tsx',
    '!app/root.tsx',
    '!app/services/config.server.ts', // Config initialization, tested via integration
    '!app/services/theme.server.ts', // Real Shopify API, tested via mocks
    '!app/services/ai.server.ts', // Real Gemini API, tested via mocks
    '!app/services/billing.server.ts', // Complex Shopify billing, needs integration tests
    '!app/services/history.server.ts', // DB operations, needs integration tests
    '!app/services/settings.server.ts', // DB operations, needs integration tests
    '!app/services/template.server.ts', // DB operations, needs integration tests
    '!app/services/usage-tracking.server.ts', // DB operations, needs integration tests
    '!app/services/shopify-data.server.ts', // Real Shopify API, tested via mocks
    '!app/services/adapters/*.ts', // Simple delegation, tested via integration
    '!app/services/flags/*.ts', // Feature flags, tested via integration
  ],
  coverageThreshold: {
    // Low global thresholds - codebase still early stage
    // TODO: Increase as test coverage improves
    global: {
      branches: 0,
      functions: 0,
      lines: 0,
      statements: 0,
    },
  },
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      tsconfig: {
        jsx: 'react-jsx',
        esModuleInterop: true,
        allowSyntheticDefaultImports: true,
      },
    }],
  },
};
</file>

<file path="shopify.web.toml">
name = "React Router"
roles = ["frontend", "backend"]
webhooks_path = "/webhooks/app/uninstalled"

[commands]
predev = "npx prisma generate"
dev = "npm exec react-router dev"
</file>

<file path="app/components/generate/GenerateLayout.tsx">
import type { ReactNode } from "react";

export interface GenerateLayoutProps {
  inputColumn: ReactNode;
  previewColumn: ReactNode;
}

/**
 * Two-column responsive layout for generate screen
 * Following Shopify's Details template pattern:
 * - Primary column (2/3): Main content (prompt, templates)
 * - Secondary column (1/3): Supporting info (preview, save)
 * Uses s-grid for proper responsive behavior
 */
export function GenerateLayout({ inputColumn, previewColumn }: GenerateLayoutProps) {
  return (
    <s-grid
      gap="large"
      gridTemplateColumns="1fr 2fr"
    >
      {/* Primary column: Main creation content */}
      <s-stack gap="large" direction="block">
        {inputColumn}
      </s-stack>

      {/* Secondary column: Preview and save */}
      <s-stack gap="large" direction="block">
        {previewColumn}
      </s-stack>
    </s-grid>
  );
}
</file>

<file path="app/components/generate/PromptExamples.tsx">
import { PROMPT_EXAMPLES } from './templates/template-data';

export interface PromptExamplesProps {
  onSelectExample: (prompt: string) => void;
  disabled?: boolean;
}

/**
 * Quick prompt examples as clickable chips
 * Click to populate prompt field
 * Uses s-clickable-chip for proper Polaris styling
 */
export function PromptExamples({
  onSelectExample,
  disabled = false
}: PromptExamplesProps) {
  return (
    <s-stack gap="small" direction="inline">
      {PROMPT_EXAMPLES.map((example) => (
        <s-clickable-chip
          key={example.id}
          onClick={() => !disabled && onSelectExample(example.prompt)}
          disabled={disabled || undefined}
        >
          {example.label}
        </s-clickable-chip>
      ))}
    </s-stack>
  );
}
</file>

<file path="app/components/generate/SectionNameInput.tsx">
export interface SectionNameInputProps {
  value: string;
  onChange: (value: string) => void;
  error?: string;
  disabled?: boolean;
}

/**
 * Section filename input
 * Shows filename preview with .liquid extension
 */
export function SectionNameInput({
  value,
  onChange,
  error
}: SectionNameInputProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <s-text-field
      label="Section Filename"
      value={value}
      onInput={handleInput}
      autocomplete="off"
      suffix=".liquid"
      error={error}
    />
  );
}
</file>

<file path="app/components/generate/TemplateSuggestions.tsx">
import { SECTION_TEMPLATES, type SectionTemplate } from './templates/template-data';

export interface TemplateSuggestionsProps {
  onSelectTemplate: (prompt: string) => void;
  disabled?: boolean;
}

/**
 * Template gallery showing common section types
 * Click to populate prompt with pre-written description
 * Uses s-grid for proper responsive layout
 */
export function TemplateSuggestions({
  onSelectTemplate,
  disabled = false
}: TemplateSuggestionsProps) {
  const handleClick = (template: SectionTemplate) => {
    if (!disabled) {
      onSelectTemplate(template.prompt);
    }
  };

  return (
    <s-grid
      gap="base"
      gridTemplateColumns="repeat(auto-fill, minmax(140px, 1fr))"
    >
      {SECTION_TEMPLATES.map((template) => (
        <s-clickable
          key={template.id}
          onClick={() => handleClick(template)}
          disabled={disabled || undefined}
          padding="base"
          borderRadius="base"
          border="base"
          borderColor="subdued"
          background="base"
        >
          <s-stack gap="small" direction="block">
            <s-text>{template.icon}</s-text>
            <s-text type="strong">{template.title}</s-text>
            <s-text color="subdued">{template.description}</s-text>
          </s-stack>
        </s-clickable>
      ))}
    </s-grid>
  );
}
</file>

<file path="app/components/preview/hooks/useResourceFetcher.ts">
/**
 * Resource Fetcher Hook
 * Fetches Shopify resource data from the API endpoint
 */

import { useCallback, useState } from 'react';
import type { MockProduct, MockCollection, MockArticle } from '../mockData/types';

export type ResourceType = 'product' | 'collection' | 'article';

interface UseResourceFetcherReturn {
  fetchProduct: (productId: string) => Promise<MockProduct | null>;
  fetchProducts: (productIds: string[]) => Promise<MockProduct[]>;
  fetchCollection: (collectionId: string) => Promise<MockCollection | null>;
  fetchArticle: (articleId: string) => Promise<MockArticle | null>;
  loading: boolean;
  error: string | null;
  clearError: () => void;
}

/**
 * Hook for fetching Shopify resources from the API
 */
export function useResourceFetcher(): UseResourceFetcherReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchResource = useCallback(async <T>(
    type: ResourceType,
    id: string
  ): Promise<T | null> => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`/app/api/resource?type=${type}&id=${encodeURIComponent(id)}`);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch ${type}`);
      }

      const result = await response.json();
      return result.data as T;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : `Failed to fetch ${type}`;
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const fetchProduct = useCallback(async (productId: string): Promise<MockProduct | null> => {
    return fetchResource<MockProduct>('product', productId);
  }, [fetchResource]);

  const fetchProducts = useCallback(async (productIds: string[]): Promise<MockProduct[]> => {
    if (productIds.length === 0) return [];

    setLoading(true);
    setError(null);

    try {
      // Fetch all products in parallel
      const results = await Promise.all(
        productIds.map(id => fetchResource<MockProduct>('product', id))
      );
      return results.filter((p): p is MockProduct => p !== null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch products';
      setError(errorMessage);
      return [];
    } finally {
      setLoading(false);
    }
  }, [fetchResource]);

  const fetchCollection = useCallback(async (collectionId: string): Promise<MockCollection | null> => {
    return fetchResource<MockCollection>('collection', collectionId);
  }, [fetchResource]);

  const fetchArticle = useCallback(async (articleId: string): Promise<MockArticle | null> => {
    return fetchResource<MockArticle>('article', articleId);
  }, [fetchResource]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    fetchProduct,
    fetchProducts,
    fetchCollection,
    fetchArticle,
    loading,
    error,
    clearError
  };
}
</file>

<file path="app/components/preview/mockData/types.ts">
/**
 * Mock data types for Shopify Liquid objects
 */

export interface MockImage {
  src: string;
  alt: string;
  width: number;
  height: number;
}

export interface MockProduct {
  id: number;
  title: string;
  handle: string;
  description: string;
  vendor: string;
  type: string;
  price: number;
  price_min: number;
  price_max: number;
  compare_at_price: number | null;
  available: boolean;
  inventory_quantity: number;
  featured_image: MockImage;
  images: MockImage[];
  tags: string[];
  options: string[];
  variants: MockProductVariant[];
  url: string;
}

export interface MockProductVariant {
  id: number;
  title: string;
  price: number;
  available: boolean;
  inventory_quantity: number;
  sku: string;
  option1: string | null;
  option2: string | null;
  option3: string | null;
}

export interface MockCollection {
  id: number;
  title: string;
  handle: string;
  description: string;
  image: MockImage | null;
  products: MockProduct[];
  products_count: number;
  url: string;
}

export interface MockArticle {
  id: number;
  title: string;
  handle: string;
  content: string;
  excerpt: string;
  author: string;
  published_at: string;
  image: MockImage | null;
  tags: string[];
  url: string;
}

export interface MockBlog {
  id: number;
  title: string;
  handle: string;
  articles: MockArticle[];
  articles_count: number;
  url: string;
}

export interface MockShop {
  name: string;
  email: string;
  domain: string;
  url: string;
  currency: string;
  money_format: string;
  description: string;
}

export interface MockCart {
  item_count: number;
  total_price: number;
  items: MockCartItem[];
  currency: string;
}

export interface MockCartItem {
  id: number;
  title: string;
  quantity: number;
  price: number;
  line_price: number;
  image: MockImage;
  url: string;
}

export interface MockCustomer {
  id: number;
  email: string;
  first_name: string;
  last_name: string;
  name: string;
  orders_count: number;
  total_spent: number;
}

export interface MockRequest {
  design_mode: boolean;
  page_type: string;
  path: string;
  host?: string;
  origin?: string;
}

export interface MockForloop {
  index: number;
  index0: number;
  rindex: number;
  rindex0: number;
  first: boolean;
  last: boolean;
  length: number;
}

export interface MockPaginate {
  current_page: number;
  page_size: number;
  total_items: number;
}

export interface MockRoutes {
  root_url: string;
  cart_url: string;
  account_url: string;
  account_login_url: string;
  account_logout_url: string;
  account_register_url: string;
  account_addresses_url: string;
  cart_add_url: string;
  cart_change_url: string;
  cart_clear_url: string;
  cart_update_url: string;
  collections_url: string;
  all_products_collection_url: string;
  search_url: string;
  predictive_search_url: string;
  product_recommendations_url: string;
}

export interface MockTheme {
  id: number;
  name: string;
  role: string;
}

export interface MockDataContext {
  product?: MockProduct;
  products?: MockProduct[];
  collection?: MockCollection;
  collections?: MockCollection[];
  article?: MockArticle;
  articles?: MockArticle[];
  blog?: MockBlog;
  shop: MockShop;
  cart?: MockCart;
  customer?: MockCustomer | null;
  request?: MockRequest;
}
</file>

<file path="app/components/preview/schema/SchemaTypes.ts">
/**
 * Shopify section schema types
 * Supports all 31 input setting types from Shopify theme documentation
 */

export type SettingType =
  // Basic Input
  | 'text'
  | 'textarea'
  | 'richtext'
  | 'inline_richtext'
  | 'number'
  | 'range'
  | 'checkbox'
  | 'select'
  | 'radio'
  // Color & Design
  | 'color'
  | 'color_background'
  | 'font_picker'
  | 'text_alignment'
  // Media
  | 'image_picker'
  | 'video'
  | 'video_url'
  // Rich Content
  | 'url'
  | 'html'
  | 'liquid'
  // Resource Pickers
  | 'article'
  | 'blog'
  | 'collection'
  | 'page'
  | 'product'
  | 'link_list'
  // Resource Lists
  | 'collection_list'
  | 'product_list'
  // Sidebar
  | 'header'
  | 'paragraph'
  // Advanced (deferred)
  | 'color_scheme'
  | 'color_scheme_group'
  | 'metaobject'
  | 'metaobject_list';

export interface SelectOption {
  value: string;
  label: string;
  group?: string;
}

export interface SchemaSetting {
  type: SettingType;
  id: string;
  label: string;
  default?: string | number | boolean;
  placeholder?: string;
  info?: string;
  // Type-specific properties
  options?: SelectOption[];
  min?: number;
  max?: number;
  step?: number;
  unit?: string;
  // Header/paragraph content
  content?: string;
  // Video URL specific
  accept?: string[];
  // List types
  limit?: number;
}

export interface SchemaBlock {
  type: string;
  name: string;
  settings?: SchemaSetting[];
  limit?: number;
}

export interface SchemaPreset {
  name: string;
  settings?: Record<string, unknown>;
  blocks?: Array<{ type: string; settings?: Record<string, unknown> }>;
}

export interface SchemaDefinition {
  name: string;
  tag?: string;
  class?: string;
  limit?: number;
  settings?: SchemaSetting[];
  blocks?: SchemaBlock[];
  presets?: SchemaPreset[];
  default?: {
    settings?: Record<string, unknown>;
    blocks?: Array<{ type: string; settings?: Record<string, unknown> }>;
  };
}

export type SettingsState = Record<string, string | number | boolean>;

/**
 * Runtime block instance with settings
 * Represents a single block in section.blocks array
 */
export interface BlockInstance {
  id: string;           // Unique identifier (auto-generated)
  type: string;         // Block type from schema
  settings: SettingsState;  // Block-specific settings with defaults
}
</file>

<file path="app/components/preview/settings/CollectionSetting.tsx">
/**
 * CollectionSetting Component
 * Renders resource picker for schema settings with type: "collection"
 * Uses Polaris Web Components for styling
 */

import type { SchemaSetting } from '../schema/SchemaTypes';
import { ResourceSelector, type SelectedResource } from '../ResourceSelector';

export interface CollectionSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (id: string, value: string) => void;
  disabled?: boolean;
  selectedResource?: SelectedResource | null;
  onResourceSelect?: (settingId: string, resourceId: string | null, resource: SelectedResource | null) => void;
  loading?: boolean;
}

/**
 * CollectionSetting - Renders App Bridge resource picker for collection type settings
 * Integrates with SettingsPanel to store resource ID in settingsValues
 */
export function CollectionSetting({
  setting,
  value: _value,
  onChange,
  disabled,
  selectedResource,
  onResourceSelect,
  loading
}: CollectionSettingProps) {
  const handleSelect = (resourceId: string | null, resource: SelectedResource | null) => {
    // Update settings value with resource ID (for context building)
    onChange(setting.id, resourceId || '');
    // Notify parent about full resource selection (for state management)
    onResourceSelect?.(setting.id, resourceId, resource);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <ResourceSelector
        resourceType="collection"
        onSelect={handleSelect}
        selectedResource={selectedResource}
        disabled={disabled}
        loading={loading}
      />
    </div>
  );
}
</file>

<file path="app/components/preview/settings/ColorSetting.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';

export interface ColorSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

/**
 * ColorSetting - Renders color picker using Polaris Web Components
 * Includes both color picker and text input for hex value
 */
export function ColorSetting({ setting, value, onChange, disabled }: ColorSettingProps) {
  // Use native Event type for Polaris Web Components
  const handleColorChange = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  const handleTextChange = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
        <s-color-field
          value={value || ''}
          placeholder="#000000"
          disabled={disabled || undefined}
          label={setting.label}
          onChange={handleColorChange}
          onInput={handleTextChange}
        />
      </div>
      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/ProductSetting.tsx">
/**
 * ProductSetting Component
 * Renders resource picker for schema settings with type: "product"
 * Uses Polaris Web Components for styling
 */

import type { SchemaSetting } from '../schema/SchemaTypes';
import { ResourceSelector, type SelectedResource } from '../ResourceSelector';

export interface ProductSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (id: string, value: string) => void;
  disabled?: boolean;
  selectedResource?: SelectedResource | null;
  onResourceSelect?: (settingId: string, resourceId: string | null, resource: SelectedResource | null) => void;
  loading?: boolean;
}

/**
 * ProductSetting - Renders App Bridge resource picker for product type settings
 * Integrates with SettingsPanel to store resource ID in settingsValues
 */
export function ProductSetting({
  setting,
  value: _value,
  onChange,
  disabled,
  selectedResource,
  onResourceSelect,
  loading
}: ProductSettingProps) {
  const handleSelect = (resourceId: string | null, resource: SelectedResource | null) => {
    // Update settings value with resource ID (for context building)
    onChange(setting.id, resourceId || '');
    // Notify parent about full resource selection (for state management)
    onResourceSelect?.(setting.id, resourceId, resource);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>{setting.info}</span>
      )}

      <ResourceSelector
        resourceType="product"
        onSelect={handleSelect}
        selectedResource={selectedResource}
        disabled={disabled}
        loading={loading}
      />
    </div>
  );
}
</file>

<file path="app/components/templates/TemplateEditorModal.tsx">
import { useState, useEffect } from "react";
import type { SectionTemplate } from "@prisma/client";

export interface TemplateEditorModalProps {
  template: SectionTemplate | null;
  onSave: (data: {
    title: string;
    description: string;
    category: string;
    icon: string;
    prompt: string;
  }) => void;
  onClose: () => void;
}

// Updated categories to match the new 10 categories
const CATEGORIES = [
  { value: "hero", label: "Hero" },
  { value: "features", label: "Features" },
  { value: "testimonials", label: "Testimonials" },
  { value: "pricing", label: "Pricing" },
  { value: "cta", label: "Call to Action" },
  { value: "faq", label: "FAQ" },
  { value: "team", label: "Team" },
  { value: "gallery", label: "Gallery" },
  { value: "content", label: "Content" },
  { value: "footer", label: "Footer" },
];

const ICONS = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

const MODAL_ID = "template-editor-modal";

/**
 * Modal for creating/editing templates using s-modal
 */
export function TemplateEditorModal({
  template,
  onSave,
  onClose
}: TemplateEditorModalProps) {
  const [title, setTitle] = useState(template?.title || "");
  const [description, setDescription] = useState(template?.description || "");
  const [category, setCategory] = useState(template?.category || "hero");
  const [icon, setIcon] = useState(template?.icon || "");
  const [prompt, setPrompt] = useState(template?.prompt || "");

  // Update form when template changes
  useEffect(() => {
    setTitle(template?.title || "");
    setDescription(template?.description || "");
    setCategory(template?.category || "hero");
    setIcon(template?.icon || "");
    setPrompt(template?.prompt || "");
  }, [template]);

  const isValid = title.trim() && description.trim() && prompt.trim();

  const handleSubmit = () => {
    if (!isValid) return;
    onSave({
      title: title.trim(),
      description: description.trim(),
      category,
      icon,
      prompt: prompt.trim(),
    });
  };

  // Programmatically show modal when component mounts
  useEffect(() => {
    const modal = document.getElementById(MODAL_ID);
    if (modal) {
      (modal as HTMLElement & { show: () => void }).show?.();
    }
  }, []);

  // Handle close via modal's close event
  const handleModalClose = () => {
    onClose();
  };

  return (
    <s-modal
      id={MODAL_ID}
      heading={template ? "Edit Template" : "Create Template"}
      size="large"
    >
      <s-stack gap="large" direction="block">
        {/* Title */}
        <s-text-field
          label="Title"
          value={title}
          onInput={(e: Event) => setTitle((e.target as HTMLInputElement).value)}
          placeholder="e.g., Hero with Background Image"
          required
        />

        {/* Description */}
        <s-text-field
          label="Description"
          value={description}
          onInput={(e: Event) => setDescription((e.target as HTMLInputElement).value)}
          placeholder="Brief description of what this template creates"
          required
        />

        {/* Category */}
        <s-select
          label="Category"
          value={category}
          onChange={(e: Event) => setCategory((e.target as HTMLSelectElement).value)}
        >
          {CATEGORIES.map((cat) => (
            <option key={cat.value} value={cat.value}>{cat.label}</option>
          ))}
        </s-select>

        {/* Icon picker */}
        <s-stack gap="small" direction="block">
          <s-text type="strong">Icon</s-text>
          <div style={{ overflowX: 'auto', paddingBottom: '4px' }}>
            <s-button-group gap="none">
              {ICONS.map((emoji) => (
                <s-button
                  key={emoji}
                  variant={icon === emoji ? "primary" : "secondary"}
                  onClick={() => setIcon(emoji)}
                >
                  <span style={{ fontSize: '18px' }}>{emoji}</span>
                </s-button>
              ))}
            </s-button-group>
          </div>
        </s-stack>

        {/* Prompt */}
        <s-text-area
          label="Prompt"
          value={prompt}
          onInput={(e: Event) => setPrompt((e.target as HTMLTextAreaElement).value)}
          placeholder="Describe what section this template should generate when used..."
          rows={4}
          required
        />
      </s-stack>

      {/* Modal Actions */}
      <s-button
        slot="secondary-actions"
        command="--hide"
        commandFor={MODAL_ID}
        onClick={handleModalClose}
      >
        Cancel
      </s-button>
      <s-button
        slot="primary-action"
        variant="primary"
        command="--hide"
        commandFor={MODAL_ID}
        onClick={handleSubmit}
        disabled={!isValid}
      >
        {template ? "Save Changes" : "Create Template"}
      </s-button>
    </s-modal>
  );
}
</file>

<file path="app/components/templates/TemplateGrid.tsx">
import type { SectionTemplate } from "@prisma/client";
import { TemplateCard } from "./TemplateCard";

export interface TemplateGridProps {
  templates: SectionTemplate[];
  onUseAsIs: (template: SectionTemplate) => void;
  onCustomize: (template: SectionTemplate) => void;
  onEdit: (template: SectionTemplate) => void;
  onToggleFavorite: (id: string) => void;
  onDuplicate: (id: string) => void;
  onDelete: (id: string) => void;
}

/**
 * Grid of template cards using Polaris s-grid
 */
export function TemplateGrid({
  templates,
  onUseAsIs,
  onCustomize,
  onEdit,
  onToggleFavorite,
  onDuplicate,
  onDelete
}: TemplateGridProps) {
  return (
    <s-grid
      gap="base"
      gridTemplateColumns="repeat(auto-fill, minmax(320px, 1fr))"
    >
      {templates.map((template) => (
        <TemplateCard
          key={template.id}
          template={template}
          onUseAsIs={() => onUseAsIs(template)}
          onCustomize={() => onCustomize(template)}
          onEdit={() => onEdit(template)}
          onToggleFavorite={() => onToggleFavorite(template.id)}
          onDuplicate={() => onDuplicate(template.id)}
          onDelete={() => onDelete(template.id)}
        />
      ))}
    </s-grid>
  );
}
</file>

<file path="app/routes/app.billing.tsx">
/**
 * Billing page - Plan selection, subscription management, usage dashboard
 */

import { useEffect } from "react";
import type { LoaderFunctionArgs, ActionFunctionArgs } from "react-router";
import {
  useLoaderData,
  useSubmit,
  useActionData,
  useNavigation,
} from "react-router";
import { authenticate } from "../shopify.server";
import {
  getActivePlans,
  getSubscription,
  createSubscription,
  cancelSubscription,
  checkQuota,
} from "../services/billing.server";
import type { PlanTier } from "../types/billing";
import {
  PlanSelector,
  UsageDashboard,
  UsageAlertBanner,
} from "../components/billing";
import { useAppBridge } from "@shopify/app-bridge-react";

export async function loader({ request }: LoaderFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const url = new URL(request.url);
  const status = url.searchParams.get("status");
  const charge_id = url.searchParams.get("charge_id");

  const [plans, subscription, quota] = await Promise.all([
    getActivePlans(),
    getSubscription(session.shop),
    checkQuota(session.shop),
  ]);

  return {
    plans,
    subscription,
    quota,
    shop: session.shop,
    approvalStatus: status, // 'success', 'declined', or null
    chargeId: charge_id,
  };
}

export async function action({ request }: ActionFunctionArgs) {
  const { session, admin } = await authenticate.admin(request);
  const formData = await request.formData();
  const action = formData.get("action") as string;

  if (action === "subscribe") {
    const planName = formData.get("planName") as PlanTier;

    // Build the embedded app URL that Shopify will redirect to after approval
    // Format: https://admin.shopify.com/store/{shop}/apps/{app-handle}/app/billing
    const shopDomain = session.shop.replace(".myshopify.com", "");
    const appHandle = "blocksmith-ai"; // Your app handle from shopify.app.toml
    const returnUrl = `https://admin.shopify.com/store/${shopDomain}/apps/${appHandle}/app/billing`;

    try {
      const result = await createSubscription(admin, {
        shop: session.shop,
        planName,
        returnUrl,
      });

      // Return confirmation URL for App Bridge redirect (embedded apps)
      return {
        confirmationUrl: result.confirmationUrl,
      };
    } catch (error) {
      console.error("Failed to create subscription:", error);
      return {
        error: "Failed to create subscription. Please try again.",
      };
    }
  }

  if (action === "cancel") {
    try {
      await cancelSubscription(admin, session.shop);
      return { success: true };
    } catch (error) {
      console.error("Failed to cancel subscription:", error);
      return {
        error: "Failed to cancel subscription. Please try again.",
      };
    }
  }

  return { error: "Invalid action" };
}

export default function BillingPage() {
  const { plans, subscription, quota, approvalStatus, chargeId } =
    useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const navigation = useNavigation();
  const submit = useSubmit();
  const shopify = useAppBridge();

  // Redirect to Shopify confirmation page
  useEffect(() => {
    if (actionData?.confirmationUrl) {
      // For embedded apps, use top-level window redirect
      // Shopify will handle the billing flow in their UI
      window.top!.location.href = actionData.confirmationUrl;
    }
  }, [actionData?.confirmationUrl]);

  // Show toast on successful subscription cancellation
  useEffect(() => {
    if (actionData?.success) {
      shopify.toast.show("Subscription cancelled successfully");
    }
  }, [actionData?.success, shopify]);

  // Handle plan selection
  const handlePlanSelect = (planName: PlanTier) => {
    const formData = new FormData();
    formData.append("action", "subscribe");
    formData.append("planName", planName);
    submit(formData, { method: "post" });
  };

  // Handle upgrade click from alert banner
  const handleUpgradeClick = () => {
    // Scroll to plan selector
    const planSelector = document.getElementById("plan-selector");
    if (planSelector) {
      planSelector.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  };

  // Show loading state during subscription operations
  const isLoading =
    navigation.state === "submitting" || navigation.state === "loading";
  const isCancelling =
    isLoading && navigation.formData?.get("action") === "cancel";

  return (
    <s-page heading="Billing & Usage" inlineSize="base">
      <s-button slot="primary-action" variant="secondary" href="/docs/billing">
        Help
      </s-button>

      {/* Subscription Approval Success */}
      {approvalStatus === "success" && chargeId && (
        <s-banner tone="success">
          <s-paragraph>
            Subscription activated successfully! Your plan is now active.
          </s-paragraph>
        </s-banner>
      )}

      {/* Subscription Approval Declined */}
      {approvalStatus === "declined" && (
        <s-banner tone="warning">
          <s-paragraph>
            Subscription approval was declined. Please select a plan to
            continue.
          </s-paragraph>
        </s-banner>
      )}

      {/* Error Banner */}
      {actionData?.error && (
        <s-banner tone="critical">
          <s-paragraph>{actionData.error}</s-paragraph>
        </s-banner>
      )}

      {/* Usage Alert Banner (shows at 75%+ usage) */}
      <UsageAlertBanner quota={quota} onUpgradeClick={handleUpgradeClick} />

      <s-stack gap="large" direction="block">
        {/* Current Subscription Details */}
        {subscription && (
          <s-section heading="Current Subscription">
            <s-box border="base" borderRadius="base" padding="base">
              <s-grid gap="base">
                {/* Plan Info */}
                <s-grid gridTemplateColumns="1fr auto" alignItems="center">
                  <s-grid gap="small-100">
                    <s-heading>
                      {subscription.planName === "starter" && "Starter Plan"}
                      {subscription.planName === "growth" && "Growth Plan"}
                      {subscription.planName === "professional" &&
                        "Professional Plan"}
                    </s-heading>
                    <s-paragraph color="subdued">
                      ${subscription.basePrice}/month + usage charges
                    </s-paragraph>
                  </s-grid>
                  <s-badge
                    tone={
                      subscription.status === "active"
                        ? "success"
                        : subscription.status === "cancelled"
                          ? "critical"
                          : "warning"
                    }
                  >
                    {subscription.status.charAt(0).toUpperCase() +
                      subscription.status.slice(1)}
                  </s-badge>
                </s-grid>

                {/* Billing Date */}
                {subscription.currentPeriodEnd && (
                  <>
                    <s-divider />
                    <s-grid gridTemplateColumns="1fr auto">
                      <s-paragraph>Next billing date</s-paragraph>
                      <s-text>
                        {new Date(
                          subscription.currentPeriodEnd,
                        ).toLocaleDateString("en-US", {
                          month: "short",
                          day: "numeric",
                          year: "numeric",
                        })}
                      </s-text>
                    </s-grid>
                  </>
                )}
              </s-grid>
            </s-box>
          </s-section>
        )}

        {/* Usage Dashboard */}
        <UsageDashboard quota={quota} subscription={subscription} />

        {/* Plan Selector */}
        <PlanSelector
          plans={plans.map((p) => ({
            ...p,
            planName: p.planName as PlanTier,
            badge: p.badge ?? undefined,
          }))}
          currentPlan={(subscription?.planName as PlanTier) ?? null}
          onSelect={handlePlanSelect}
        />

        {/* Cancel Subscription Button & Modal - only show if subscription exists */}
        {subscription && subscription.status === "active" && (
          <>
            <s-button
              variant="secondary"
              tone="critical"
              commandFor="cancel-subscription-modal"
              command="--show"
              accessibilityLabel="Cancel subscription"
            >
              Cancel Subscription
            </s-button>

            <s-modal id="cancel-subscription-modal" heading="Cancel your subscription?">
              <s-stack gap="base" direction="block">
                <s-paragraph>
                  You&apos;re currently on the{" "}
                  <s-text type="strong">
                    {subscription.planName === "starter" && "Starter"}
                    {subscription.planName === "growth" && "Growth"}
                    {subscription.planName === "professional" && "Professional"}
                  </s-text>{" "}
                  plan.
                </s-paragraph>

                <s-paragraph>Canceling will remove access to:</s-paragraph>
                <s-stack gap="small-100" direction="block">
                  <s-text> {quota.includedQuota} generations per month</s-text>
                  <s-text> Premium templates library</s-text>
                  <s-text> Section history & versioning</s-text>
                </s-stack>

                <s-banner tone="warning">
                  <s-paragraph>
                    Your subscription will end immediately. This action cannot be undone.
                  </s-paragraph>
                </s-banner>
              </s-stack>

              <s-button
                slot="primary-action"
                variant="primary"
                tone="critical"
                loading={isCancelling || undefined}
                disabled={isCancelling || undefined}
                onClick={() => {
                  const formData = new FormData();
                  formData.append("action", "cancel");
                  submit(formData, { method: "post" });
                }}
              >
                {isCancelling ? "Cancelling..." : "Yes, cancel subscription"}
              </s-button>
              <s-button
                slot="secondary-actions"
                variant="secondary"
                commandFor="cancel-subscription-modal"
                command="--hide"
              >
                Keep my subscription
              </s-button>
            </s-modal>
          </>
        )}
      </s-stack>

      {/* Loading Overlay */}
      {isLoading && (
        <div
          style={{
            position: "fixed",
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            backgroundColor: "rgba(255, 255, 255, 0.9)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 1000,
          }}
        >
          <s-text type="strong">Processing subscription...</s-text>
        </div>
      )}
    </s-page>
  );
}
</file>

<file path="app/routes/app.sections._index.tsx">
import { useState, useCallback, useEffect, useRef } from "react";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import {
  useActionData,
  useLoaderData,
  useSearchParams,
  useSubmit,
  useNavigate,
  useNavigation,
} from "react-router";
import { authenticate } from "../shopify.server";
import { sectionService } from "../services/section.server";
import { SectionsEmptyState } from "../components/sections/SectionsEmptyState";
import { DeleteConfirmModal } from "../components/sections/DeleteConfirmModal";

// View type for tab switching
type ViewType = "all" | "active" | "draft" | "archived";

// Map view tabs to status filters
const viewStatusMap: Record<ViewType, string | undefined> = {
  all: undefined,
  active: "saved",
  draft: "generated",
  archived: undefined, // TODO: implement archived flag in future
};

export async function loader({ request }: LoaderFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;

  const url = new URL(request.url);
  const page = parseInt(url.searchParams.get("page") || "1", 10);
  const view = (url.searchParams.get("view") || "all") as ViewType;
  const statusParam = url.searchParams.get("status") || "";
  const favoritesOnly = url.searchParams.get("favorites") === "true";
  const search = url.searchParams.get("search") || undefined;
  const sort = url.searchParams.get("sort") || "newest";

  // Parse multi-status from comma-separated param
  const statusArray = statusParam.split(",").filter(Boolean);

  // Determine final status filter: explicit param > view-derived
  let status: string | undefined;
  if (statusArray.length === 1) {
    status = statusArray[0];
  } else if (statusArray.length === 0) {
    status = viewStatusMap[view];
  }
  // If multiple statuses selected, we filter client-side (getByShop doesn't support multi-status yet)

  const history = await sectionService.getByShop(shop, {
    page,
    limit: 20,
    status,
    favoritesOnly,
    search,
    sort: sort as "newest" | "oldest",
  });

  return { history, shop, currentView: view, statusFilter: statusArray };
}

export async function action({ request }: ActionFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;
  const formData = await request.formData();
  const actionType = formData.get("action");

  if (actionType === "toggleFavorite") {
    const id = formData.get("id") as string;
    await sectionService.toggleFavorite(id, shop);
    return { success: true, action: "toggleFavorite" };
  }

  if (actionType === "delete") {
    const id = formData.get("id") as string;
    await sectionService.delete(id, shop);
    return {
      success: true,
      action: "delete",
      message: "Section deleted successfully.",
    };
  }

  if (actionType === "bulkDelete") {
    const idsJson = formData.get("ids") as string;
    const ids = JSON.parse(idsJson) as string[];

    // Delete in parallel, max 50 at a time
    const idsToDelete = ids.slice(0, 50);
    await Promise.all(idsToDelete.map((id) => sectionService.delete(id, shop)));

    return {
      success: true,
      action: "bulkDelete",
      message: `${idsToDelete.length} section${idsToDelete.length > 1 ? "s" : ""} deleted successfully.`,
      deletedCount: idsToDelete.length,
    };
  }

  return null;
}

function formatRelativeDate(date: Date | string): string {
  const now = new Date();
  const d = new Date(date);
  const diffMs = now.getTime() - d.getTime();
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffDays === 0) {
    return "Today";
  } else if (diffDays === 1) {
    return "Yesterday";
  } else if (diffDays < 7) {
    return d.toLocaleDateString("en-US", { weekday: "short" });
  } else {
    return d.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  }
}

function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + "...";
}

export default function SectionsPage() {
  const { history } = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const submit = useSubmit();
  const navigate = useNavigate();
  const navigation = useNavigation();
  const [searchParams, setSearchParams] = useSearchParams();

  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [deleteTarget, setDeleteTarget] = useState<"single" | "bulk">("single");
  const [singleDeleteId, setSingleDeleteId] = useState<string | null>(null);

  // Modal ID for commandFor pattern
  const DELETE_MODAL_ID = "delete-confirm-modal";

  // Use any type for ref since Shopify web components have specific types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const tableRef = useRef<any>(null);
  const currentPage = parseInt(searchParams.get("page") || "1", 10);

  const isDeleting =
    navigation.state === "submitting" &&
    (navigation.formData?.get("action") === "delete" ||
      navigation.formData?.get("action") === "bulkDelete");

  const handleToggleFavorite = (id: string) => {
    const formData = new FormData();
    formData.append("action", "toggleFavorite");
    formData.append("id", id);
    submit(formData, { method: "post" });
  };

  const handleDeleteClick = (id: string) => {
    setSingleDeleteId(id);
    setDeleteTarget("single");
  };

  const handleBulkDeleteClick = () => {
    if (selectedIds.size === 0) return;
    setDeleteTarget("bulk");
  };

  const handleConfirmDelete = () => {
    if (deleteTarget === "single" && singleDeleteId) {
      const formData = new FormData();
      formData.append("action", "delete");
      formData.append("id", singleDeleteId);
      submit(formData, { method: "post" });
    } else if (deleteTarget === "bulk") {
      const formData = new FormData();
      formData.append("action", "bulkDelete");
      formData.append("ids", JSON.stringify(Array.from(selectedIds)));
      submit(formData, { method: "post" });
      setSelectedIds(new Set());
    }
    setSingleDeleteId(null);
  };

  // Pagination handlers for s-table
  const handleNextPage = useCallback(() => {
    if (currentPage < history.totalPages) {
      const params = new URLSearchParams(searchParams);
      params.set("page", (currentPage + 1).toString());
      setSearchParams(params);
    }
  }, [currentPage, history.totalPages, searchParams, setSearchParams]);

  const handlePreviousPage = useCallback(() => {
    if (currentPage > 1) {
      const params = new URLSearchParams(searchParams);
      params.set("page", (currentPage - 1).toString());
      setSearchParams(params);
    }
  }, [currentPage, searchParams, setSearchParams]);

  // Attach pagination event listeners to table
  useEffect(() => {
    const table = tableRef.current;
    if (!table) return;

    const nextHandler = () => handleNextPage();
    const prevHandler = () => handlePreviousPage();

    table.addEventListener("nextpage", nextHandler);
    table.addEventListener("previouspage", prevHandler);

    return () => {
      table.removeEventListener("nextpage", nextHandler);
      table.removeEventListener("previouspage", prevHandler);
    };
  }, [handleNextPage, handlePreviousPage]);

  // Show toast for delete success messages
  useEffect(() => {
    if (
      actionData?.success &&
      (actionData.action === "delete" || actionData.action === "bulkDelete")
    ) {
      shopify.toast.show(actionData.message || "Section deleted successfully");
    }
  }, [actionData]);

  return (
    <>
      <s-page heading="Sections" inlineSize="large">
        {/* Primary action button */}
        <s-button
          slot="primary-action"
          variant="primary"
          href="/app/sections/new"
        >
          Create Section
        </s-button>

        {/* Bulk action bar when items selected */}
        {selectedIds.size > 0 && (
          <s-box padding="base" background="subdued" borderRadius="base">
            <s-stack
              direction="inline"
              alignItems="center"
              justifyContent="space-between"
            >
              <s-text>
                <strong>
                  {selectedIds.size} {selectedIds.size === 1 ? "item" : "items"}{" "}
                  selected
                </strong>
              </s-text>
              <s-button
                tone="critical"
                command="--show"
                commandFor={DELETE_MODAL_ID}
                onClick={handleBulkDeleteClick}
              >
                Delete selected
              </s-button>
            </s-stack>
          </s-box>
        )}

        {/* Table section */}
        <s-section padding="none" accessibilityLabel="Sections table">
          {history.items.length > 0 ? (
            <s-table
              ref={tableRef}
              paginate={history.totalPages > 1}
              hasPreviousPage={currentPage > 1}
              hasNextPage={currentPage < history.totalPages}
              loading={navigation.state === "loading"}
            >
              {/* Table header */}
              <s-table-header-row>
                {/* <s-table-header>
                  <s-checkbox
                    accessibilityLabel="Select all sections"
                    checked={allSelected}
                    indeterminate={someSelected}
                    onChange={handleSelectAll}
                  />
                </s-table-header> */}
                <s-table-header listSlot="primary">Name</s-table-header>
                <s-table-header listSlot="inline">Status</s-table-header>
                <s-table-header listSlot="labeled">Theme</s-table-header>
                <s-table-header listSlot="labeled">Created</s-table-header>
                <s-table-header listSlot="labeled">Actions</s-table-header>
              </s-table-header-row>

              {/* Table body */}
              <s-table-body>
                {history.items.map((item) => (
                  <s-table-row key={item.id} clickDelegate={`link-${item.id}`}>
                    {/* <s-table-cell>
                      <s-checkbox
                        id={`checkbox-${item.id}`}
                        accessibilityLabel={`Select section: ${truncateText(item.prompt, 30)}`}
                        checked={selectedIds.has(item.id)}
                        onChange={(e: ShopifyEvent) =>
                          handleSelectOne(item.id, e)
                        }
                      />
                    </s-table-cell> */}
                    <s-table-cell>
                      <s-stack
                        gap="small"
                        direction="inline"
                        alignItems="center"
                      >
                        {item.isFavorite && (
                          <s-badge tone="warning" icon="star-filled">
                            Fav
                          </s-badge>
                        )}
                        <s-text
                          id={`link-${item.id}`}
                          // href={`/app/sections/${item.id}`}
                        >
                          {item.name || truncateText(item.prompt, 50)}
                        </s-text>
                      </s-stack>
                    </s-table-cell>
                    <s-table-cell>
                      {item.status === "saved" ? (
                        <s-badge tone="success">Saved</s-badge>
                      ) : (
                        <s-badge tone="neutral">Draft</s-badge>
                      )}
                    </s-table-cell>
                    <s-table-cell>
                      {item.themeName ? (
                        <s-text>{truncateText(item.themeName, 20)}</s-text>
                      ) : (
                        <s-text color="subdued">-</s-text>
                      )}
                    </s-table-cell>
                    <s-table-cell>
                      <s-text color="subdued">
                        {formatRelativeDate(item.createdAt)}
                      </s-text>
                    </s-table-cell>
                    <s-table-cell>
                      <s-stack
                        gap="small"
                        direction="inline"
                        // justifyContent="end"
                      >
                        <s-button
                          icon={item.isFavorite ? "star-filled" : "star"}
                          variant="tertiary"
                          accessibilityLabel={
                            item.isFavorite
                              ? "Remove from favorites"
                              : "Add to favorites"
                          }
                          onClick={() => handleToggleFavorite(item.id)}
                        />
                        <s-button
                          icon="delete"
                          variant="tertiary"
                          tone="critical"
                          accessibilityLabel="Delete section"
                          command="--show"
                          commandFor={DELETE_MODAL_ID}
                          onClick={() => handleDeleteClick(item.id)}
                        />
                      </s-stack>
                    </s-table-cell>
                  </s-table-row>
                ))}
              </s-table-body>
            </s-table>
          ) : (
            <SectionsEmptyState
              hasFilters={false}
              onClearFilters={() => setSearchParams(new URLSearchParams())}
              onCreateNew={() => navigate("/app/sections/new")}
            />
          )}
        </s-section>

        {/* Results count - Shopify Products style: "1-20 of 50" */}
        {history.total > 0 && (
          <s-box padding="base">
            <s-stack direction="inline" justifyContent="center" gap="base">
              <s-text color="subdued">
                {(history.page - 1) * 20 + 1}-
                {Math.min(history.page * 20, history.total)} of {history.total}
              </s-text>
            </s-stack>
          </s-box>
        )}
      </s-page>

      {/* Delete Confirmation Modal */}
      <DeleteConfirmModal
        id={DELETE_MODAL_ID}
        isBulk={deleteTarget === "bulk"}
        count={deleteTarget === "bulk" ? selectedIds.size : 1}
        isDeleting={isDeleting}
        onConfirm={handleConfirmDelete}
      />
    </>
  );
}
</file>

<file path="app/services/adapters/ai-adapter.ts">
import type { AIServiceInterface } from '../../types/service.types';
import { aiService } from '../ai.server';

/**
 * AI Service Adapter
 * Provides a consistent interface to the AI service
 */
class AIAdapter implements AIServiceInterface {
  private service: AIServiceInterface;

  constructor() {
    this.service = aiService;
  }

  async generateSection(prompt: string): Promise<string> {
    return this.service.generateSection(prompt);
  }

  getMockSection(prompt: string): string {
    return this.service.getMockSection(prompt);
  }
}

export const aiAdapter = new AIAdapter();
</file>

<file path="app/services/billing.server.ts">
/**
 * Billing Service - Shopify App Billing API
 *
 * Handles hybrid subscription model: Base recurring + usage-based overages
 * Uses Shopify GraphQL Admin API for billing operations
 */

import type { AdminApiContext } from "@shopify/shopify-app-react-router/server";
import prisma from "../db.server";
import type {
  CreateSubscriptionInput,
  CreateSubscriptionResult,
  RecordUsageInput,
  RecordUsageResult,
  QuotaCheck,
  ChangeSubscriptionInput,
  PlanTier,
  SubscriptionStatus,
} from "../types/billing";

/**
 * Get plan configuration by tier
 */
export async function getPlanConfig(planName: PlanTier) {
  const config = await prisma.planConfiguration.findUnique({
    where: { planName },
  });

  if (!config) {
    throw new Error(`Plan configuration not found: ${planName}`);
  }

  return config;
}

/**
 * Get all active plans (for pricing page)
 */
export async function getActivePlans() {
  return await prisma.planConfiguration.findMany({
    where: { isActive: true },
    orderBy: { sortOrder: "asc" },
  });
}

/**
 * Create a new subscription via Shopify Billing API
 */
export async function createSubscription(
  admin: AdminApiContext,
  input: CreateSubscriptionInput,
): Promise<CreateSubscriptionResult> {
  const { shop, planName, returnUrl } = input;

  // Cancel existing pending/declined subscriptions before creating new one
  await prisma.subscription.updateMany({
    where: {
      shop,
      status: { in: ["pending", "declined"] }
    },
    data: { status: "cancelled" }
  });

  // Use environment variable for test mode (true = free subscriptions on dev stores)
  const test = process.env.BILLING_TEST_MODE === "true";

  // Get plan configuration
  const plan = await getPlanConfig(planName);

  // Create hybrid subscription (recurring + usage)
  const mutation = `
    mutation appSubscriptionCreate($name: String!, $returnUrl: URL!, $lineItems: [AppSubscriptionLineItemInput!]!, $test: Boolean) {
      appSubscriptionCreate(
        name: $name
        returnUrl: $returnUrl
        lineItems: $lineItems
        test: $test
      ) {
        appSubscription {
          id
          status
          currentPeriodEnd
        }
        confirmationUrl
        userErrors {
          field
          message
        }
      }
    }
  `;

  const response = await admin.graphql(mutation, {
    variables: {
      name: `${plan.displayName} Plan`,
      returnUrl,
      test,
      lineItems: [
        // Base recurring charge
        {
          plan: {
            appRecurringPricingDetails: {
              price: { amount: plan.basePrice, currencyCode: "USD" },
              interval: "EVERY_30_DAYS",
            },
          },
        },
        // Usage-based overage charges
        {
          plan: {
            appUsagePricingDetails: {
              cappedAmount: { amount: plan.cappedAmount, currencyCode: "USD" },
              terms: `${plan.includedQuota} sections included. $${plan.overagePrice.toFixed(2)} per additional section.`,
            },
          },
        },
      ],
    },
  });

  const data = await response.json();
  const result = data.data.appSubscriptionCreate;

  if (result.userErrors && result.userErrors.length > 0) {
    throw new Error(`Failed to create subscription: ${result.userErrors[0].message}`);
  }

  // Save subscription to database (status: pending until approved)
  // Handle null/undefined currentPeriodEnd from pending subscriptions
  const currentPeriodEnd = result.appSubscription.currentPeriodEnd
    ? new Date(result.appSubscription.currentPeriodEnd)
    : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // Default to 30 days from now
  const trialEndsAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000); // 14 days from now

  await prisma.subscription.create({
    data: {
      shop,
      shopifySubId: result.appSubscription.id,
      planName,
      status: "pending" as SubscriptionStatus,
      currentPeriodEnd,
      trialEndsAt,
      basePrice: plan.basePrice,
      includedQuota: plan.includedQuota,
      overagePrice: plan.overagePrice,
      cappedAmount: plan.cappedAmount,
      usageThisCycle: 0,
      overagesThisCycle: 0,
    },
  });

  return {
    confirmationUrl: result.confirmationUrl,
    subscriptionId: result.appSubscription.id,
  };
}

/**
 * Cancel subscription
 */
export async function cancelSubscription(admin: AdminApiContext, shop: string) {
  const subscription = await getSubscription(shop);

  if (!subscription) {
    throw new Error("No active subscription found");
  }

  const mutation = `
    mutation appSubscriptionCancel($id: ID!) {
      appSubscriptionCancel(id: $id) {
        appSubscription {
          id
          status
        }
        userErrors {
          field
          message
        }
      }
    }
  `;

  const response = await admin.graphql(mutation, {
    variables: {
      id: subscription.shopifySubId,
    },
  });

  const data = await response.json();
  const result = data.data.appSubscriptionCancel;

  if (result.userErrors && result.userErrors.length > 0) {
    throw new Error(`Failed to cancel subscription: ${result.userErrors[0].message}`);
  }

  // Update local database - use updateMany since shop is not unique
  await prisma.subscription.updateMany({
    where: {
      shop,
      shopifySubId: subscription.shopifySubId
    },
    data: { status: "cancelled" },
  });
}

/**
 * Record usage charge (for generation overages)
 */
export async function recordUsage(
  admin: AdminApiContext,
  input: RecordUsageInput,
): Promise<RecordUsageResult> {
  const { shop, sectionId, description, amount: customAmount } = input;

  // Get subscription
  const subscription = await getSubscription(shop);

  if (!subscription) {
    throw new Error("No active subscription found");
  }

  // Check if generation is within included quota or overage
  const isOverage = subscription.usageThisCycle >= subscription.includedQuota;
  const amount = customAmount ?? (isOverage ? subscription.overagePrice : 0);

  // Generate idempotency key (prevents duplicate charges)
  const timestamp = Date.now();
  const idempotencyKey = `${shop}-${sectionId}-${timestamp}`;

  // Save usage record locally first
  const usageRecord = await prisma.usageRecord.create({
    data: {
      shop,
      subscriptionId: subscription.id,
      sectionId,
      idempotencyKey,
      amount,
      description,
      billingCycle: subscription.currentPeriodEnd,
      chargeStatus: "pending",
    },
  });

  // If no charge amount (within quota), mark as accepted immediately
  if (amount === 0) {
    await prisma.usageRecord.update({
      where: { id: usageRecord.id },
      data: { chargeStatus: "accepted", sentAt: new Date() },
    });

    // Increment usage counter
    await prisma.subscription.update({
      where: { id: subscription.id },
      data: { usageThisCycle: { increment: 1 } },
    });

    return {
      usageRecordId: usageRecord.id,
      shopifyChargeId: null,
      amount: 0,
      chargeStatus: "accepted",
    };
  }

  // Send usage charge to Shopify (for overages)
  try {
    // Get or fetch usage line item ID
    let usageLineItemId = subscription.usageLineItemId;

    if (!usageLineItemId) {
      // Query Shopify to get the correct usage line item ID
      const query = `
        query getSubscription($id: ID!) {
          appSubscription(id: $id) {
            lineItems {
              id
              plan {
                pricingDetails {
                  __typename
                }
              }
            }
          }
        }
      `;

      const queryResponse = await admin.graphql(query, {
        variables: { id: subscription.shopifySubId }
      });

      const queryData = await queryResponse.json();
      const lineItems = queryData.data.appSubscription.lineItems;

      // Find usage line item (AppUsagePricing type)
      interface LineItem {
        id: string;
        plan: {
          pricingDetails: {
            __typename: string;
          };
        };
      }
      const usageLineItem = lineItems.find(
        (item: LineItem) => item.plan.pricingDetails.__typename === "AppUsagePricing"
      );

      if (!usageLineItem) {
        throw new Error("Usage line item not found in subscription");
      }

      usageLineItemId = usageLineItem.id;

      // Cache the line item ID for future use
      await prisma.subscription.update({
        where: { id: subscription.id },
        data: { usageLineItemId }
      });
    }

    const mutation = `
      mutation appUsageRecordCreate($subscriptionLineItemId: ID!, $price: MoneyInput!, $description: String!, $idempotencyKey: String!) {
        appUsageRecordCreate(
          subscriptionLineItemId: $subscriptionLineItemId
          price: $price
          description: $description
          idempotencyKey: $idempotencyKey
        ) {
          appUsageRecord {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;

    const response = await admin.graphql(mutation, {
      variables: {
        subscriptionLineItemId: usageLineItemId,
        price: { amount, currencyCode: "USD" },
        description,
        idempotencyKey,
      },
    });

    const data = await response.json();
    const result = data.data.appUsageRecordCreate;

    if (result.userErrors && result.userErrors.length > 0) {
      // Update record with error
      await prisma.usageRecord.update({
        where: { id: usageRecord.id },
        data: {
          chargeStatus: "error",
          errorMessage: result.userErrors[0].message,
        },
      });

      throw new Error(`Failed to record usage: ${result.userErrors[0].message}`);
    }

    // Update record with Shopify charge ID
    await prisma.usageRecord.update({
      where: { id: usageRecord.id },
      data: {
        shopifyChargeId: result.appUsageRecord.id,
        chargeStatus: "accepted",
        sentAt: new Date(),
      },
    });

    // Increment usage and overage counters
    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        usageThisCycle: { increment: 1 },
        overagesThisCycle: { increment: 1 },
      },
    });

    return {
      usageRecordId: usageRecord.id,
      shopifyChargeId: result.appUsageRecord.id,
      amount,
      chargeStatus: "accepted",
    };
  } catch (error) {
    // Log error but don't block merchant (graceful degradation)
    console.error("Failed to send usage charge to Shopify:", error);

    await prisma.usageRecord.update({
      where: { id: usageRecord.id },
      data: {
        chargeStatus: "error",
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      },
    });

    // Still increment usage counter locally
    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        usageThisCycle: { increment: 1 },
        overagesThisCycle: isOverage ? { increment: 1 } : undefined,
      },
    });

    return {
      usageRecordId: usageRecord.id,
      shopifyChargeId: null,
      amount,
      chargeStatus: "error",
    };
  }
}

/**
 * Check quota before generation
 */
export async function checkQuota(shop: string): Promise<QuotaCheck> {
  const subscription = await getSubscription(shop);
  console.log("Subscription for quota check:", subscription);
  // No subscription = free tier with limits
  if (!subscription) {
    return {
      hasQuota: true, // Allow 5 free generations
      subscription: null,
      usageThisCycle: 0,
      includedQuota: 5, // Free tier limit
      overagesThisCycle: 0,
      overagesRemaining: 0,
      percentUsed: 0,
      isInTrial: false,
      trialEndsAt: null,
    };
  }

  const isInTrial = subscription.trialEndsAt ? new Date() < subscription.trialEndsAt : false;
  const maxOverages = Math.floor(subscription.cappedAmount / subscription.overagePrice);
  const overagesRemaining = maxOverages - subscription.overagesThisCycle;
  const hasQuota = subscription.usageThisCycle < subscription.includedQuota || overagesRemaining > 0;
  const percentUsed = (subscription.usageThisCycle / (subscription.includedQuota + maxOverages)) * 100;

  return {
    hasQuota,
    subscription,
    usageThisCycle: subscription.usageThisCycle,
    includedQuota: subscription.includedQuota,
    overagesThisCycle: subscription.overagesThisCycle,
    overagesRemaining,
    percentUsed: Math.min(percentUsed, 100),
    isInTrial,
    trialEndsAt: subscription.trialEndsAt,
  };
}

/**
 * Get active subscription for shop (filters by status)
 * Note: Shopify sends uppercase status ("ACTIVE"), but our type uses lowercase
 */
export async function getSubscription(shop: string) {
  return await prisma.subscription.findFirst({
    where: {
      shop,
      status: {
        mode: "insensitive",
        equals: "active"
      }
    },
    orderBy: { createdAt: "desc" }
  });
}

/**
 * Get active subscription (explicit helper)
 */
export async function getActiveSubscription(shop: string) {
  return await getSubscription(shop);
}

/**
 * Update subscription status (called by webhook)
 */
export async function updateSubscriptionStatus(shopifySubId: string, status: SubscriptionStatus, currentPeriodEnd?: Date) {
  const updateData: {
    status: SubscriptionStatus;
    currentPeriodEnd?: Date;
    usageThisCycle?: number;
    overagesThisCycle?: number;
  } = { status };

  if (currentPeriodEnd) {
    updateData.currentPeriodEnd = currentPeriodEnd;
    // Reset usage counters at start of new billing cycle
    updateData.usageThisCycle = 0;
    updateData.overagesThisCycle = 0;
  }

  return await prisma.subscription.update({
    where: { shopifySubId },
    data: updateData,
  });
}

/**
 * Fetch currentPeriodEnd from Shopify GraphQL (webhook fallback)
 */
export async function fetchCurrentPeriodEnd(
  admin: AdminApiContext,
  shopifySubId: string
): Promise<Date | null> {
  try {
    const query = `
      query getSubscription($id: ID!) {
        appSubscription(id: $id) {
          currentPeriodEnd
        }
      }
    `;

    const response = await admin.graphql(query, {
      variables: { id: shopifySubId }
    });

    interface AppSubscriptionResponse {
      errors?: unknown;
      data?: {
        appSubscription?: {
          currentPeriodEnd?: string;
        };
      };
    }
    const data: AppSubscriptionResponse = await response.json();

    if (data.errors || !data.data?.appSubscription?.currentPeriodEnd) {
      console.warn("[Billing] Failed to fetch currentPeriodEnd:", shopifySubId);
      return null;
    }

    return new Date(data.data.appSubscription.currentPeriodEnd);
  } catch (error) {
    console.error("[Billing] Error fetching currentPeriodEnd:", error);
    return null;
  }
}

/**
 * Change subscription plan (upgrade/downgrade)
 */
export async function changeSubscription(
  admin: AdminApiContext,
  input: ChangeSubscriptionInput,
): Promise<CreateSubscriptionResult> {
  const { shop, newPlanName, returnUrl } = input;

  // Cancel existing subscription
  await cancelSubscription(admin, shop);

  // Create new subscription
  return await createSubscription(admin, {
    shop,
    planName: newPlanName,
    returnUrl,
  });
}
</file>

<file path="app/services/section.server.ts">
import prisma from "../db.server";
import type { Section } from "@prisma/client";

/**
 * Extract the "name" field from Liquid schema block
 * Returns null if unable to parse
 */
function extractSchemaName(liquidCode: string): string | null {
  const schemaMatch = liquidCode.match(
    /{% schema %}\s*([\s\S]*?)\s*{% endschema %}/
  );

  if (!schemaMatch?.[1]) {
    return null;
  }

  try {
    const schema = JSON.parse(schemaMatch[1]);
    if (schema.name && typeof schema.name === 'string') {
      return schema.name.trim();
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Generate a default section name from prompt text
 * Used as fallback when schema name extraction fails
 * Truncates to ~50 chars at last word boundary
 */
function generateDefaultName(prompt: string): string {
  const maxLength = 50;
  const trimmed = prompt.trim();
  if (trimmed.length <= maxLength) return trimmed;

  const truncated = trimmed.substring(0, maxLength);
  const lastSpace = truncated.lastIndexOf(" ");

  if (lastSpace > 20) {
    return truncated.substring(0, lastSpace) + "...";
  }
  return truncated + "...";
}

export interface CreateSectionInput {
  shop: string;
  prompt: string;
  code: string;
  name?: string;
  tone?: string;
  style?: string;
  status?: string;
  themeId?: string;
  themeName?: string;
  fileName?: string;
}

export interface UpdateSectionInput {
  name?: string;
  themeId?: string;
  themeName?: string;
  fileName?: string;
  status?: string;
  isFavorite?: boolean;
}

/**
 * Section service for managing AI-generated sections
 */
export const sectionService = {
  /**
   * Create a new section entry after generation
   * Uses schema name from generated code if user doesn't provide a name
   */
  async create(input: CreateSectionInput): Promise<Section> {
    // Priority: user-provided name > schema name > prompt-based fallback
    const schemaName = extractSchemaName(input.code);
    const defaultName = input.name || schemaName || generateDefaultName(input.prompt);

    return prisma.section.create({
      data: {
        shop: input.shop,
        name: defaultName,
        prompt: input.prompt,
        code: input.code,
        tone: input.tone,
        style: input.style,
        status: input.status || "draft",
        themeId: input.themeId,
        themeName: input.themeName,
        fileName: input.fileName,
      },
    });
  },

  /**
   * Update section entry (e.g., when saved to theme)
   */
  async update(id: string, shop: string, input: UpdateSectionInput): Promise<Section | null> {
    // Verify ownership before update
    const existing = await prisma.section.findFirst({
      where: { id, shop },
    });

    if (!existing) return null;

    return prisma.section.update({
      where: { id },
      data: input,
    });
  },

  /**
   * Get paginated sections for a shop
   */
  async getByShop(
    shop: string,
    options: {
      page?: number;
      limit?: number;
      status?: string;
      favoritesOnly?: boolean;
      search?: string;
      sort?: "newest" | "oldest";
    } = {}
  ): Promise<{ items: Section[]; total: number; page: number; totalPages: number }> {
    const { page = 1, limit = 20, status, favoritesOnly, search, sort = "newest" } = options;
    const skip = (page - 1) * limit;

    const where = {
      shop,
      ...(status && { status }),
      ...(favoritesOnly && { isFavorite: true }),
      ...(search && {
        prompt: {
          contains: search,
          mode: "insensitive" as const
        }
      }),
    };

    const [items, total] = await Promise.all([
      prisma.section.findMany({
        where,
        orderBy: { createdAt: sort === "newest" ? "desc" : "asc" },
        skip,
        take: limit,
      }),
      prisma.section.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  },

  /**
   * Get single section by ID
   */
  async getById(id: string, shop: string): Promise<Section | null> {
    return prisma.section.findFirst({
      where: { id, shop },
    });
  },

  /**
   * Toggle favorite status
   */
  async toggleFavorite(id: string, shop: string): Promise<Section | null> {
    const existing = await prisma.section.findFirst({
      where: { id, shop },
    });

    if (!existing) return null;

    return prisma.section.update({
      where: { id },
      data: { isFavorite: !existing.isFavorite },
    });
  },

  /**
   * Delete section entry
   */
  async delete(id: string, shop: string): Promise<boolean> {
    const existing = await prisma.section.findFirst({
      where: { id, shop },
    });

    if (!existing) return false;

    await prisma.section.delete({ where: { id } });
    return true;
  },

  /**
   * Get most recent section for a shop
   */
  async getMostRecent(shop: string): Promise<Section | null> {
    return prisma.section.findFirst({
      where: { shop },
      orderBy: { createdAt: "desc" },
    });
  },
};
</file>

<file path="app/components/generate/AdvancedOptions.tsx">
import { useState } from 'react';

export interface AdvancedOptionsState {
  tone: 'professional' | 'casual' | 'friendly';
  style: 'minimal' | 'bold' | 'elegant';
  // includeSchema is now controlled by sectionType in parent component
  includeSchema: boolean;
}

export interface AdvancedOptionsProps {
  value: AdvancedOptionsState;
  onChange: (options: AdvancedOptionsState) => void;
  disabled?: boolean;
}

/**
 * Collapsible advanced options for generation customization
 * Tone and style settings (includeSchema controlled by SectionTypeSelector)
 */
export function AdvancedOptions({
  value,
  onChange,
  disabled = false
}: AdvancedOptionsProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  const handleToneChange = (e: Event) => {
    const target = e.target as HTMLSelectElement;
    onChange({ ...value, tone: target.value as AdvancedOptionsState['tone'] });
  };

  const handleStyleChange = (e: Event) => {
    const target = e.target as HTMLSelectElement;
    onChange({ ...value, style: target.value as AdvancedOptionsState['style'] });
  };

  return (
    <s-stack gap="base" direction="block">
      {/* Collapsible trigger */}
      <s-button
        onClick={() => setIsExpanded(!isExpanded)}
        variant="tertiary"
        icon={isExpanded ? 'chevron-up' : 'chevron-down'}
        disabled={disabled || undefined}
        accessibilityLabel={isExpanded ? 'Collapse advanced options' : 'Expand advanced options'}
      >
        Advanced Options
      </s-button>

      {/* Collapsible content */}
      {isExpanded && (
        <s-stack gap="base" direction="block">
          {/* Tone select */}
          <s-select
            label="Tone"
            value={value.tone}
            onChange={handleToneChange}
            disabled={disabled || undefined}
            details="Writing style for generated content"
          >
            <option value="professional">Professional</option>
            <option value="casual">Casual</option>
            <option value="friendly">Friendly</option>
          </s-select>

          {/* Style select */}
          <s-select
            label="Style"
            value={value.style}
            onChange={handleStyleChange}
            disabled={disabled || undefined}
            details="Visual aesthetic for the section"
          >
            <option value="minimal">Minimal</option>
            <option value="bold">Bold</option>
            <option value="elegant">Elegant</option>
          </s-select>
        </s-stack>
      )}
    </s-stack>
  );
}
</file>

<file path="app/components/generate/CodePreview.tsx">
import { useState } from 'react';

export interface CodePreviewProps {
  code: string;
  maxHeight?: string;
  fileName?: string;
  onCopy?: () => void;
  onDownload?: () => void;
}

/**
 * Enhanced code preview with copy and download buttons
 * Shows generated Liquid code in a formatted, scrollable container
 * Uses proper Polaris components
 */
export function CodePreview({
  code,
  maxHeight = '400px',
  fileName = 'section',
  onCopy,
  onDownload
}: CodePreviewProps) {
  const [copySuccess, setCopySuccess] = useState(false);

  if (!code) {
    return null;
  }

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopySuccess(true);
      onCopy?.();

      // Reset success state after 2 seconds
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (error) {
      console.error('Failed to copy:', error);
    }
  };

  const handleDownload = () => {
    // Sanitize filename (replace special chars with dashes)
    const sanitizedName = fileName.replace(/[^a-zA-Z0-9-_]/g, '-');

    // Create blob and download link
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${sanitizedName}.liquid`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    onDownload?.();
  };

  return (
    <s-stack gap="base" direction="block">
      {/* Action buttons */}
      <s-stack gap="small" direction="inline" justifyContent="end">
        <s-button
          onClick={handleCopy}
          variant="secondary"
          icon={copySuccess ? 'check' : 'clipboard'}
        >
          {copySuccess ? 'Copied!' : 'Copy'}
        </s-button>

        <s-button
          onClick={handleDownload}
          variant="secondary"
          icon="download"
        >
          Download
        </s-button>
      </s-stack>

      {/* Code display */}
      <s-box
        padding="base"
        background="subdued"
        borderRadius="base"
      >
        <pre
          style={{
            overflowX: 'auto',
            overflowY: 'auto',
            maxHeight,
            margin: 0,
            fontFamily: 'ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace',
            fontSize: '13px',
            lineHeight: '1.6',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word'
          }}
        >
          {code}
        </pre>
      </s-box>
    </s-stack>
  );
}
</file>

<file path="app/components/generate/PromptInput.tsx">
export interface PromptInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  helpText?: string;
  error?: string;
  disabled?: boolean;
  minLength?: number;
  maxLength?: number;
}

/**
 * Prompt input field with character counter and validation
 * Minimum 10 characters, maximum 2000 characters
 * Uses Polaris s-text-area component
 */
export function PromptInput({
  value,
  onChange,
  placeholder = 'A hero section with a background image and centered text...',
  helpText = 'Describe the section you want to generate in natural language',
  error,
  disabled = false,
  minLength = 10,
  maxLength = 2000
}: PromptInputProps) {
  const handleInput = (e: Event) => {
    const target = e.target as HTMLInputElement;
    onChange(target.value);
  };

  // Character counter
  const charCount = value.length;
  const charCountText = `${charCount}/${maxLength} characters`;

  // Validation
  const isValid = charCount === 0 || (charCount >= minLength && charCount <= maxLength);
  const validationError = !isValid
    ? `Prompt must be between ${minLength} and ${maxLength} characters`
    : undefined;

  // Combine help text with character counter
  const displayDetails = !error && !validationError
    ? `${helpText} (${charCountText})`
    : charCountText;

  return (
    <s-text-area
      label="Prompt"
      value={value}
      onInput={handleInput}
      placeholder={placeholder}
      disabled={disabled || undefined}
      rows={6}
      maxLength={maxLength}
      error={error || validationError}
      details={displayDetails}
    />
  );
}
</file>

<file path="app/components/preview/drops/index.ts">
/**
 * Shopify Liquid Drop Classes
 * Provides LiquidJS-compatible drop classes for Shopify objects
 */

export { ShopifyDrop } from './base/ShopifyDrop';
export { ImageDrop } from './ImageDrop';
export { VariantDrop } from './VariantDrop';
export { ProductDrop } from './ProductDrop';
export { CollectionDrop } from './CollectionDrop';
export { CollectionsDrop } from './CollectionsDrop';
export { ArticleDrop } from './ArticleDrop';
export { ShopDrop } from './ShopDrop';
export { BlockDrop } from './BlockDrop';
// Phase 2: Missing Objects and Drops
export { ForloopDrop } from './ForloopDrop';
export { RequestDrop } from './RequestDrop';
export { RoutesDrop } from './RoutesDrop';
export { CartDrop, CartItemDrop } from './CartDrop';
export { CustomerDrop } from './CustomerDrop';
export { PaginateDrop } from './PaginateDrop';
export { ThemeDrop, SettingsDrop } from './ThemeDrop';
// Phase 4: Media Drop
export { MediaDrop } from './MediaDrop';
</file>

<file path="app/components/preview/settings/ImageSetting.tsx">
import { useState, useEffect } from 'react';
import type { SchemaSetting } from '../schema/SchemaTypes';
import { IMAGE_PICKER_MODAL_ID } from './ImagePickerModal';

export interface ImageSettingProps {
  setting: SchemaSetting;
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
  /** Unique identifier for this specific setting instance (e.g., "block-123-image" for block settings) */
  uniqueId?: string;
}

/**
 * ImageSetting - Renders image picker button using Polaris Web Components
 * Uses commandFor/command pattern to open modal declaratively
 */
export function ImageSetting({ setting, value, onChange, disabled, uniqueId }: ImageSettingProps) {
  const [hasError, setHasError] = useState(false);

  // Use uniqueId if provided, otherwise fall back to setting.id
  // This is critical for block settings where multiple blocks may have the same setting.id
  const instanceId = uniqueId ?? setting.id;

  // Reset error state when value changes
  useEffect(() => {
    setHasError(false);
  }, [value]);

  // Dispatch event to tell modal which setting opened it
  const handleOpenClick = () => {
    window.dispatchEvent(new CustomEvent('image-picker-open', {
      detail: { settingId: instanceId }
    }));
  };

  // Listen for image selection events
  useEffect(() => {
    const handleImageSelected = (event: Event) => {
      const customEvent = event as CustomEvent<{ settingId: string; imageUrl: string }>;
      // Only respond if this specific instance is targeted
      if (customEvent.detail.settingId === instanceId) {
        onChange(customEvent.detail.imageUrl);
      }
    };

    window.addEventListener('image-picker-select', handleImageSelected);
    return () => {
      window.removeEventListener('image-picker-select', handleImageSelected);
    };
  }, [instanceId, onChange]);

  const handleClear = () => {
    onChange('');
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <span style={{ fontWeight: 500 }}>{setting.label}</span>

      {/* Image Preview (when value exists) */}
      {value ? (
        <div style={{
          border: '1px solid #e1e3e5',
          borderRadius: '8px',
          padding: '12px',
          backgroundColor: '#f6f6f7',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '8px'
        }}>
          <div style={{
            maxWidth: '120px',
            overflow: 'hidden',
            display: 'flex',
            justifyContent: 'center'
          }}>
            <img
              src={value}
              alt="Preview"
              style={{
                maxWidth: '100%',
                maxHeight: '80px',
                borderRadius: '4px',
                display: hasError ? 'none' : 'block'
              }}
              onError={() => setHasError(true)}
              onLoad={() => setHasError(false)}
            />
          </div>

          {/* Error message when image fails to load */}
          {hasError && (
            <span style={{ fontSize: '12px', color: '#d72c0d' }}>
              Could not load image preview
            </span>
          )}

          <div style={{ display: 'flex', gap: '8px' }}>
            <s-button
              variant="secondary"
              commandFor={IMAGE_PICKER_MODAL_ID}
              command="--show"
              onClick={handleOpenClick}
              disabled={disabled || undefined}
            >
              Change
            </s-button>
            <s-button
              variant="tertiary"
              tone="critical"
              onClick={handleClear}
              disabled={disabled || undefined}
            >
              Remove
            </s-button>
          </div>
        </div>
      ) : (
        /* Empty State with Select Button */
        <div style={{
          border: '2px dashed #c9cccf',
          borderRadius: '8px',
          padding: '16px',
          backgroundColor: '#f6f6f7',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '12px'
        }}>
          <s-button
            variant="secondary"
            commandFor={IMAGE_PICKER_MODAL_ID}
            command="--show"
            onClick={handleOpenClick}
            disabled={disabled || undefined}
          >
            Select
          </s-button>
        </div>
      )}

      {/* Helper text */}
      {setting.info && (
        <span style={{ fontSize: '13px', color: '#6d7175' }}>
          {setting.info}
        </span>
      )}
    </div>
  );
}
</file>

<file path="app/components/preview/settings/SettingField.tsx">
import type { SchemaSetting } from '../schema/SchemaTypes';
import type { SelectedResource } from '../ResourceSelector';
import { TextSetting } from './TextSetting';
import { NumberSetting } from './NumberSetting';
import { SelectSetting } from './SelectSetting';
import { CheckboxSetting } from './CheckboxSetting';
import { ColorSetting } from './ColorSetting';
import { ImageSetting } from './ImageSetting';
import { ProductSetting } from './ProductSetting';
import { CollectionSetting } from './CollectionSetting';
// Phase 01: Resource Pickers
import { ArticleSetting } from './ArticleSetting';
import { BlogSetting } from './BlogSetting';
import { PageSetting } from './PageSetting';
import { LinkListSetting } from './LinkListSetting';
// Phase 02: Media Settings
import { VideoUrlSetting } from './VideoUrlSetting';
import { VideoSetting } from './VideoSetting';
// Phase 03: Design Settings
import { FontPickerSetting } from './FontPickerSetting';
import { TextAlignmentSetting } from './TextAlignmentSetting';
import { RadioSetting } from './RadioSetting';
// Phase 04: Multi-Select Resources
import { CollectionListSetting } from './CollectionListSetting';
import { ProductListSetting } from './ProductListSetting';

export interface SettingFieldProps {
  setting: SchemaSetting;
  value: string | number | boolean;
  onChange: (id: string, value: string | number | boolean) => void;
  disabled?: boolean;
  // Resource setting props (for product/collection types)
  resourceSettings?: Record<string, SelectedResource | null>;
  onResourceSelect?: (settingId: string, resourceId: string | null, resource: SelectedResource | null) => void;
  isLoadingResource?: boolean;
  // Multi-select resource props (for collection_list/product_list types)
  multiResourceSettings?: Record<string, SelectedResource[]>;
  onMultiResourceSelect?: (settingId: string, resources: SelectedResource[]) => void;
  // Block context for unique identification
  blockId?: string;
}

/**
 * Routes setting to appropriate input component based on type
 */
export function SettingField({
  setting,
  value,
  onChange,
  disabled,
  resourceSettings,
  onResourceSelect,
  isLoadingResource,
  multiResourceSettings,
  onMultiResourceSelect,
  blockId
}: SettingFieldProps) {
  const handleChange = (newValue: string | number | boolean) => {
    onChange(setting.id, newValue);
  };

  // Generate unique identifier for settings that need instance-specific identification
  // This is critical for image picker in blocks where multiple blocks may have the same setting.id
  const uniqueId = blockId ? `${blockId}-${setting.id}` : setting.id;

  switch (setting.type) {
    // Basic text inputs
    case 'text':
    case 'textarea':
    case 'richtext':
    case 'inline_richtext':
    case 'url':
    case 'html':
    case 'liquid':
      return (
        <TextSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Number inputs
    case 'number':
    case 'range':
      return (
        <NumberSetting
          setting={setting}
          value={Number(value) || 0}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Select dropdown (auto-converts to segmented for 5 options)
    case 'select':
      return (
        <SelectSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Radio button group
    case 'radio':
      return (
        <RadioSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Checkbox
    case 'checkbox':
      return (
        <CheckboxSetting
          setting={setting}
          value={Boolean(value)}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Color pickers
    case 'color':
    case 'color_background':
      return (
        <ColorSetting
          setting={setting}
          value={String(value || '#000000')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Image picker
    case 'image_picker':
      return (
        <ImageSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
          uniqueId={uniqueId}
        />
      );

    // Video settings
    case 'video':
      return (
        <VideoSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    case 'video_url':
      return (
        <VideoUrlSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Font picker
    case 'font_picker':
      return (
        <FontPickerSetting
          setting={setting}
          value={String(value || 'system-ui')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Text alignment
    case 'text_alignment':
      return (
        <TextAlignmentSetting
          setting={setting}
          value={String(value || 'left')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Single resource pickers
    case 'product':
      return (
        <ProductSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
          selectedResource={resourceSettings?.[setting.id]}
          onResourceSelect={onResourceSelect}
          loading={isLoadingResource}
        />
      );

    case 'collection':
      return (
        <CollectionSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
          selectedResource={resourceSettings?.[setting.id]}
          onResourceSelect={onResourceSelect}
          loading={isLoadingResource}
        />
      );

    // Handle-based resource pickers (no App Bridge support)
    case 'article':
      return (
        <ArticleSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    case 'blog':
      return (
        <BlogSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    case 'page':
      return (
        <PageSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    case 'link_list':
      return (
        <LinkListSetting
          setting={setting}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );

    // Multi-select resource pickers
    case 'collection_list':
      return (
        <CollectionListSetting
          setting={setting}
          value={String(value || '[]')}
          onChange={onChange}
          disabled={disabled}
          selectedResources={multiResourceSettings?.[setting.id] || []}
          onResourcesSelect={onMultiResourceSelect}
          loading={isLoadingResource}
        />
      );

    case 'product_list':
      return (
        <ProductListSetting
          setting={setting}
          value={String(value || '[]')}
          onChange={onChange}
          disabled={disabled}
          selectedResources={multiResourceSettings?.[setting.id] || []}
          onResourcesSelect={onMultiResourceSelect}
          loading={isLoadingResource}
        />
      );

    default:
      // Fallback to text input for unsupported types
      return (
        <TextSetting
          setting={{ ...setting, type: 'text' }}
          value={String(value || '')}
          onChange={handleChange}
          disabled={disabled}
        />
      );
  }
}
</file>

<file path="app/components/preview/utils/buildPreviewContext.ts">
/**
 * Preview Context Builder
 * Builds Liquid template context with Drop classes for Shopify data
 */

import {
  ProductDrop,
  CollectionDrop,
  CollectionsDrop,
  ArticleDrop,
  ShopDrop,
  RequestDrop,
  RoutesDrop,
  CartDrop,
  CustomerDrop,
  ThemeDrop
} from '../drops';
import type { MockProduct, MockCollection, MockArticle, MockShop, MockCart, MockCustomer } from '../mockData/types';

/**
 * Default shop data for preview (used when no real shop data is available)
 */
const defaultShop: MockShop = {
  name: 'Demo Store',
  email: 'hello@demo-store.com',
  domain: 'demo-store.myshopify.com',
  url: 'https://demo-store.myshopify.com',
  currency: 'USD',
  money_format: '${{amount}}',
  description: 'Your one-stop shop for amazing products.'
};

export interface PreviewContextOptions {
  product?: MockProduct | null;
  products?: MockProduct[];
  collection?: MockCollection | null;
  article?: MockArticle | null;
  shop?: MockShop;
  cart?: MockCart | null;
  customer?: MockCustomer | null;
  // Settings-based resources (from schema settings with type: product/collection)
  settingsResources?: Record<string, MockProduct | MockCollection>;
}

export interface PreviewContext {
  product?: ProductDrop;
  collection?: CollectionDrop;
  collections?: CollectionsDrop;
  article?: ArticleDrop;
  shop: ShopDrop;
  request: RequestDrop;
  routes: RoutesDrop;
  theme: ThemeDrop;
  cart?: CartDrop;
  customer: CustomerDrop;
  settingsResourceDrops?: Record<string, ProductDrop | CollectionDrop>;
  [key: string]: unknown;
}

/**
 * Build Drop classes for settings-based resources
 * Wraps MockProduct/MockCollection in appropriate Drop classes
 */
function buildSettingsResourceDrops(
  settingsResources: Record<string, MockProduct | MockCollection>
): Record<string, ProductDrop | CollectionDrop> {
  const drops: Record<string, ProductDrop | CollectionDrop> = {};

  for (const [settingId, resource] of Object.entries(settingsResources)) {
    // Determine if resource is product or collection based on shape
    if ('variants' in resource || 'vendor' in resource || 'product_type' in resource) {
      // It's a product
      drops[settingId] = new ProductDrop(resource as MockProduct);
    } else {
      // It's a collection
      drops[settingId] = new CollectionDrop(resource as MockCollection);
    }
  }

  return drops;
}

/**
 * Build preview context with Drop classes
 * Drop classes provide controlled access to object properties in Liquid templates
 */
export function buildPreviewContext(options: PreviewContextOptions): PreviewContext {
  const { product, products = [], collection, article, shop, cart, customer, settingsResources = {} } = options;

  // Build settings resource drops
  const settingsResourceDrops = Object.keys(settingsResources).length > 0
    ? buildSettingsResourceDrops(settingsResources)
    : undefined;

  // Determine page type for request context
  const pageType = product ? 'product' : collection ? 'collection' : article ? 'article' : 'index';

  // Build context with Drop classes
  const context: PreviewContext = {
    shop: shop ? new ShopDrop(shop) : new ShopDrop(defaultShop),
    request: new RequestDrop({
      design_mode: true,
      page_type: pageType,
      path: '/'
    }),
    routes: new RoutesDrop(),
    theme: new ThemeDrop(),
    customer: new CustomerDrop(customer ?? null)
  };

  // Add cart if provided
  if (cart) {
    context.cart = new CartDrop(cart);
  }

  // Add product if provided
  if (product) {
    context.product = new ProductDrop(product);
  } else if (products.length > 0) {
    // Use first product from multiple selection as the "product" context
    context.product = new ProductDrop(products[0]);
  }

  // Handle collection and collections global
  let collectionData: MockCollection | null = null;

  if (collection) {
    // If we have selected products, merge them into the collection
    if (products.length > 0) {
      collectionData = {
        ...collection,
        products: products,
        products_count: products.length
      };
    } else {
      collectionData = collection;
    }
  } else if (products.length > 0) {
    // Create a synthetic collection from selected products
    collectionData = {
      id: 1,
      title: 'Selected Products',
      handle: 'selected-products',
      description: 'Products selected for preview',
      url: '/collections/selected-products',
      products_count: products.length,
      products: products,
      image: null
    };
  }

  if (collectionData) {
    context.collection = new CollectionDrop(collectionData);
    // Provide collections global for templates using collections['handle'] syntax
    context.collections = new CollectionsDrop(collectionData);
  }

  if (article) {
    context.article = new ArticleDrop(article);
  }

  // Settings-based resources are always included
  if (settingsResourceDrops) {
    context.settingsResourceDrops = settingsResourceDrops;
  }

  return context;
}

/**
 * Extract resource summary for UI display
 */
export function getContextResourceSummary(context: PreviewContext): string {
  const resources: string[] = [];

  if (context.product) {
    resources.push(`Product: ${context.product.title}`);
  }
  if (context.collection) {
    resources.push(`Collection: ${context.collection.title}`);
  }
  if (context.article) {
    resources.push(`Article: ${context.article.title}`);
  }

  return resources.length > 0
    ? resources.join(', ')
    : 'Using default shop data';
}

/**
 * Check if context has any selected resources
 */
export function hasSelectedResources(context: PreviewContext): boolean {
  return !!(context.product || context.collection || context.article);
}
</file>

<file path="app/components/preview/PreviewFrame.tsx">
import { useRef, useEffect, useState } from 'react';
import type { DeviceSize } from './types';

export interface PreviewFrameProps {
  deviceSize: DeviceSize;
  onLoad?: (iframe: HTMLIFrameElement) => void;
}

// Fixed widths for each device mode
const DEVICE_WIDTHS: Record<DeviceSize, number> = {
  mobile: 375,
  tablet: 768,
  desktop: 1200
};

// Standalone HTML template for iframe
// Note: Using srcDoc means the iframe has null origin, so we accept messages from any origin
// but validate the message structure instead
const IFRAME_HTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style id="preview-styles"></style>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.5;
      color: #1a1a1a;
    }
    img { max-width: 100%; height: auto; }
    img.placeholder-image {
      background: #f0f0f0;
      border: 1px dashed #ccc;
      object-fit: contain;
    }
    .preview-error {
      color: #d72c0d;
      padding: 16px;
      background: #fff4f4;
      border-radius: 8px;
      border: 1px solid #ffd2cc;
    }
    .preview-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      color: #6d7175;
    }
  </style>
</head>
<body>
  <div id="preview-content">
    <div class="preview-loading">Loading preview...</div>
  </div>
  <script>
    // For srcDoc iframes, we validate message structure instead of origin
    // since srcDoc iframes have null origin
    window.addEventListener('message', (event) => {
      // Validate message structure for security
      if (!event.data || typeof event.data !== 'object') return;
      const { type, html, css, error } = event.data;
      if (!type || typeof type !== 'string') return;

      if (type === 'RENDER') {
        document.getElementById('preview-styles').textContent = css || '';
        // Wrap HTML in shopify-section wrapper to match CSS selectors like #shopify-section-{{ section.id }}
        document.getElementById('preview-content').innerHTML =
          '<div id="shopify-section-preview-section">' + (html || '') + '</div>';
        // Notify parent of new height
        setTimeout(() => {
          window.parent.postMessage(
            { type: 'RESIZE', height: document.body.scrollHeight },
            '*'
          );
        }, 50);
      } else if (type === 'RENDER_ERROR') {
        document.getElementById('preview-content').innerHTML =
          '<div class="preview-error">' + (error || 'Render error') + '</div>';
      }
    });

    // Placeholder image as inline SVG data URI
    const PLACEHOLDER_SVG = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="200" viewBox="0 0 300 200"><rect fill="#f0f0f0" width="300" height="200"/><rect fill="#e0e0e0" x="110" y="60" width="80" height="80" rx="4"/><circle fill="#ccc" cx="130" cy="85" r="8"/><polygon fill="#ccc" points="120,130 150,95 180,130"/><polygon fill="#d0d0d0" points="140,130 160,110 180,130"/></svg>');

    // Handle broken images by replacing with placeholder
    function handleImageError(img) {
      if (!img.dataset.placeholderApplied) {
        img.dataset.placeholderApplied = 'true';
        img.src = PLACEHOLDER_SVG;
        img.classList.add('placeholder-image');
      }
    }

    // Apply error handlers to all images after content updates
    const observer = new MutationObserver(function() {
      document.querySelectorAll('img:not([data-error-handled])').forEach(function(img) {
        img.dataset.errorHandled = 'true';
        img.onerror = function() { handleImageError(this); };
        // Also check if image already failed to load
        if (img.complete && img.naturalWidth === 0 && img.src && !img.src.startsWith('data:')) {
          handleImageError(img);
        }
      });

      // Handle elements with data-block-type="image" that don't have actual images
      document.querySelectorAll('[data-block-type="image"]:not([data-placeholder-handled])').forEach(function(el) {
        el.dataset.placeholderHandled = 'true';
        // If element has no img child or only contains text like "image"
        var hasImg = el.querySelector('img');
        var textContent = el.textContent.trim().toLowerCase();
        if (!hasImg && (textContent === 'image' || textContent === 'placeholder' || textContent === '')) {
          el.innerHTML = '<img src="' + PLACEHOLDER_SVG + '" alt="Image placeholder" class="placeholder-image" style="width:100%;height:auto;min-height:100px;display:block;" />';
        }
      });
    });
    observer.observe(document.getElementById('preview-content'), { childList: true, subtree: true });
  </script>
</body>
</html>
`;

/**
 * Sandboxed iframe wrapper for preview rendering
 * Uses postMessage for parent-child communication
 * Desktop mode uses CSS transform scaling to maintain exact layout on small screens
 */
export function PreviewFrame({ deviceSize, onLoad }: PreviewFrameProps) {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState<number>(0);
  const [iframeHeight, setIframeHeight] = useState<number>(400);

  // Measure container width for scaling calculation
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setContainerWidth(entry.contentRect.width);
      }
    });

    resizeObserver.observe(container);
    return () => resizeObserver.disconnect();
  }, []);

  // Listen for height updates from iframe
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'RESIZE' && typeof event.data.height === 'number') {
        setIframeHeight(Math.max(300, event.data.height));
      }
    };
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []);

  useEffect(() => {
    if (iframeRef.current && onLoad) {
      const iframe = iframeRef.current;
      iframe.onload = () => onLoad(iframe);
    }
  }, [onLoad]);

  // Get the target width for the device
  const targetWidth = DEVICE_WIDTHS[deviceSize];

  // Calculate scale: only scale down if container is smaller than target width
  const needsScaling = containerWidth > 0 && containerWidth < targetWidth;
  const scale = needsScaling ? containerWidth / targetWidth : 1;

  // Calculate the visual height after scaling
  const scaledHeight = iframeHeight * scale;

  return (
    <div
      ref={containerRef}
      style={{
        backgroundColor: '#f6f6f7',
        borderRadius: '8px',
        padding: '16px',
        // Container height matches the scaled content
        height: `${scaledHeight + 32}px`,
        position: 'relative',
        overflow: 'hidden'
      }}
    >
      {/*
        Wrapper div that renders at full target width.
        Uses absolute positioning so it's not constrained by parent width.
        Transform origin at top-left for predictable scaling behavior.
      */}
      <div
        style={{
          position: 'absolute',
          top: '16px',
          left: '50%',
          width: `${targetWidth}px`,
          marginLeft: `-${targetWidth / 2}px`, // Center the element
          transform: `scale(${scale})`,
          transformOrigin: 'top center'
        }}
      >
        <iframe
          ref={iframeRef}
          srcDoc={IFRAME_HTML}
          sandbox="allow-scripts allow-same-origin"
          style={{
            width: '100%',
            height: `${iframeHeight}px`,
            border: '1px solid #e1e3e5',
            borderRadius: '8px',
            backgroundColor: '#fff',
            display: 'block'
          }}
          title="Section Preview"
          aria-label="Live preview of generated section"
        />
      </div>
    </div>
  );
}
</file>

<file path="app/components/preview/PreviewToolbar.tsx">
import { useState, useMemo } from 'react';
import type { DeviceSize } from './types';
import type { ResourceNeeds } from './hooks/useResourceDetection';
import type { SelectedResource } from './ResourceSelector';
import type { SchemaSetting } from './schema/SchemaTypes';
import { ResourceSelector } from './ResourceSelector';

export interface PreviewToolbarProps {
  deviceSize: DeviceSize;
  onDeviceSizeChange: (size: DeviceSize) => void;
  onRefresh: () => void;
  isRendering?: boolean;
  renderedHtml?: string;
  // Resource data props
  selectedProduct?: SelectedResource | null;
  selectedProducts?: SelectedResource[];
  selectedCollection?: SelectedResource | null;
  onProductSelect?: (productId: string | null, resource: SelectedResource | null) => void;
  onProductsSelect?: (resources: SelectedResource[]) => void;
  onCollectionSelect?: (collectionId: string | null, resource: SelectedResource | null) => void;
  resourceNeeds?: ResourceNeeds;
  isLoadingResource?: boolean;
  // Schema settings (to check if resource pickers are in settings panel)
  schemaSettings?: SchemaSetting[];
}

/**
 * Preview toolbar with device selector, resource picker, and refresh button
 */
export function PreviewToolbar({
  deviceSize,
  onDeviceSizeChange,
  onRefresh,
  isRendering,
  renderedHtml,
  selectedProduct,
  selectedProducts = [],
  selectedCollection,
  onProductSelect,
  onProductsSelect,
  onCollectionSelect,
  resourceNeeds,
  isLoadingResource,
  schemaSettings = []
}: PreviewToolbarProps) {
  const [copied, setCopied] = useState(false);

  // Check if schema already has resource settings (so we can hide toolbar pickers)
  const hasSchemaProductSetting = useMemo(
    () => schemaSettings.some(s => s.type === 'product'),
    [schemaSettings]
  );
  const hasSchemaCollectionSetting = useMemo(
    () => schemaSettings.some(s => s.type === 'collection'),
    [schemaSettings]
  );

  const handleCopy = async () => {
    if (!renderedHtml) return;
    try {
      await navigator.clipboard.writeText(renderedHtml);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Copy failed:', err);
    }
  };

  // Check if section needs any resources
  const hasResourceNeeds = resourceNeeds && (
    resourceNeeds.needsProduct ||
    resourceNeeds.needsCollection ||
    resourceNeeds.needsArticle
  );

  return (
    <s-stack gap="base" direction="block">
      {/* Main toolbar row */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        flexWrap: 'wrap',
        gap: '12px'
      }}>
        {/* Device size selector */}
        <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
          <s-button
            variant={deviceSize === 'mobile' ? 'primary' : 'tertiary'}
            onClick={() => onDeviceSizeChange('mobile')}
            aria-pressed={deviceSize === 'mobile' ? 'true' : 'false'}
            aria-label="Preview on mobile device"
          >
            Mobile
          </s-button>
          <s-button
            variant={deviceSize === 'tablet' ? 'primary' : 'tertiary'}
            onClick={() => onDeviceSizeChange('tablet')}
            aria-pressed={deviceSize === 'tablet' ? 'true' : 'false'}
            aria-label="Preview on tablet device"
          >
            Tablet
          </s-button>
          <s-button
            variant={deviceSize === 'desktop' ? 'primary' : 'tertiary'}
            onClick={() => onDeviceSizeChange('desktop')}
            aria-pressed={deviceSize === 'desktop' ? 'true' : 'false'}
            aria-label="Preview on desktop device"
          >
            Desktop
          </s-button>
        </div>

        <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
          {/* Copy HTML button */}
          {renderedHtml && (
            <s-button
              variant="tertiary"
              onClick={handleCopy}
            >
              {copied ? 'Copied!' : 'Copy HTML'}
            </s-button>
          )}

          {/* Refresh button */}
          <s-button
            variant="tertiary"
            onClick={onRefresh}
            loading={isRendering || undefined}
          >
            Refresh
          </s-button>
        </div>
      </div>

      {/* Resource selectors row (shown if section uses resources) */}
      {hasResourceNeeds && (
        <div style={{
          display: 'flex',
          alignItems: 'center',
          gap: '16px',
          padding: '12px',
          backgroundColor: '#f8f9fa',
          borderRadius: '8px',
          border: '1px solid #e5e7eb',
          flexWrap: 'wrap'
        }}>
          <div style={{ display: 'flex', gap: '12px', alignItems: 'center', flexWrap: 'wrap' }}>
            {/* Only show product picker if schema doesn't have product setting */}
            {resourceNeeds?.needsProduct && onProductsSelect && !hasSchemaProductSetting && (
              <ResourceSelector
                resourceType="product"
                onSelect={onProductSelect || (() => {})}
                onSelectMultiple={onProductsSelect}
                selectedResource={selectedProduct}
                selectedResources={selectedProducts}
                multiple={true}
                disabled={isLoadingResource}
                loading={isLoadingResource}
              />
            )}

            {/* Only show collection picker if schema doesn't have collection setting */}
            {resourceNeeds?.needsCollection && onCollectionSelect && !hasSchemaCollectionSetting && (
              <ResourceSelector
                resourceType="collection"
                onSelect={onCollectionSelect}
                selectedResource={selectedCollection}
                disabled={isLoadingResource}
                loading={isLoadingResource}
              />
            )}

            {/* Show hint when pickers are in settings panel */}
            {(hasSchemaProductSetting || hasSchemaCollectionSetting) && (
              <span style={{ fontSize: '13px', color: '#6d7175', fontStyle: 'italic' }}>
                Resource pickers available in Settings panel
              </span>
            )}
          </div>

          {/* Loading indicator */}
          {isLoadingResource && (
            <span style={{ color: '#6d7175', fontSize: '14px' }}>
              Loading...
            </span>
          )}

          {/* Hint when no selection */}
          {selectedProducts.length === 0 && !selectedCollection && !isLoadingResource && (
            <span style={{ color: '#6d7175', fontSize: '13px', fontStyle: 'italic' }}>
              Select products or collection for preview
            </span>
          )}
        </div>
      )}
    </s-stack>
  );
}
</file>

<file path="app/components/shared/Button.tsx">
import type { ReactNode } from 'react';

export interface ButtonProps {
  children: ReactNode;
  variant?: 'primary' | 'secondary' | 'plain' | 'destructive';
  loading?: boolean;
  disabled?: boolean;
  onClick?: () => void;
  submit?: boolean;
  fullWidth?: boolean;
}

/**
 * Wrapper for Polaris s-button web component
 * Provides type-safe props and consistent button styling
 */
export function Button({
  children,
  variant = 'secondary',
  loading = false,
  disabled = false,
  onClick,
  submit = false,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fullWidth = false
}: ButtonProps) {
  // Map "plain" variant to "tertiary" for Polaris web components
  const mappedVariant = variant === 'plain' ? 'tertiary' : variant;
  // Map "destructive" variant to secondary with critical tone
  const tone = variant === 'destructive' ? 'critical' : undefined;

  // Note: fullWidth not directly supported by s-button, use wrapper if needed
  return (
    <s-button
      variant={mappedVariant as 'primary' | 'secondary' | 'tertiary'}
      tone={tone}
      loading={loading || undefined}
      disabled={disabled}
      onClick={onClick}
      type={submit ? 'submit' : 'button'}
    >
      {children}
    </s-button>
  );
}
</file>

<file path="app/routes/app._index.tsx">
import type {
  ActionFunctionArgs,
  HeadersFunction,
  LoaderFunctionArgs,
} from "react-router";
import { useLoaderData, useNavigate } from "react-router";
import { authenticate } from "../shopify.server";
import { boundary } from "@shopify/shopify-app-react-router/server";
import prisma from "../db.server";
import { settingsService } from "../services/settings.server";
import { SetupGuide, FeatureNav, QuickStats } from "../components/home";

// Helper to get start of current week (Monday)
function getStartOfWeek(): Date {
  const now = new Date();
  const dayOfWeek = now.getDay();
  const diff = now.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
  const startOfWeek = new Date(now.setDate(diff));
  startOfWeek.setHours(0, 0, 0, 0);
  return startOfWeek;
}

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;

  // Fetch stats and onboarding state in parallel
  const [historyCount, templateCount, weeklyCount, shopSettings] =
    await Promise.all([
      prisma.section.count({ where: { shop } }),
      prisma.sectionTemplate.count({ where: { shop } }),
      prisma.section.count({
        where: {
          shop,
          createdAt: { gte: getStartOfWeek() },
        },
      }),
      settingsService.get(shop),
    ]);

  return {
    stats: {
      sectionsGenerated: historyCount,
      templatesSaved: templateCount,
      generationsThisWeek: weeklyCount,
    },
    onboarding: {
      hasGeneratedSection: historyCount > 0,
      hasSavedTemplate: templateCount > 0,
      hasViewedHistory: shopSettings?.hasViewedHistory ?? false,
      isDismissed: shopSettings?.onboardingDismissed ?? false,
    },
  };
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const { session } = await authenticate.admin(request);
  const formData = await request.formData();
  const intent = formData.get("intent");

  if (intent === "dismissOnboarding") {
    await settingsService.dismissOnboarding(session.shop);
  }

  return { success: true };
};

export default function Homepage() {
  const { stats, onboarding } = useLoaderData<typeof loader>();
  const navigate = useNavigate();

  return (
    <s-page heading="AI Section Generator" inlineSize="base">
      <s-button
        slot="primary-action"
        variant="primary"
        onClick={() => navigate("/app/sections/new")}
      >
        Generate Section
      </s-button>

      <s-stack gap="large" direction="block">
        <SetupGuide onboarding={onboarding} />
        <FeatureNav />
      </s-stack>

      <s-section slot="aside" heading="Activity">
        <QuickStats stats={stats} />
      </s-section>
    </s-page>
  );
}

export const headers: HeadersFunction = (headersArgs) => {
  return boundary.headers(headersArgs);
};
</file>

<file path="app/routes/app.sections.$id.tsx">
import { useState, useEffect } from "react";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import {
  useActionData,
  useLoaderData,
  useNavigation,
  useSubmit,
  useNavigate,
  data,
} from "react-router";
import { authenticate } from "../shopify.server";
import { aiAdapter } from "../services/adapters/ai-adapter";
import { themeAdapter } from "../services/adapters/theme-adapter";
import { sectionService } from "../services/section.server";
import { templateService } from "../services/template.server";
import prisma from "../db.server";
import {
  canGenerate,
  trackGeneration,
} from "../services/usage-tracking.server";
import type { GenerateActionData, SaveActionData, Theme } from "../types";

import { GenerateLayout } from "../components/generate/GenerateLayout";
import { GenerateInputColumn } from "../components/generate/GenerateInputColumn";
import { GeneratePreviewColumn } from "../components/generate/GeneratePreviewColumn";
import { SaveTemplateModal } from "../components/generate/SaveTemplateModal";
import type { AdvancedOptionsState } from "../components/generate/AdvancedOptions";
import type { SectionType } from "../components/generate/SectionTypeSelector";
import { DeleteConfirmModal } from "../components/sections/DeleteConfirmModal";

export async function loader({ request, params }: LoaderFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;
  const { id } = params;

  if (!id) {
    throw data({ message: "Section ID is required" }, { status: 400 });
  }

  const generation = await sectionService.getById(id, shop);

  if (!generation) {
    throw data({ message: "Section not found" }, { status: 404 });
  }

  const themes = await themeAdapter.getThemes(request);

  return { generation, themes };
}

export async function action({ request, params }: ActionFunctionArgs) {
  const { session, admin } = await authenticate.admin(request);
  const shop = session.shop;
  const { id } = params;
  const formData = await request.formData();
  const actionType = formData.get("action");

  if (actionType === "generate") {
    const prompt = formData.get("prompt") as string;
    const name = formData.get("name") as string | null;
    const tone = formData.get("tone") as string | null;
    const style = formData.get("style") as string | null;

    // Check quota before generation
    const quotaCheck = await canGenerate(shop);

    if (!quotaCheck.allowed) {
      return {
        error: quotaCheck.reason || "Generation limit reached",
        quota: quotaCheck.quota,
      };
    }

    const code = await aiAdapter.generateSection(prompt);

    // Update existing section with new code (edit page regenerate updates in-place)
    if (id) {
      await sectionService.update(id, shop, {
        name: name || undefined,
      });

      // Track usage
      trackGeneration(admin, shop, id, prompt).catch((error) => {
        console.error("Failed to track generation:", error);
      });
    }

    return {
      code,
      prompt,
      name: name || undefined,
      tone: tone || undefined,
      style: style || undefined,
      quota: quotaCheck.quota,
      regenerated: true,
    } satisfies GenerateActionData & { regenerated?: boolean };
  }

  if (actionType === "save") {
    const themeId = formData.get("themeId") as string;
    const fileName = formData.get("fileName") as string;
    const content = formData.get("content") as string;
    const prompt = formData.get("prompt") as string;
    const sectionName = formData.get("sectionName") as string | null;
    const themeName = formData.get("themeName") as string | null;

    try {
      const result = await themeAdapter.createSection(
        request,
        themeId,
        fileName,
        content,
        sectionName || undefined
      );

      // Update existing section entry with new code and save info
      if (id) {
        await sectionService.update(id, shop, {
          themeId,
          themeName: themeName || undefined,
          fileName,
          status: "saved",
          name: sectionName || undefined,
        });

        // Also update the code if it was regenerated
        // We need to update the code separately since update() doesn't handle it
        await prisma.section.update({
          where: { id },
          data: {
            code: content,
            prompt: prompt,
          },
        });
      }

      return {
        success: true,
        message: `Section saved successfully to ${result?.filename || fileName}!`,
        sectionId: id,
      } satisfies SaveActionData;
    } catch (error) {
      console.error("Failed to save section:", error);
      return {
        success: false,
        message:
          error instanceof Error
            ? error.message
            : "Failed to save section. Please try again.",
      } satisfies SaveActionData;
    }
  }

  if (actionType === "saveDraft") {
    const content = formData.get("content") as string;
    const prompt = formData.get("prompt") as string;
    const sectionName = formData.get("sectionName") as string | null;

    try {
      // Update existing section with new code (keep as draft)
      if (id) {
        await sectionService.update(id, shop, {
          name: sectionName || undefined,
          status: "draft",
        });

        await prisma.section.update({
          where: { id },
          data: {
            code: content,
            prompt: prompt,
          },
        });
      }

      return {
        success: true,
        message: "Draft saved!",
        sectionId: id,
      } satisfies SaveActionData;
    } catch (error) {
      console.error("Failed to save draft:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Failed to save draft.",
      } satisfies SaveActionData;
    }
  }

  if (actionType === "saveAsTemplate") {
    const title = formData.get("title") as string;
    const description = formData.get("description") as string;
    const category = formData.get("category") as string;
    const icon = formData.get("icon") as string;
    const prompt = formData.get("prompt") as string;
    const code = formData.get("code") as string | null;

    try {
      await templateService.create({
        shop,
        title,
        description,
        category,
        icon,
        prompt,
        code: code || undefined,
      });

      return {
        success: true,
        message: "Template saved successfully!",
        templateSaved: true,
      };
    } catch (error) {
      console.error("Failed to save template:", error);
      return {
        success: false,
        message:
          error instanceof Error
            ? error.message
            : "Failed to save template. Please try again.",
      };
    }
  }

  if (actionType === "updateName") {
    const name = formData.get("name") as string;
    if (!id) {
      return { success: false, message: "Section ID is required" };
    }

    await sectionService.update(id, shop, { name });
    return {
      success: true,
      nameUpdated: true,
      message: "Section name updated",
    };
  }

  if (actionType === "delete") {
    if (!id) {
      return { success: false, message: "Section ID is required" };
    }

    const deleted = await sectionService.delete(id, shop);

    if (!deleted) {
      return { success: false, message: "Failed to delete section" };
    }

    return {
      success: true,
      deleted: true,
      message: "Section deleted successfully",
    };
  }

  return null;
}

function formatDate(date: Date | string): string {
  return new Date(date).toLocaleDateString("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function SectionEditPage() {
  const { generation, themes } = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const navigation = useNavigation();
  const submit = useSubmit();
  const navigate = useNavigate();

  // Initialize state from loaded generation
  const [prompt, setPrompt] = useState(generation.prompt);
  const [sectionName, setSectionName] = useState(generation.name || "");
  const [generatedCode, setGeneratedCode] = useState(generation.code);

  // Section type state (customizable vs production-ready) - default based on existing section
  const [sectionType, setSectionType] = useState<SectionType>('customizable');

  // Advanced options state
  const [advancedOptions, setAdvancedOptions] = useState<AdvancedOptionsState>({
    tone: (generation.tone as AdvancedOptionsState["tone"]) || "professional",
    style: (generation.style as AdvancedOptionsState["style"]) || "minimal",
    includeSchema: true,
  });

  // Auto-sync includeSchema with sectionType
  useEffect(() => {
    setAdvancedOptions(prev => ({
      ...prev,
      includeSchema: sectionType === 'customizable'
    }));
  }, [sectionType]);

  // Theme selection - use original theme if available, else active theme, else first theme
  const originalTheme = themes.find((t: Theme) => t.id === generation.themeId);
  const activeTheme = themes.find((theme: Theme) => theme.role === "MAIN");
  const [selectedTheme, setSelectedTheme] = useState(
    originalTheme?.id || activeTheme?.id || themes[0]?.id || "",
  );

  const [fileName, setFileName] = useState(generation.fileName || "ai-section");
  const [showSaveTemplateModal, setShowSaveTemplateModal] = useState(false);

  // Modal ID for commandFor pattern
  const DELETE_MODAL_ID = "delete-section-modal";

  const isLoading = navigation.state === "submitting";
  const isGenerating =
    isLoading && navigation.formData?.get("action") === "generate";
  const isSavingDraft = isLoading && navigation.formData?.get("action") === "saveDraft";
  const isPublishing = isLoading && navigation.formData?.get("action") === "save";
  const isSaving = isSavingDraft || isPublishing;
  const isDeleting =
    isLoading && navigation.formData?.get("action") === "delete";

  // Update state when action data changes (after regeneration)
  useEffect(() => {
    if (actionData?.code && actionData.code !== generatedCode) {
      setGeneratedCode(actionData.code);
    }
  }, [actionData?.code, generatedCode]);

  // Handle delete success - show toast and navigate back to sections list
  useEffect(() => {
    if (actionData?.deleted) {
      shopify.toast.show(actionData.message || "Section deleted successfully");
      navigate("/app/sections");
    }
  }, [actionData?.deleted, actionData?.message, navigate]);

  // Close modal on successful template save
  useEffect(() => {
    if (actionData?.templateSaved) {
      setShowSaveTemplateModal(false);
    }
  }, [actionData?.templateSaved]);

  // Show toast on successful save (draft or publish)
  useEffect(() => {
    if (actionData?.success && !actionData?.templateSaved && !actionData?.deleted && !actionData?.nameUpdated) {
      shopify.toast.show("Section saved");
    }
  }, [actionData?.success, actionData?.templateSaved, actionData?.deleted, actionData?.nameUpdated]);

  // Get theme name for success message
  const selectedThemeName =
    themes.find((t: Theme) => t.id === selectedTheme)?.name || "theme";

  // Handlers
  const handleGenerate = () => {
    if (!prompt.trim()) return;
    const formData = new FormData();
    formData.append("action", "generate");
    formData.append("prompt", prompt);
    formData.append("name", sectionName);
    formData.append("tone", advancedOptions.tone);
    formData.append("style", advancedOptions.style);
    formData.append("sectionType", sectionType);
    submit(formData, { method: "post" });
  };

  // Save name on blur
  const handleNameBlur = () => {
    if (sectionName !== (generation.name || "")) {
      const formData = new FormData();
      formData.append("action", "updateName");
      formData.append("name", sectionName);
      submit(formData, { method: "post" });
    }
  };

  const handleSaveDraft = () => {
    const formData = new FormData();
    formData.append("action", "saveDraft");
    formData.append("content", generatedCode);
    formData.append("prompt", prompt);
    formData.append("sectionName", sectionName);
    submit(formData, { method: "post" });
  };

  const handlePublish = () => {
    const formData = new FormData();
    formData.append("action", "save");
    formData.append("themeId", selectedTheme);
    formData.append("fileName", fileName);
    formData.append("content", generatedCode);
    formData.append("prompt", prompt);
    formData.append("themeName", selectedThemeName);
    formData.append("sectionName", sectionName);
    submit(formData, { method: "post" });
  };

  const handleDelete = () => {
    const formData = new FormData();
    formData.append("action", "delete");
    submit(formData, { method: "post" });
  };

  const canSave = Boolean(generatedCode);
  const canPublish = Boolean(generatedCode && fileName && selectedTheme);

  const handleSaveAsTemplate = (templateData: {
    title: string;
    description: string;
    category: string;
    icon: string;
    prompt: string;
  }) => {
    const formData = new FormData();
    formData.append("action", "saveAsTemplate");
    formData.append("title", templateData.title);
    formData.append("description", templateData.description);
    formData.append("category", templateData.category);
    formData.append("icon", templateData.icon);
    formData.append("prompt", templateData.prompt);
    if (generatedCode) {
      formData.append("code", generatedCode);
    }
    submit(formData, { method: "post" });
    setShowSaveTemplateModal(false);
  };

  return (
    <>
      <s-page heading="Edit Section" inlineSize="large">
        <s-stack gap="large" direction="block">
          {/* Breadcrumb */}
          <s-stack direction="inline" gap="small" alignItems="center">
            <a
              href="/app/sections"
              style={{ color: "var(--p-color-text-secondary)" }}
            >
              Sections
            </a>
            <s-text color="subdued">/</s-text>
            <s-text>
              {prompt.length > 40 ? prompt.substring(0, 40) + "..." : prompt}
            </s-text>
          </s-stack>

          {/* Section Info Banner */}
          <s-banner tone="info">
            <s-stack direction="inline" gap="base" alignItems="center">
              <s-badge
                tone={generation.status === "saved" ? "success" : "neutral"}
              >
                {generation.status === "saved" ? "Saved" : "Draft"}
              </s-badge>
              <s-text color="subdued">
                Created: {formatDate(generation.createdAt)}
              </s-text>
              {generation.themeName && (
                <s-text color="subdued">Theme: {generation.themeName}</s-text>
              )}
            </s-stack>
          </s-banner>

          {/* Regeneration info callout */}
          {actionData?.regenerated && (
            <s-banner tone="success" dismissible>
              New section created! The previous version is still available in
              your sections list.
            </s-banner>
          )}

          {/* Template saved banner */}
          {actionData?.templateSaved && (
            <s-banner tone="success" dismissible>
              Template saved successfully! View your templates in the Templates
              Library.
            </s-banner>
          )}

          {/* Note: Section save success banner removed - toast notification used instead */}

          {/* Error banner */}
          {actionData?.success === false && (
            <s-banner tone="critical">{actionData.message}</s-banner>
          )}

          {/* Two-column layout */}
          <GenerateLayout
            inputColumn={
              <GenerateInputColumn
                prompt={prompt}
                onPromptChange={setPrompt}
                sectionName={sectionName}
                onSectionNameChange={setSectionName}
                onSectionNameBlur={handleNameBlur}
                sectionType={sectionType}
                onSectionTypeChange={setSectionType}
                advancedOptions={advancedOptions}
                onAdvancedOptionsChange={setAdvancedOptions}
                disabled={isGenerating || isSaving}
                onGenerate={handleGenerate}
                isGenerating={isGenerating}
              />
            }
            previewColumn={
              <GeneratePreviewColumn
                generatedCode={generatedCode}
                themes={themes}
                selectedTheme={selectedTheme}
                onThemeChange={setSelectedTheme}
                fileName={fileName}
                onFileNameChange={setFileName}
                onSaveDraft={handleSaveDraft}
                onPublish={handlePublish}
                onSaveAsTemplate={() => setShowSaveTemplateModal(true)}
                isSavingDraft={isSavingDraft}
                isPublishing={isPublishing}
                isGenerating={isGenerating}
                canSave={canSave}
                canPublish={canPublish}
              />
            }
          />

          {/* Delete button at bottom */}
          <s-stack direction="inline" justifyContent="end">
            <s-button
              tone="critical"
              command="--show"
              commandFor={DELETE_MODAL_ID}
              disabled={isDeleting}
              variant="primary"
            >
              Delete Section
            </s-button>
          </s-stack>
        </s-stack>
      </s-page>

      {/* Save as Template Modal */}
      {showSaveTemplateModal && (
        <SaveTemplateModal
          defaultPrompt={prompt}
          onSave={handleSaveAsTemplate}
          onClose={() => setShowSaveTemplateModal(false)}
        />
      )}

      {/* Delete Confirmation Modal */}
      <DeleteConfirmModal
        id={DELETE_MODAL_ID}
        isBulk={false}
        count={1}
        isDeleting={isDeleting}
        onConfirm={handleDelete}
      />
    </>
  );
}

// Error boundary for 404
export function ErrorBoundary() {
  return (
    <s-page heading="Section Not Found" inlineSize="large">
      <s-stack gap="large" direction="block" alignItems="center">
        <s-section>
          <s-stack gap="base" alignItems="center">
            <s-heading>Section not found</s-heading>
            <s-paragraph>
              The section you are looking for does not exist or you do not have
              access to it.
            </s-paragraph>
            <s-button
              variant="primary"
              onClick={() => (window.location.href = "/app/sections")}
            >
              Back to Sections
            </s-button>
          </s-stack>
        </s-section>
      </s-stack>
    </s-page>
  );
}
</file>

<file path="app/services/adapters/theme-adapter.ts">
import type { ThemeServiceInterface } from '../../types/service.types';
import { themeService } from '../theme.server';

/**
 * Theme Service Adapter
 * Provides a consistent interface to the theme service
 */
class ThemeAdapter implements ThemeServiceInterface {
  private service: ThemeServiceInterface;

  constructor() {
    this.service = themeService;
  }

  async getThemes(request: Request): Promise<import('../../types/shopify-api.types').Theme[]> {
    return this.service.getThemes(request);
  }

  async createSection(
    request: Request,
    themeId: string,
    fileName: string,
    content: string,
    sectionName?: string
  ): Promise<import('../../types/shopify-api.types').ThemeFileMetadata> {
    return this.service.createSection(request, themeId, fileName, content, sectionName);
  }
}

export const themeAdapter = new ThemeAdapter();
</file>

<file path="app/services/theme.server.ts">
import { authenticate } from "../shopify.server";
import type {
  Theme,
  ThemesQueryResponse,
  ThemeFilesUpsertResponse,
  ThemeFileMetadata,
  ThemeServiceInterface
} from "../types";

/** Prefix for all sections created by this app to avoid conflicts */
const SECTION_PREFIX = 'bsm-';

/**
 * Truncate name to Shopify's 25-char limit for schema names
 */
function truncateName(name: string, maxLength = 25): string {
  if (name.length <= maxLength) return name;
  return name.substring(0, maxLength - 3).trim() + '...';
}

/**
 * Update schema "name" and preset names in Liquid code
 * Returns original code if parsing fails (safe fallback)
 */
function updateSchemaName(liquidCode: string, newName: string): string {
  const safeName = truncateName(newName.trim());

  const schemaMatch = liquidCode.match(
    /{% schema %}\s*([\s\S]*?)\s*{% endschema %}/
  );

  if (!schemaMatch?.[1]) {
    console.warn('updateSchemaName: No schema block found');
    return liquidCode;
  }

  try {
    const schema = JSON.parse(schemaMatch[1]);
    schema.name = safeName;

    // Sync preset names
    if (Array.isArray(schema.presets)) {
      schema.presets = schema.presets.map((preset: Record<string, unknown>) => ({
        ...preset,
        name: safeName
      }));
    }

    return liquidCode.replace(
      /{% schema %}\s*[\s\S]*?\s*{% endschema %}/,
      `{% schema %}\n${JSON.stringify(schema, null, 2)}\n{% endschema %}`
    );
  } catch (error) {
    console.error('updateSchemaName: Failed to parse schema JSON', error);
    return liquidCode; // Safe fallback
  }
}

export class ThemeService implements ThemeServiceInterface {
  async getThemes(request: Request): Promise<Theme[]> {
    const { admin } = await authenticate.admin(request);
    const response = await admin.graphql(
      `#graphql
      query getThemes {
        themes(first: 10) {
          edges {
            node {
              id
              name
              role
            }
          }
        }
      }`
    );

    const data = await response.json() as ThemesQueryResponse;
    return data.data?.themes?.edges.map(edge => edge.node) || [];
  }

  async createSection(
    request: Request,
    themeId: string,
    fileName: string,
    content: string,
    sectionName?: string
  ): Promise<ThemeFileMetadata> {
    const { admin } = await authenticate.admin(request);

    // Apply section name to schema if provided
    let finalContent = content;
    if (sectionName?.trim()) {
      finalContent = updateSchemaName(content, sectionName);
    }

    // Extract base filename (remove path prefix and .liquid extension)
    let baseName = fileName.includes('/')
      ? fileName.split('/').pop()!
      : fileName;
    baseName = baseName.replace(/\.liquid$/, '');

    // Add BSM prefix if not already present (prevents conflicts, identifies app-created sections)
    if (!baseName.startsWith(SECTION_PREFIX)) {
      baseName = `${SECTION_PREFIX}${baseName}`;
    }

    // Construct full filename with sections/ folder and .liquid extension
    const fullFilename = `sections/${baseName}.liquid`;

    const mutation = `
      mutation themeFilesUpsert($files: [OnlineStoreThemeFilesUpsertFileInput!]!, $themeId: ID!) {
        themeFilesUpsert(files: $files, themeId: $themeId) {
          upsertedThemeFiles {
            filename
          }
          userErrors {
            field
            message
          }
        }
      }
    `;

    const response = await admin.graphql(mutation, {
      variables: {
        themeId: themeId,
        files: [
          {
            filename: fullFilename,
            body: {
              type: "TEXT",
              value: finalContent
            }
          }
        ]
      }
    });

    const data = await response.json() as ThemeFilesUpsertResponse;

    // Check for errors
    if (data.data?.themeFilesUpsert?.userErrors?.length) {
      const errors = data.data.themeFilesUpsert.userErrors;
      throw new Error(`Failed to save theme file: ${errors.map(e => e.message).join(', ')}`);
    }

    const file = data.data?.themeFilesUpsert?.upsertedThemeFiles?.[0];
    if (!file) {
      throw new Error('No file returned from upsert');
    }

    return file;
  }
}

export const themeService = new ThemeService();
</file>

<file path="tsconfig.json">
{
  "include": ["env.d.ts", "**/*.ts", "**/*.tsx", ".react-router/types/**/*"],
  "exclude": ["**/__tests__/**", "**/*.test.ts", "**/*.test.tsx", "node_modules"],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "allowJs": true,
    "resolveJsonModule": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "target": "ES2022",
    "baseUrl": ".",
    "types": ["@react-router/node", "vite/client", "@shopify/app-bridge-types", "@shopify/polaris-types"],
    "rootDirs": [".", "./.react-router/types"]
  }
}
</file>

<file path="app/components/generate/SaveTemplateModal.tsx">
import { useState } from "react";

export interface SaveTemplateModalProps {
  defaultPrompt: string;
  onSave: (data: {
    title: string;
    description: string;
    category: string;
    icon: string;
    prompt: string;
  }) => void;
  onClose: () => void;
}

const CATEGORIES = [
  { value: "marketing", label: "Marketing" },
  { value: "product", label: "Product" },
  { value: "content", label: "Content" },
  { value: "layout", label: "Layout" },
];

const ICONS = ["", "", "", "", "", "", "", "", "", ""];

/**
 * Modal for saving generated code as a reusable template
 */
export function SaveTemplateModal({
  defaultPrompt,
  onSave,
  onClose
}: SaveTemplateModalProps) {
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [category, setCategory] = useState("marketing");
  const [icon, setIcon] = useState("");
  const [prompt, setPrompt] = useState(defaultPrompt);

  const isValid = title.trim() && description.trim() && prompt.trim();

  const handleSubmit = () => {
    if (!isValid) return;
    onSave({
      title: title.trim(),
      description: description.trim(),
      category,
      icon,
      prompt: prompt.trim(),
    });
  };

  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      }}
      onClick={onClose}
      onKeyDown={(e) => {
        if (e.key === 'Escape') {
          onClose();
        }
      }}
    >
      {/* eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions, jsx-a11y/click-events-have-key-events */}
      <div
        role="dialog"
        aria-modal="true"
        aria-labelledby="save-template-title"
        style={{
          backgroundColor: 'var(--p-color-bg-surface)',
          borderRadius: '12px',
          width: '100%',
          maxWidth: '600px',
          maxHeight: '90vh',
          overflow: 'auto'
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <s-section>
          <s-stack gap="large" direction="block">
            {/* Header */}
            <s-stack gap="small" direction="inline" justifyContent="space-between">
              <s-text id="save-template-title" type="strong">
                Save as Template
              </s-text>
              <s-button variant="tertiary" onClick={onClose}>
                
              </s-button>
            </s-stack>

            <s-text color="subdued">
              Save this generation as a reusable template for future use.
            </s-text>

            {/* Form fields */}
            <s-stack gap="large" direction="block">
              {/* Title */}
              <s-stack gap="small" direction="block">
                <s-text type="strong">Title</s-text>
                <input
                  type="text"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder="e.g., Hero Banner"
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid var(--p-color-border)',
                    borderRadius: '8px',
                    fontSize: '14px'
                  }}
                />
              </s-stack>

              {/* Description */}
              <s-stack gap="small" direction="block">
                <s-text type="strong">Description</s-text>
                <input
                  type="text"
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="Brief description of the template"
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid var(--p-color-border)',
                    borderRadius: '8px',
                    fontSize: '14px'
                  }}
                />
              </s-stack>

              {/* Category */}
              <s-stack gap="small" direction="block">
                <s-text type="strong">Category</s-text>
                <select
                  value={category}
                  onChange={(e) => setCategory(e.target.value)}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid var(--p-color-border)',
                    borderRadius: '8px',
                    fontSize: '14px',
                    backgroundColor: 'var(--p-color-bg-surface)'
                  }}
                >
                  {CATEGORIES.map((cat) => (
                    <option key={cat.value} value={cat.value}>
                      {cat.label}
                    </option>
                  ))}
                </select>
              </s-stack>

              {/* Icon picker */}
              <s-stack gap="small" direction="block">
                <s-text type="strong">Icon</s-text>
                <s-stack gap="small">
                  {ICONS.map((emoji) => (
                    <button
                      key={emoji}
                      type="button"
                      onClick={() => setIcon(emoji)}
                      style={{
                        width: '40px',
                        height: '40px',
                        fontSize: '20px',
                        border: icon === emoji
                          ? '2px solid var(--p-color-border-interactive)'
                          : '1px solid var(--p-color-border)',
                        borderRadius: '8px',
                        backgroundColor: icon === emoji
                          ? 'var(--p-color-bg-surface-secondary)'
                          : 'transparent',
                        cursor: 'pointer'
                      }}
                    >
                      {emoji}
                    </button>
                  ))}
                </s-stack>
              </s-stack>

              {/* Prompt (read-only preview) */}
              <s-stack gap="small" direction="block">
                <s-text type="strong">Prompt</s-text>
                <textarea
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  rows={3}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid var(--p-color-border)',
                    borderRadius: '8px',
                    fontSize: '14px',
                    resize: 'vertical',
                    fontFamily: 'inherit'
                  }}
                />
              </s-stack>
            </s-stack>

            {/* Actions */}
            <s-stack gap="small" alignItems="end">
              <s-button variant="secondary" onClick={onClose}>
                Cancel
              </s-button>
              <s-button
                variant="primary"
                onClick={handleSubmit}
                disabled={!isValid}
              >
                Save Template
              </s-button>
            </s-stack>
          </s-stack>
        </s-section>
      </div>
    </div>
  );
}
</file>

<file path="app/components/generate/ThemeSelector.tsx">
import type { Theme } from '../../types';

export interface ThemeSelectorProps {
  themes: Theme[];
  selectedThemeId: string;
  onChange: (themeId: string) => void;
  disabled?: boolean;
}

/**
 * Theme selection dropdown
 * Uses native select element because s-select web component
 * doesn't render dynamically generated options properly
 */
export function ThemeSelector({
  themes,
  selectedThemeId,
  onChange,
  disabled = false
}: ThemeSelectorProps) {
  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    onChange(e.target.value);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
      <label
        htmlFor="theme-selector"
        style={{
          fontSize: '13px',
          fontWeight: 500,
          color: '#202223'
        }}
      >
        Select Theme
      </label>
      <select
        id="theme-selector"
        value={selectedThemeId}
        onChange={handleChange}
        disabled={disabled}
        style={{
          width: '100%',
          padding: '8px 12px',
          fontSize: '14px',
          borderRadius: '8px',
          border: '1px solid #c9cccf',
          backgroundColor: disabled ? '#f6f6f7' : '#fff',
          color: '#202223',
          cursor: disabled ? 'not-allowed' : 'pointer',
          appearance: 'none',
          backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236d7175' d='M6 8.5L1.5 4h9L6 8.5z'/%3E%3C/svg%3E")`,
          backgroundRepeat: 'no-repeat',
          backgroundPosition: 'right 12px center',
          paddingRight: '32px'
        }}
      >
        {themes.length === 0 ? (
          <option value="">No themes available</option>
        ) : (
          themes.map((theme) => (
            <option key={theme.id} value={theme.id}>
              {theme.name} {theme.role === 'MAIN' ? '(Live)' : `(${theme.role})`}
            </option>
          ))
        )}
      </select>
    </div>
  );
}
</file>

<file path="app/components/preview/schema/parseSchema.ts">
import type { SchemaDefinition, SchemaSetting, SettingsState, SchemaBlock, BlockInstance } from './SchemaTypes';

/**
 * Resolve Shopify translation key to human-readable label.
 * Handles keys like "t:sections.hero.settings.heading.label"
 *
 * @example
 * resolveTranslationKey("t:sections.hero.settings.heading.label") // "Heading"
 * resolveTranslationKey("Background Color") // "Background Color" (unchanged)
 */
export function resolveTranslationKey(value: string | undefined): string {
  if (!value) return '';

  // Check if it's a translation key (starts with "t:")
  if (!value.startsWith('t:')) {
    return value;
  }

  // Extract the last meaningful part of the key
  // "t:sections.hero.settings.heading.label" -> ["sections", "hero", "settings", "heading", "label"]
  const parts = value.slice(2).split('.');

  // Find the most meaningful part (not "label", "info", "options", "name", etc.)
  const skipWords = ['label', 'info', 'placeholder', 'options', 't', 'sections', 'blocks', 'settings', 'name'];
  let meaningfulPart = '';

  for (let i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    // Skip common suffixes/prefixes and options patterns (options__1, options__2, etc)
    if (!skipWords.includes(part.toLowerCase()) && !part.match(/^options__\d+$/)) {
      meaningfulPart = part;
      break;
    }
  }

  // Convert snake_case to Title Case
  if (meaningfulPart) {
    return meaningfulPart
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  // Fallback: return original without "t:" prefix
  return value.slice(2);
}

/**
 * Resolve all translation keys in a setting object
 */
function resolveSettingLabels(setting: SchemaSetting): SchemaSetting {
  const resolved = { ...setting };

  // Resolve main label and info
  if (resolved.label) {
    resolved.label = resolveTranslationKey(resolved.label);
  }
  if (resolved.info) {
    resolved.info = resolveTranslationKey(resolved.info);
  }
  if (resolved.placeholder) {
    resolved.placeholder = resolveTranslationKey(resolved.placeholder);
  }

  // Resolve select/radio option labels
  if (resolved.options && Array.isArray(resolved.options)) {
    resolved.options = resolved.options.map(opt => ({
      ...opt,
      label: resolveTranslationKey(opt.label)
    }));
  }

  return resolved;
}

/**
 * Extract and parse {% schema %} block from Liquid code
 */
export function parseSchema(liquidCode: string): SchemaDefinition | null {
  // Match {% schema %}...{% endschema %}
  const schemaMatch = liquidCode.match(
    /\{%\s*schema\s*%\}([\s\S]*?)\{%\s*endschema\s*%\}/
  );

  if (!schemaMatch || !schemaMatch[1]) {
    return null;
  }

  try {
    const schemaJson = schemaMatch[1].trim();
    const schema = JSON.parse(schemaJson) as SchemaDefinition;

    // Validate required fields
    if (!schema.name || typeof schema.name !== 'string') {
      console.warn('Schema missing required "name" field');
    }

    return schema;
  } catch (error) {
    console.error('Failed to parse schema JSON:', error);
    return null;
  }
}

/**
 * Extract settings array from schema, filtering to supported types
 * Also resolves any translation keys to human-readable labels
 */
export function extractSettings(schema: SchemaDefinition | null): SchemaSetting[] {
  if (!schema?.settings) {
    return [];
  }

  // Filter to only editable setting types (exclude headers/paragraphs)
  const supportedTypes = [
    'text', 'textarea', 'richtext', 'number', 'range',
    'checkbox', 'select', 'color', 'color_background',
    'image_picker', 'url', 'html',
    // Resource types
    'product', 'collection'
  ];

  return schema.settings
    .filter(setting => supportedTypes.includes(setting.type) && setting.id)
    .map(resolveSettingLabels); // Resolve any translation keys
}

/**
 * Build initial state from schema defaults
 */
export function buildInitialState(settings: SchemaSetting[]): SettingsState {
  const state: SettingsState = {};

  for (const setting of settings) {
    if (setting.default !== undefined) {
      state[setting.id] = setting.default;
    } else {
      // Provide sensible defaults by type
      switch (setting.type) {
        case 'checkbox':
          state[setting.id] = false;
          break;
        case 'number':
        case 'range':
          state[setting.id] = setting.min ?? 0;
          break;
        case 'color':
        case 'color_background':
          state[setting.id] = '#000000';
          break;
        case 'select':
          state[setting.id] = setting.options?.[0]?.value ?? '';
          break;
        case 'image_picker':
          // Use 'placeholder' marker which Liquid filters will convert to actual placeholder SVG
          state[setting.id] = 'placeholder';
          break;
        default:
          state[setting.id] = '';
      }
    }
  }

  return state;
}

/**
 * Coerce value to appropriate type based on setting type
 */
export function coerceValue(
  value: string | number | boolean,
  settingType: string
): string | number | boolean {
  switch (settingType) {
    case 'checkbox':
      return Boolean(value);
    case 'number':
    case 'range':
      return typeof value === 'number' ? value : parseFloat(String(value)) || 0;
    default:
      return String(value);
  }
}

/**
 * Extract block definitions from schema
 * Resolves translation keys in block names and settings
 */
export function extractBlocks(schema: SchemaDefinition | null): SchemaBlock[] {
  if (!schema?.blocks) return [];

  return schema.blocks
    .filter(block => block.type && block.name)
    .map(block => ({
      ...block,
      name: resolveTranslationKey(block.name),
      settings: block.settings?.map(resolveSettingLabels)
    }));
}

/**
 * Build block instances from preset configuration
 * Initializes blocks with default settings from schema
 */
export function buildBlockInstancesFromPreset(
  schema: SchemaDefinition | null
): BlockInstance[] {
  if (!schema) return [];

  // Get blocks from first preset or default
  const presetBlocks = schema.presets?.[0]?.blocks || schema.default?.blocks || [];

  return presetBlocks.map((presetBlock, index) => {
    // Find block definition in schema.blocks
    const blockDef = schema.blocks?.find(b => b.type === presetBlock.type);

    // Build settings with defaults from block definition
    const blockSettings = blockDef?.settings || [];
    const settings = buildInitialState(blockSettings);

    // Apply preset overrides if any
    if (presetBlock.settings) {
      Object.assign(settings, presetBlock.settings);
    }

    return {
      id: `block-${index}`,
      type: presetBlock.type,
      settings
    };
  });
}
</file>

<file path="app/routes/app.sections.new.tsx">
import { useState, useEffect, useRef } from "react";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import { useActionData, useLoaderData, useNavigation, useSubmit, useSearchParams, useNavigate } from "react-router";
import { authenticate } from "../shopify.server";
import { aiAdapter } from "../services/adapters/ai-adapter";
import { themeAdapter } from "../services/adapters/theme-adapter";
import { sectionService } from "../services/section.server";
import { templateService } from "../services/template.server";
import { canGenerate, trackGeneration } from "../services/usage-tracking.server";
import type { GenerateActionData, SaveActionData, Theme } from "../types";

import { GenerateLayout } from "../components/generate/GenerateLayout";
import { GenerateInputColumn } from "../components/generate/GenerateInputColumn";
import { GeneratePreviewColumn } from "../components/generate/GeneratePreviewColumn";
import { SaveTemplateModal } from "../components/generate/SaveTemplateModal";
import type { AdvancedOptionsState } from "../components/generate/AdvancedOptions";
import type { SectionType } from "../components/generate/SectionTypeSelector";

export async function loader({ request }: LoaderFunctionArgs) {
  await authenticate.admin(request);
  const themes = await themeAdapter.getThemes(request);
  return { themes };
}

export async function action({ request }: ActionFunctionArgs) {
  const { session, admin } = await authenticate.admin(request);
  const shop = session.shop;
  const formData = await request.formData();
  const actionType = formData.get("action");

  if (actionType === "generate") {
    const prompt = formData.get("prompt") as string;
    const name = formData.get("name") as string | null;
    const tone = formData.get("tone") as string | null;
    const style = formData.get("style") as string | null;

    // Check quota before generation
    const quotaCheck = await canGenerate(shop);

    if (!quotaCheck.allowed) {
      return {
        error: quotaCheck.reason || "Generation limit reached",
        quota: quotaCheck.quota,
      };
    }

    const code = await aiAdapter.generateSection(prompt);

    // Return code only - section saved to DB only when user clicks Save Draft or Publish
    return {
      code,
      prompt,
      name: name || undefined,
      tone: tone || undefined,
      style: style || undefined,
      quota: quotaCheck.quota,
    } satisfies GenerateActionData;
  }

  if (actionType === "saveDraft") {
    const prompt = formData.get("prompt") as string;
    const content = formData.get("content") as string;
    const sectionName = formData.get("sectionName") as string | null;
    const tone = formData.get("tone") as string | null;
    const style = formData.get("style") as string | null;

    try {
      // Create section in DB with draft status
      const sectionEntry = await sectionService.create({
        shop,
        prompt,
        code: content,
        name: sectionName || undefined,
        tone: tone || undefined,
        style: style || undefined,
        status: "draft",
      });

      // Track usage
      trackGeneration(admin, shop, sectionEntry.id, prompt).catch((error) => {
        console.error("Failed to track generation:", error);
      });

      return {
        success: true,
        message: "Draft saved successfully!",
        sectionId: sectionEntry.id,
      } satisfies SaveActionData;
    } catch (error) {
      console.error("Failed to save draft:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Failed to save draft. Please try again."
      } satisfies SaveActionData;
    }
  }

  if (actionType === "save") {
    const themeId = formData.get("themeId") as string;
    const fileName = formData.get("fileName") as string;
    const content = formData.get("content") as string;
    const prompt = formData.get("prompt") as string;
    const sectionName = formData.get("sectionName") as string | null;
    const themeName = formData.get("themeName") as string | null;
    const tone = formData.get("tone") as string | null;
    const style = formData.get("style") as string | null;

    try {
      // Save to theme first
      const result = await themeAdapter.createSection(request, themeId, fileName, content, sectionName || undefined);

      // Create section in DB with saved status
      const sectionEntry = await sectionService.create({
        shop,
        prompt,
        code: content,
        name: sectionName || undefined,
        tone: tone || undefined,
        style: style || undefined,
        themeId,
        themeName: themeName || undefined,
        fileName,
      });

      // Track usage
      trackGeneration(admin, shop, sectionEntry.id, prompt).catch((error) => {
        console.error("Failed to track generation:", error);
      });

      return {
        success: true,
        message: `Section published to ${result?.filename || fileName}!`,
        sectionId: sectionEntry.id,
      } satisfies SaveActionData;
    } catch (error) {
      console.error("Failed to save section:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Failed to save section. Please try again."
      } satisfies SaveActionData;
    }
  }

  if (actionType === "saveAsTemplate") {
    const title = formData.get("title") as string;
    const description = formData.get("description") as string;
    const category = formData.get("category") as string;
    const icon = formData.get("icon") as string;
    const prompt = formData.get("prompt") as string;
    const code = formData.get("code") as string | null;

    try {
      await templateService.create({
        shop,
        title,
        description,
        category,
        icon,
        prompt,
        code: code || undefined,
      });

      return {
        success: true,
        message: "Template saved successfully!",
        templateSaved: true
      };
    } catch (error) {
      console.error("Failed to save template:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Failed to save template. Please try again."
      };
    }
  }

  return null;
}

export default function CreateSectionPage() {
  const { themes } = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const navigation = useNavigation();
  const submit = useSubmit();
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();

  // Get params from URL (from template navigation)
  const urlPrompt = searchParams.get("prompt") || "";
  const urlCode = searchParams.get("code") || "";
  const urlName = searchParams.get("name") || "";
  const hasAutoGenerated = useRef(false);
  const hasLoadedCode = useRef(false);

  const [prompt, setPrompt] = useState(urlPrompt || actionData?.prompt || "");
  const [sectionName, setSectionName] = useState(urlName || "");
  const [generatedCode, setGeneratedCode] = useState(urlCode || actionData?.code || "");

  // Section type state (customizable vs production-ready)
  const [sectionType, setSectionType] = useState<SectionType>('customizable');

  // Advanced options state (for future AI integration)
  const [advancedOptions, setAdvancedOptions] = useState<AdvancedOptionsState>({
    tone: 'professional',
    style: 'minimal',
    includeSchema: true
  });

  // Auto-sync includeSchema with sectionType
  useEffect(() => {
    setAdvancedOptions(prev => ({
      ...prev,
      includeSchema: sectionType === 'customizable'
    }));
  }, [sectionType]);

  // Find the active (main) theme to set as default
  const activeTheme = themes.find((theme: Theme) => theme.role === "MAIN");
  const [selectedTheme, setSelectedTheme] = useState(activeTheme?.id || themes[0]?.id || "");

  const [fileName, setFileName] = useState(urlName ? urlName.toLowerCase().replace(/\s+/g, '-') : "ai-section");
  const [showSaveTemplateModal, setShowSaveTemplateModal] = useState(false);

  const isLoading = navigation.state === "submitting";
  const isGenerating = isLoading && navigation.formData?.get("action") === "generate";
  const isSaving = isLoading && (navigation.formData?.get("action") === "save" || navigation.formData?.get("action") === "saveDraft");
  const isSavingDraft = isLoading && navigation.formData?.get("action") === "saveDraft";
  const isPublishing = isLoading && navigation.formData?.get("action") === "save";

  // Update state when action data changes
  useEffect(() => {
    if (actionData?.code && actionData.code !== generatedCode) {
      setGeneratedCode(actionData.code);
    }
  }, [actionData?.code, generatedCode]);

  // Load pre-built code from URL (Use As-Is flow)
  useEffect(() => {
    if (urlCode && !hasLoadedCode.current) {
      hasLoadedCode.current = true;
      // Code is already set via useState initial value
      // Just clear URL params to prevent issues on reload
      setSearchParams({}, { replace: true });
    }
  }, [urlCode, setSearchParams]);

  // Auto-generate when coming from template with prompt URL param
  useEffect(() => {
    if (urlPrompt && !hasAutoGenerated.current && navigation.state === "idle" && !urlCode) {
      hasAutoGenerated.current = true;
      // Set prompt state if not already set
      if (prompt !== urlPrompt) {
        setPrompt(urlPrompt);
      }
      // Clear the URL param to prevent re-generation on reload
      setSearchParams({}, { replace: true });
      // Trigger generation
      const formData = new FormData();
      formData.append("action", "generate");
      formData.append("prompt", urlPrompt);
      formData.append("name", "");
      formData.append("tone", advancedOptions.tone);
      formData.append("style", advancedOptions.style);
      formData.append("sectionType", sectionType);
      submit(formData, { method: "post" });
    }
  }, [urlPrompt, urlCode, navigation.state, prompt, advancedOptions, sectionType, submit, setSearchParams]);

  // Get theme name for success message and save handler
  const selectedThemeName = themes.find((t: Theme) => t.id === selectedTheme)?.name || 'theme';

  // Handlers
  const handleGenerate = () => {
    if (!prompt.trim()) return;
    const formData = new FormData();
    formData.append("action", "generate");
    formData.append("prompt", prompt);
    formData.append("name", sectionName);
    formData.append("tone", advancedOptions.tone);
    formData.append("style", advancedOptions.style);
    formData.append("sectionType", sectionType);
    submit(formData, { method: "post" });
  };

  const handleSaveDraft = () => {
    const formData = new FormData();
    formData.append("action", "saveDraft");
    formData.append("prompt", prompt);
    formData.append("content", generatedCode);
    formData.append("sectionName", sectionName);
    formData.append("tone", advancedOptions.tone);
    formData.append("style", advancedOptions.style);
    submit(formData, { method: "post" });
  };

  const handlePublish = () => {
    const formData = new FormData();
    formData.append("action", "save");
    formData.append("themeId", selectedTheme);
    formData.append("fileName", fileName);
    formData.append("content", generatedCode);
    formData.append("prompt", prompt);
    formData.append("themeName", selectedThemeName);
    formData.append("sectionName", sectionName);
    formData.append("tone", advancedOptions.tone);
    formData.append("style", advancedOptions.style);
    submit(formData, { method: "post" });
  };

  const canSave = Boolean(generatedCode);
  const canPublish = Boolean(generatedCode && fileName && selectedTheme);

  const handleSaveAsTemplate = (data: {
    title: string;
    description: string;
    category: string;
    icon: string;
    prompt: string;
  }) => {
    const formData = new FormData();
    formData.append("action", "saveAsTemplate");
    formData.append("title", data.title);
    formData.append("description", data.description);
    formData.append("category", data.category);
    formData.append("icon", data.icon);
    formData.append("prompt", data.prompt);
    if (generatedCode) {
      formData.append("code", generatedCode);
    }
    submit(formData, { method: "post" });
    setShowSaveTemplateModal(false);
  };

  // Close modal on successful template save
  useEffect(() => {
    if (actionData?.templateSaved) {
      setShowSaveTemplateModal(false);
    }
  }, [actionData?.templateSaved]);

  // Redirect to edit page after successful section save
  useEffect(() => {
    if (actionData?.success && actionData?.sectionId && !actionData?.templateSaved) {
      shopify.toast.show("Section saved");
      navigate(`/app/sections/${actionData.sectionId}`);
    }
  }, [actionData?.success, actionData?.sectionId, actionData?.templateSaved, navigate]);

  return (
    <>
      <s-page heading="Create Section" inlineSize="large">
        <s-stack gap="large" direction="block">
          {/* Enhanced feedback banners */}

          {/* Template saved banner */}
          {actionData?.templateSaved && (
            <s-banner tone="success" dismissible>
              Template saved successfully! View your templates in the Templates Library.
            </s-banner>
          )}

          {/* Note: Section save success banner removed - user is redirected to edit page */}

          {/* Error banner with recovery guidance */}
          {actionData?.success === false && (
            <s-banner tone="critical">
              {actionData.message}
              {actionData.message?.toLowerCase().includes('generate') && (
                <span> Try simplifying your prompt or choose a pre-built template.</span>
              )}
              {actionData.message?.toLowerCase().includes('save') && (
                <span> Verify that the selected theme exists and you have permission to modify it.</span>
              )}
            </s-banner>
          )}

          {/* Two-column layout */}
          <GenerateLayout
            inputColumn={
              <GenerateInputColumn
                prompt={prompt}
                onPromptChange={setPrompt}
                sectionName={sectionName}
                onSectionNameChange={setSectionName}
                sectionType={sectionType}
                onSectionTypeChange={setSectionType}
                advancedOptions={advancedOptions}
                onAdvancedOptionsChange={setAdvancedOptions}
                disabled={isGenerating || isSaving}
                onGenerate={handleGenerate}
                isGenerating={isGenerating}
              />
            }
            previewColumn={
              <GeneratePreviewColumn
                generatedCode={generatedCode}
                themes={themes}
                selectedTheme={selectedTheme}
                onThemeChange={setSelectedTheme}
                fileName={fileName}
                onFileNameChange={setFileName}
                onSaveDraft={handleSaveDraft}
                onPublish={handlePublish}
                onSaveAsTemplate={() => setShowSaveTemplateModal(true)}
                isSavingDraft={isSavingDraft}
                isPublishing={isPublishing}
                isGenerating={isGenerating}
                canSave={canSave}
                canPublish={canPublish}
              />
            }
          />
        </s-stack>
      </s-page>

      {/* Save as Template Modal */}
      {showSaveTemplateModal && (
        <SaveTemplateModal
          defaultPrompt={prompt}
          onSave={handleSaveAsTemplate}
          onClose={() => setShowSaveTemplateModal(false)}
        />
      )}
    </>
  );
}
</file>

<file path="app/globals.d.ts">
declare module "*.css";
</file>

<file path="app/components/templates/TemplateCard.tsx">
import type { SectionTemplate } from "@prisma/client";

export interface TemplateCardProps {
  template: SectionTemplate;
  onUseAsIs: () => void;      // Use pre-built code (instant)
  onCustomize: () => void;    // Use prompt for AI generation
  onEdit: () => void;
  onToggleFavorite: () => void;
  onDuplicate: () => void;
  onDelete: () => void;
}

/**
 * Card component displaying a single template with Polaris patterns
 * Shows "Use As-Is" for templates with code, "Customize" for AI generation
 */
export function TemplateCard({
  template,
  onUseAsIs,
  onCustomize,
  onEdit: _onEdit,           // Reserved for future user templates
  onToggleFavorite,
  onDuplicate: _onDuplicate, // Reserved for future user templates
  onDelete: _onDelete        // Reserved for future user templates
}: TemplateCardProps) {
  const hasCode = Boolean(template.code);

  return (
    <s-box
      padding="base"
      borderRadius="base"
      border="base"
      background="base"
    >
      <s-stack gap="base" direction="block">
        {/* Header with icon, title, and badges */}
        <s-stack gap="small" justifyContent="space-between" alignItems="start" direction="inline">
          <s-stack gap="small" direction="inline" alignItems="center">
            <span style={{ fontSize: '28px', lineHeight: 1 }}>{template.icon}</span>
            <s-stack gap="none" direction="block">
              <s-text type="strong">{template.title}</s-text>
              <s-stack gap="small" direction="inline">
                <s-badge tone="neutral">{template.category}</s-badge>
                {hasCode ? (
                  <s-badge tone="success">Ready to Use</s-badge>
                ) : (
                  <s-badge tone="info">AI Only</s-badge>
                )}
              </s-stack>
            </s-stack>
          </s-stack>
          <s-button
            variant="tertiary"
            onClick={onToggleFavorite}
            accessibilityLabel={template.isFavorite ? "Remove from favorites" : "Add to favorites"}
          >
            <span style={{ fontSize: '16px' }}>{template.isFavorite ? '' : ''}</span>
          </s-button>
        </s-stack>

        {/* Description */}
        <s-text color="subdued">{template.description}</s-text>

        {/* Code preview or prompt preview */}
        <s-box
          padding="small"
          background="subdued"
          borderRadius="base"
        >
          {hasCode ? (
            <s-stack gap="small" direction="block">
              <s-text color="subdued" type="strong">Preview:</s-text>
              <s-text color="subdued">
                {template.code!.substring(0, 100).replace(/\s+/g, ' ')}...
              </s-text>
            </s-stack>
          ) : (
            <s-text color="subdued">
              {template.prompt.length > 80
                ? `${template.prompt.substring(0, 80)}...`
                : template.prompt}
            </s-text>
          )}
        </s-box>

        {/* Primary Actions - Use/Customize only (system templates) */}
        {/* Note: Edit/Duplicate/Delete actions reserved for future user templates */}
        <s-stack gap="small" direction="inline">
          {hasCode && (
            <s-button variant="primary" onClick={onUseAsIs}>
              Use As-Is
            </s-button>
          )}
          <s-button
            variant={hasCode ? "secondary" : "primary"}
            onClick={onCustomize}
          >
            {hasCode ? "Customize with AI" : "Generate with AI"}
          </s-button>
        </s-stack>
      </s-stack>
    </s-box>
  );
}
</file>

<file path="app/types/service.types.ts">
/**
 * Service Layer Type Definitions
 * Interfaces for AI and Theme services
 */

import type { Theme, ThemeFileMetadata } from './shopify-api.types';
import type { QuotaCheck } from './billing';

// Section Type for generation mode
export type SectionType = 'customizable' | 'production-ready';

// AI Service Types
export interface AIGenerationOptions {
  prompt: string;
  model?: string;
  temperature?: number;
}

export interface AIGenerationResult {
  code: string;
  prompt: string;
  modelUsed: string;
  timestamp: Date;
}

export interface AIServiceInterface {
  generateSection(prompt: string): Promise<string>;
  getMockSection(prompt: string): string;
}

// Theme Service Types
export interface ThemeServiceInterface {
  getThemes(request: Request): Promise<Theme[]>;
  createSection(
    request: Request,
    themeId: string,
    fileName: string,
    content: string,
    sectionName?: string
  ): Promise<ThemeFileMetadata>;
}

// Database Types
export interface GeneratedSectionRecord {
  id: string;
  shop: string;
  prompt: string;
  content: string;
  createdAt: Date;
}

// Action Data Types for Routes
export interface GenerateActionData {
  success?: boolean;
  code?: string;
  prompt?: string;
  message?: string;
  error?: string;
  quota?: QuotaCheck;
  // Generation metadata (no DB save until user saves)
  name?: string;
  tone?: string;
  style?: string;
}

export interface SaveActionData {
  success: boolean;
  message: string;
  sectionId?: string;
  templateSaved?: boolean;
}
</file>

<file path="app/components/generate/GenerateInputColumn.tsx">
import { PromptInput } from "./PromptInput";
import { TemplateSuggestions } from "./TemplateSuggestions";
import { PromptExamples } from "./PromptExamples";
import { AdvancedOptions, type AdvancedOptionsState } from "./AdvancedOptions";
import { SectionTypeSelector, type SectionType } from "./SectionTypeSelector";

export interface GenerateInputColumnProps {
  prompt: string;
  onPromptChange: (value: string) => void;
  sectionName?: string;
  onSectionNameChange?: (value: string) => void;
  onSectionNameBlur?: () => void;
  sectionType: SectionType;
  onSectionTypeChange: (type: SectionType) => void;
  advancedOptions: AdvancedOptionsState;
  onAdvancedOptionsChange: (options: AdvancedOptionsState) => void;
  disabled: boolean;
  onGenerate: () => void;
  isGenerating: boolean;
}

/**
 * Primary column for generate screen (following Details pattern)
 * Contains prompt input, templates, examples, and advanced options
 * Uses s-section for proper grouping with headers
 */
export function GenerateInputColumn({
  prompt,
  onPromptChange,
  sectionName,
  onSectionNameChange,
  onSectionNameBlur,
  sectionType,
  onSectionTypeChange,
  advancedOptions,
  onAdvancedOptionsChange,
  disabled,
  onGenerate,
  isGenerating,
}: GenerateInputColumnProps) {
  // Validate prompt before enabling generate button (min 10, max 2000 chars)
  const isPromptValid =
    prompt.trim().length >= 10 && prompt.trim().length <= 2000;

  return (
    <>
      {/* Main input section */}
      <s-section heading="Describe your section">
        <s-stack gap="large" direction="block">
          <SectionTypeSelector
            value={sectionType}
            onChange={onSectionTypeChange}
            disabled={disabled}
          />

          <PromptInput
            value={prompt}
            onChange={onPromptChange}
            disabled={disabled}
          />

          {/* Section name input - optional, auto-generated if empty */}
          {onSectionNameChange && (
            <s-text-field
              label="Section Name"
              value={sectionName || ""}
              onInput={(e) =>
                onSectionNameChange(
                  (e as unknown as { currentTarget: { value: string } })
                    .currentTarget.value,
                )
              }
              onBlur={onSectionNameBlur}
              placeholder="Auto-generated from prompt if empty"
              disabled={disabled}
              details="A friendly name to identify this section in your history"
            />
          )}

          <AdvancedOptions
            value={advancedOptions}
            onChange={onAdvancedOptionsChange}
            disabled={disabled}
          />

          <s-button
            variant="primary"
            onClick={onGenerate}
            loading={isGenerating || undefined}
            disabled={disabled || !isPromptValid}
          >
            Generate Code
          </s-button>
        </s-stack>
      </s-section>

      {/* Template suggestions */}
      <s-section heading="Quick Start Templates">
        <TemplateSuggestions
          onSelectTemplate={onPromptChange}
          disabled={disabled}
        />
      </s-section>

      {/* Prompt examples */}
      <s-section heading="Example Prompts">
        <PromptExamples onSelectExample={onPromptChange} disabled={disabled} />
      </s-section>
    </>
  );
}
</file>

<file path="app/routes/app.templates.tsx">
import { useState } from "react";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import { useActionData, useLoaderData, useSearchParams, useSubmit, useNavigate } from "react-router";
import { authenticate } from "../shopify.server";
import { templateService } from "../services/template.server";
import { templateSeeder } from "../services/template-seeder.server";
import { TemplateGrid } from "../components/templates/TemplateGrid";
import { TemplateEditorModal } from "../components/templates/TemplateEditorModal";
import { FilterButtonGroup } from "../components/shared/FilterButtonGroup";
import { EmptyState } from "../components/shared/EmptyState";

export async function loader({ request }: LoaderFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;

  // Auto-seed default templates on first visit
  const seedResult = await templateSeeder.seedDefaultTemplates(shop);
  const wasSeeded = seedResult.seeded;

  const url = new URL(request.url);
  const category = url.searchParams.get("category") || undefined;
  const favoritesOnly = url.searchParams.get("favorites") === "true";

  const templates = await templateService.getByShop(shop, {
    category,
    favoritesOnly,
  });

  return { templates, wasSeeded };
}

export async function action({ request }: ActionFunctionArgs) {
  const { session } = await authenticate.admin(request);
  const shop = session.shop;
  const formData = await request.formData();
  const actionType = formData.get("action");

  if (actionType === "create") {
    const title = formData.get("title") as string;
    const description = formData.get("description") as string;
    const category = formData.get("category") as string;
    const icon = formData.get("icon") as string;
    const prompt = formData.get("prompt") as string;
    const code = formData.get("code") as string | null;

    await templateService.create({
      shop,
      title,
      description,
      category,
      icon,
      prompt,
      code: code || undefined,
    });

    return { success: true, action: "create" };
  }

  if (actionType === "update") {
    const id = formData.get("id") as string;
    const title = formData.get("title") as string;
    const description = formData.get("description") as string;
    const category = formData.get("category") as string;
    const icon = formData.get("icon") as string;
    const prompt = formData.get("prompt") as string;

    await templateService.update(id, shop, {
      title,
      description,
      category,
      icon,
      prompt,
    });

    return { success: true, action: "update" };
  }

  if (actionType === "toggleFavorite") {
    const id = formData.get("id") as string;
    await templateService.toggleFavorite(id, shop);
    return { success: true, action: "toggleFavorite" };
  }

  if (actionType === "duplicate") {
    const id = formData.get("id") as string;
    await templateService.duplicate(id, shop);
    return { success: true, action: "duplicate" };
  }

  if (actionType === "delete") {
    const id = formData.get("id") as string;
    await templateService.delete(id, shop);
    return { success: true, action: "delete" };
  }

  if (actionType === "resetToDefaults") {
    const result = await templateSeeder.resetToDefaults(shop);
    return { success: true, action: "resetToDefaults", count: result.count };
  }

  return null;
}

const CATEGORIES = [
  { value: "", label: "All Categories" },
  { value: "hero", label: "Hero" },
  { value: "features", label: "Features" },
  { value: "testimonials", label: "Testimonials" },
  { value: "pricing", label: "Pricing" },
  { value: "cta", label: "Call to Action" },
  { value: "faq", label: "FAQ" },
  { value: "team", label: "Team" },
  { value: "gallery", label: "Gallery" },
  { value: "content", label: "Content" },
  { value: "footer", label: "Footer" },
];

const FILTER_OPTIONS = [
  ...CATEGORIES,
  { value: "favorites", label: "Favorites" },
];


export default function TemplatesPage() {
  const { templates, wasSeeded } = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const submit = useSubmit();
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();

  const [showEditor, setShowEditor] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState<typeof templates[0] | null>(null);

  const currentCategory = searchParams.get("category") || "";
  const favoritesOnly = searchParams.get("favorites") === "true";

  // Determine current filter value
  const currentFilterValue = favoritesOnly ? "favorites" : currentCategory;

  const handleFilterChange = (value: string) => {
    const params = new URLSearchParams(searchParams);

    if (value === "favorites") {
      params.delete("category");
      params.set("favorites", "true");
    } else {
      params.delete("favorites");
      if (value) {
        params.set("category", value);
      } else {
        params.delete("category");
      }
    }
    setSearchParams(params);
  };

  // Use pre-built code directly (skip AI)
  const handleUseAsIs = (template: typeof templates[0]) => {
    if (template.code) {
      navigate(`/app/sections/new?code=${encodeURIComponent(template.code)}&name=${encodeURIComponent(template.title)}`);
    }
  };

  // Use prompt to generate with AI
  const handleCustomize = (template: typeof templates[0]) => {
    navigate(`/app/sections/new?prompt=${encodeURIComponent(template.prompt)}`);
  };

  const handleToggleFavorite = (id: string) => {
    const formData = new FormData();
    formData.append("action", "toggleFavorite");
    formData.append("id", id);
    submit(formData, { method: "post" });
  };

  const handleDuplicate = (id: string) => {
    const formData = new FormData();
    formData.append("action", "duplicate");
    formData.append("id", id);
    submit(formData, { method: "post" });
  };

  const handleDelete = (id: string) => {
    if (confirm("Are you sure you want to delete this template?")) {
      const formData = new FormData();
      formData.append("action", "delete");
      formData.append("id", id);
      submit(formData, { method: "post" });
    }
  };

  const handleEdit = (template: typeof templates[0]) => {
    setEditingTemplate(template);
    setShowEditor(true);
  };

  const handleSaveTemplate = (data: {
    title: string;
    description: string;
    category: string;
    icon: string;
    prompt: string;
  }) => {
    const formData = new FormData();
    formData.append("action", editingTemplate ? "update" : "create");
    if (editingTemplate) {
      formData.append("id", editingTemplate.id);
    }
    formData.append("title", data.title);
    formData.append("description", data.description);
    formData.append("category", data.category);
    formData.append("icon", data.icon);
    formData.append("prompt", data.prompt);
    submit(formData, { method: "post" });
    setShowEditor(false);
    setEditingTemplate(null);
  };

  const handleResetToDefaults = () => {
    if (confirm("This will delete all your templates and restore the default templates. Are you sure?")) {
      const formData = new FormData();
      formData.append("action", "resetToDefaults");
      submit(formData, { method: "post" });
    }
  };

  return (
    <>
      <s-page heading="Section Templates" inlineSize="large">
        <s-button slot="secondary-actions" onClick={handleResetToDefaults}>
          Reset to Defaults
        </s-button>
        <s-button slot="primary-action" variant="primary" onClick={() => {
          setEditingTemplate(null);
          setShowEditor(true);
        }}>
          Create Template
        </s-button>

        <s-stack gap="large" direction="block">
          {/* Success banners */}
          {wasSeeded && (
            <s-banner tone="info" dismissible>
              Welcome! We&apos;ve loaded {templates.length} starter templates to help you get started.
            </s-banner>
          )}
          {actionData?.action === "resetToDefaults" && (
            <s-banner tone="success" dismissible>
              Templates reset to defaults successfully.
            </s-banner>
          )}
          {actionData?.action === "delete" && (
            <s-banner tone="success" dismissible>
              Template deleted successfully.
            </s-banner>
          )}
          {actionData?.action === "create" && (
            <s-banner tone="success" dismissible>
              Template created successfully.
            </s-banner>
          )}
          {actionData?.action === "update" && (
            <s-banner tone="success" dismissible>
              Template updated successfully.
            </s-banner>
          )}
          {actionData?.action === "duplicate" && (
            <s-banner tone="success" dismissible>
              Template duplicated successfully.
            </s-banner>
          )}

          <s-section padding={templates.length > 0 ? "base" : "none"}>
            <s-stack gap="base" direction="block">
              {/* Filters */}
              <FilterButtonGroup
                options={FILTER_OPTIONS}
                value={currentFilterValue}
                onChange={handleFilterChange}
              />

              {/* Grid or Empty State */}
              {templates.length > 0 ? (
                <TemplateGrid
                  templates={templates}
                  onUseAsIs={handleUseAsIs}
                  onCustomize={handleCustomize}
                  onEdit={handleEdit}
                  onToggleFavorite={handleToggleFavorite}
                  onDuplicate={handleDuplicate}
                  onDelete={handleDelete}
                />
              ) : (
                <EmptyState
                  heading="No templates yet"
                  description="Create your first template or save one from the Generate page."
                  image="https://cdn.shopify.com/static/images/polaris/patterns/callout.png"
                  primaryAction={{
                    label: "Create Template",
                    onClick: () => {
                      setEditingTemplate(null);
                      setShowEditor(true);
                    }
                  }}
                />
              )}
            </s-stack>
          </s-section>
        </s-stack>
      </s-page>

      {/* Modal using s-modal */}
      {showEditor && (
        <TemplateEditorModal
          template={editingTemplate}
          onSave={handleSaveTemplate}
          onClose={() => {
            setShowEditor(false);
            setEditingTemplate(null);
          }}
        />
      )}
    </>
  );
}
</file>

<file path="app/routes/app.tsx">
import type { HeadersFunction, LoaderFunctionArgs } from "react-router";
import { Outlet, useLoaderData, useRouteError } from "react-router";
import { boundary } from "@shopify/shopify-app-react-router/server";
import { AppProvider } from "@shopify/shopify-app-react-router/react";

import { authenticate } from "../shopify.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  await authenticate.admin(request);

  // eslint-disable-next-line no-undef
  return { apiKey: process.env.SHOPIFY_API_KEY || "" };
};

export default function App() {
  const { apiKey } = useLoaderData<typeof loader>();

  return (
    <AppProvider embedded apiKey={apiKey}>
      <s-app-nav>
        <a href="/" rel="home">
          Home
        </a>
        <a href="/app/sections">Sections</a>
        <a href="/app/templates">Templates</a>
        <a href="/app/billing">Billing</a>
      </s-app-nav>
      <Outlet />
    </AppProvider>
  );
}

// Shopify needs React Router to catch some thrown responses, so that their headers are included in the response.
export function ErrorBoundary() {
  return boundary.error(useRouteError());
}

export const headers: HeadersFunction = (headersArgs) => {
  return boundary.headers(headersArgs);
};
</file>

<file path="app/services/ai.server.ts">
import { GoogleGenerativeAI } from "@google/generative-ai";
import type { AIServiceInterface } from "../types";

const SYSTEM_PROMPT = `You are an expert Shopify theme developer. Generate production-ready Liquid sections.

OUTPUT: Return ONLY raw Liquid code. No markdown fences, no explanations, no comments.

=== SECTION STRUCTURE (required order) ===
1. {% schema %}...{% endschema %} - JSON configuration (MUST be first)
2. {% style %}...{% endstyle %} - Scoped CSS
3. HTML/Liquid markup - Section content

=== SCHEMA RULES ===
- name: REQUIRED, max 25 chars, Title Case (e.g., "Hero Banner")
- tag: Optional wrapper (section, div, article, aside, header, footer, nav)
- settings: Array of inputs (max 7 recommended for UX)
- blocks: Array of block definitions
- max_blocks: Default 50, set lower for performance
- presets: REQUIRED for dynamic sections. Format: [{"name": "Section Name"}]
- Preset name MUST match schema name exactly
- Single {% schema %} per file, valid JSON only, no Liquid inside schema

=== INPUT TYPES REFERENCE ===

TEXT TYPES:
- text: Single line. Props: placeholder, default (string)
- textarea: Multi-line. Props: placeholder, default (string)
- richtext: HTML editor. DEFAULT MUST wrap in <p> or <ul> tags
- inline_richtext: Limited HTML (bold, italic, link). No line breaks
- html: Raw HTML input
- liquid: Liquid code (50KB max). Cannot default to empty string

NUMBERS:
- number: Integer/float. DEFAULT MUST BE NUMBER not string ("5" WRONG, 5 CORRECT)
- range: Bounded slider. REQUIRES: min, max, step. Props: unit, default (number)
- checkbox: Boolean. Returns true/false

SELECTION:
- select: Dropdown. REQUIRES: options [{value, label}]. Props: default, group
- radio: Radio buttons. REQUIRES: options [{value, label}]. Props: default
- text_alignment: Returns "left", "center", or "right"

COLORS:
- color: Hex picker. DEFAULT format: "#000000"
- color_background: CSS background (gradients allowed)

MEDIA:
- image_picker: Returns image object. NO default supported
- video: Returns video object. NO default supported
- video_url: REQUIRES: accept ["youtube", "vimeo"]. Props: placeholder
- font_picker: REQUIRES: default specified. Format: "helvetica_n4"

RESOURCES (NO defaults supported):
- article, blog, collection, page, product: Single resource pickers
- url: Link input. Use default "#" for buttons

RESOURCE LISTS:
- article_list, blog_list, collection_list, product_list: Arrays with limit (max 50)
- link_list: Menu picker

METAOBJECTS:
- metaobject: REQUIRES: metaobject_type (one type per setting)
- metaobject_list: REQUIRES: metaobject_type. Props: limit (max 50)

DISPLAY-ONLY (no storage):
- header: Heading text in editor
- paragraph: Info text in editor

=== VALIDATION RULES ===
1. range MUST have min, max, step properties (all required)
2. select/radio MUST have options: [{value: string, label: string}]
3. number default MUST be number type (5, not "5")
4. richtext default MUST start with <p> or <ul> tag
5. video_url MUST have accept: ["youtube", "vimeo"]
6. font_picker MUST have default specified
7. Resource pickers (collection, product, etc.) DO NOT support default
8. All setting IDs must be unique within section/block scope
9. All block types must be unique within section
10. url settings for buttons SHOULD have default: "#"

=== BLOCK CONFIGURATION ===
{
  "type": "unique_id",        // Required, unique within section
  "name": "Display Name",     // Required, shown in editor
  "limit": 5,                 // Optional, max instances
  "settings": [...]           // Optional, block-level settings
}

Block Title Precedence (auto-display in editor):
1. Setting with id "heading" -> used as title
2. Setting with id "title" -> fallback
3. Setting with id "text" -> fallback
4. Block "name" -> fallback

=== PRESET CONFIGURATION ===
{
  "presets": [{
    "name": "Section Name",   // Must match schema name
    "settings": {},           // Optional default values
    "blocks": []              // Optional default blocks
  }]
}

=== CSS RULES ===
- Wrap in {% style %}...{% endstyle %}
- Root selector: #shopify-section-{{ section.id }}
- Prefix custom classes with "ai-"
- Mobile-first responsive design
- Never use global CSS resets

=== MARKUP RULES ===
- Use semantic HTML (section, article, nav, header, footer)
- Responsive images with srcset or image_tag filter
- Accessible: alt text, proper heading hierarchy, aria labels

=== LABELS FORMAT ===
Use PLAIN TEXT for ALL labels, never translation keys:
- CORRECT: "label": "Background Color"
- WRONG: "label": "t:sections.hero.settings.bg_color.label"

=== JSON EXAMPLES ===

Text setting:
{"type": "text", "id": "heading", "label": "Heading", "default": "Welcome"}

Number (CORRECT - number type):
{"type": "number", "id": "columns", "label": "Columns", "default": 3}

Range (all props required):
{"type": "range", "id": "padding", "label": "Padding", "min": 0, "max": 100, "step": 5, "unit": "px", "default": 20}

Select (options required):
{"type": "select", "id": "layout", "label": "Layout", "options": [{"value": "grid", "label": "Grid"}, {"value": "list", "label": "List"}], "default": "grid"}

Color:
{"type": "color", "id": "bg_color", "label": "Background", "default": "#ffffff"}

Image (no default):
{"type": "image_picker", "id": "image", "label": "Image"}

Richtext (must wrap in <p>):
{"type": "richtext", "id": "text", "label": "Description", "default": "<p>Enter text</p>"}

URL (default for buttons):
{"type": "url", "id": "button_link", "label": "Button Link", "default": "#"}

Video URL (accept required):
{"type": "video_url", "id": "video", "label": "Video", "accept": ["youtube", "vimeo"]}

=== COMMON ERRORS - NEVER DO THESE ===
1. "default": "5" for number -> Use "default": 5
2. range without min/max/step -> Always include all three
3. select without options array -> Always include options
4. richtext default without <p> or <ul> -> Wrap content
5. "label": "t:sections...." -> Use plain text labels only
6. Empty liquid default "" -> Use valid Liquid code
7. Duplicate setting IDs -> All IDs must be unique
8. Schema inside {% if %} -> Schema must be root level
9. JS-style comments in JSON -> No comments allowed
10. Missing preset -> Always include presets array`;

export class AIService implements AIServiceInterface {
  private genAI: GoogleGenerativeAI | null = null;

  constructor(apiKey?: string) {
    const key = apiKey || process.env.GEMINI_API_KEY;
    if (key) {
      this.genAI = new GoogleGenerativeAI(key);
    } else {
      console.warn("GEMINI_API_KEY not set. Mock mode enabled.");
    }
  }

  async generateSection(prompt: string): Promise<string> {
    if (!this.genAI) {
      return this.getMockSection(prompt);
    }

    try {
      const model = this.genAI.getGenerativeModel({
        model: "gemini-2.5-flash",
        systemInstruction: SYSTEM_PROMPT
      });

      const result = await model.generateContent(prompt);
      const response = result.response;
      const text = response.text();

      // Strip markdown code block wrappers if present
      // AI sometimes returns ```liquid ... ``` despite instructions
      return this.stripMarkdownFences(text.trim());
    } catch (error) {
      console.error("Gemini API error:", error);
      // Fallback to mock on error
      return this.getMockSection(prompt);
    }
  }

  /**
   * Strip markdown code block wrappers from AI response
   * Handles: ```liquid ... ```, ```html ... ```, ``` ... ```
   */
  private stripMarkdownFences(text: string): string {
    // Match code block with optional language identifier
    const codeBlockMatch = text.match(/^```(?:liquid|html|)?\s*\n?([\s\S]*?)```\s*$/);
    if (codeBlockMatch) {
      return codeBlockMatch[1].trim();
    }
    return text;
  }

  getMockSection(prompt: string): string {
    return `
{% schema %}
{
  "name": "AI Generated Section",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Hello World"
    },
    {
      "type": "color",
      "id": "bg_color",
      "label": "Background Color",
      "default": "#f5f5f5"
    }
  ],
  "presets": [
    {
      "name": "AI Generated Section"
    }
  ]
}
{% endschema %}

{% style %}
#shopify-section-{{ section.id }} .ai-generated-section {
  padding: 40px 20px;
  text-align: center;
  background-color: {{ section.settings.bg_color }};
}

#shopify-section-{{ section.id }} .ai-generated-section h2 {
  font-size: 2rem;
  margin: 0 0 1rem;
}
{% endstyle %}

<div class="ai-generated-section">
  <h2>{{ section.settings.heading }}</h2>
  <p>This is a mock section for: ${prompt}</p>
</div>
    `.trim();
  }
}

export const aiService = new AIService();
</file>

<file path="package.json">
{
  "name": "ai-section-generator",
  "private": true,
  "scripts": {
    "build": "react-router build",
    "dev": "shopify app dev",
    "config:link": "shopify app config link",
    "generate": "shopify app generate",
    "deploy": "shopify app deploy",
    "config:use": "shopify app config use",
    "env": "shopify app env",
    "start": "react-router-serve ./build/server/index.js",
    "docker-start": "npm run setup && npm run start",
    "setup": "prisma generate && prisma db push --skip-generate",
    "lint": "eslint --ignore-path .gitignore --cache --cache-location ./node_modules/.cache/eslint .",
    "shopify": "shopify",
    "prisma": "prisma",
    "graphql-codegen": "graphql-codegen",
    "vite": "vite",
    "typecheck": "react-router typegen && tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test"
  },
  "type": "module",
  "engines": {
    "node": ">=20.19 <22 || >=22.12"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@prisma/client": "^6.16.3",
    "@react-router/dev": "^7.9.3",
    "@react-router/fs-routes": "^7.9.3",
    "@react-router/node": "^7.9.3",
    "@react-router/serve": "^7.9.3",
    "@shopify/app-bridge-react": "^4.2.4",
    "@shopify/shopify-app-react-router": "^1.0.0",
    "@shopify/shopify-app-session-storage-prisma": "^7.0.0",
    "isbot": "^5.1.31",
    "liquidjs": "^10.24.0",
    "prisma": "^6.16.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router": "^7.9.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "devDependencies": {
    "@playwright/test": "^1.57.0",
    "@shopify/api-codegen-preset": "^1.2.0",
    "@shopify/polaris-types": "^1.0.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/eslint": "^9.6.1",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.18.8",
    "@types/react": "^18.3.25",
    "@types/react-dom": "^18.3.7",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.1",
    "eslint-import-resolver-typescript": "^3.10.1",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^4.6.2",
    "graphql-config": "^5.1.1",
    "jest": "^30.2.0",
    "jest-environment-jsdom": "^30.2.0",
    "prettier": "^3.6.2",
    "ts-jest": "^29.4.5",
    "typescript": "^5.9.3",
    "vite": "^6.3.6",
    "whatwg-fetch": "^3.6.20"
  },
  "workspaces": [
    "extensions/*"
  ],
  "trustedDependencies": [
    "@shopify/plugin-cloudflare"
  ],
  "overrides": {
    "p-map": "^4.0.0",
    "react-router-dom": "npm:react-router@^7.9.3"
  },
  "author": "lmtnolimit"
}
</file>

<file path="shopify.app.toml">
# Learn more about configuring your app at https://shopify.dev/docs/apps/tools/cli/configuration

client_id = "7ecb57c3cbe103bb659936a2841c60b4"
name = "Blocksmith"
handle = "blocksmith-ai"
application_url = "https://blocksmith.m8lab.co"
embedded = true

[build]
automatically_update_urls_on_dev = true

[webhooks]
api_version = "2026-01"

  [[webhooks.subscriptions]]
  topics = [ "app/scopes_update" ]
  uri = "/webhooks/app/scopes_update"

  [[webhooks.subscriptions]]
  topics = [ "app/uninstalled" ]
  uri = "/webhooks/app/uninstalled"

  [[webhooks.subscriptions]]
  topics = [ "app_subscriptions/update" ]
  uri = "/webhooks/app/subscriptions_update"

[access_scopes]
# Learn more at https://shopify.dev/docs/apps/tools/cli/configuration#access_scopes
scopes = "write_products,write_themes,write_files"

[auth]
redirect_urls = [ "https://blocksmith.m8lab.co/api/auth" ]
</file>

<file path="app/components/generate/GeneratePreviewColumn.tsx">
import { useState } from "react";
import { CodePreview } from "./CodePreview";
import { LoadingState } from "./LoadingState";
import { EmptyState } from "./EmptyState";
import { ThemeSelector } from "./ThemeSelector";
import { SectionNameInput } from "./SectionNameInput";
import { SectionPreview, PreviewErrorBoundary } from "../preview";
import type { Theme } from "../../types";

export interface GeneratePreviewColumnProps {
  generatedCode: string;
  themes: Theme[];
  selectedTheme: string;
  onThemeChange: (themeId: string) => void;
  fileName: string;
  onFileNameChange: (name: string) => void;
  // For Create page - two save options
  onSaveDraft?: () => void;
  onPublish?: () => void;
  isSavingDraft?: boolean;
  isPublishing?: boolean;
  canPublish?: boolean;
  // For Edit page - single save to theme
  onSave?: () => void;
  isSaving?: boolean;
  canSave?: boolean;
  // Common
  onSaveAsTemplate?: () => void;
  isGenerating?: boolean;
}

/**
 * Secondary column for generate screen (following Details pattern)
 * Contains code preview, theme selector, filename input, and save button
 * Shows supporting information: status, metadata, summaries
 */
export function GeneratePreviewColumn({
  generatedCode,
  themes,
  selectedTheme,
  onThemeChange,
  fileName,
  onFileNameChange,
  // Create page props
  onSaveDraft,
  onPublish,
  isSavingDraft = false,
  isPublishing = false,
  canPublish = false,
  // Edit page props
  onSave,
  isSaving = false,
  canSave = false,
  // Common
  onSaveAsTemplate,
  isGenerating = false,
}: GeneratePreviewColumnProps) {
  // Determine if we're in "Create" mode (has draft option) or "Edit" mode (single save)
  const isCreateMode = Boolean(onSaveDraft);
  const isAnyActionLoading = isSavingDraft || isPublishing || isSaving;
  // Tab state for Code/Preview toggle - must be at top level
  const [activeTab, setActiveTab] = useState<"code" | "preview">("preview");

  // Show loading state during generation
  if (isGenerating) {
    return (
      <s-section heading="Preview">
        <LoadingState
          message="Generating section code..."
          subMessage="This may take 10-15 seconds"
        />
      </s-section>
    );
  }

  // Show empty state if no code generated yet
  if (!generatedCode) {
    return (
      <s-section heading="Preview">
        <EmptyState
          heading="No code yet"
          message="Enter a prompt or choose a template to get started."
          icon=""
        />
      </s-section>
    );
  }

  // Show code preview and save controls
  return (
    <>
      {/* Code/Preview Card with Tabs */}
      <s-section>
        {/* Tab buttons */}
        <s-stack gap="base" direction="block">
          <div style={{ display: "flex", gap: "4px" }}>
            <s-button
              variant={activeTab === "preview" ? "primary" : "tertiary"}
              onClick={() => setActiveTab("preview")}
            >
              Preview
            </s-button>
            <s-button
              variant={activeTab === "code" ? "primary" : "tertiary"}
              onClick={() => setActiveTab("code")}
            >
              Code
            </s-button>
          </div>

          {/* Tab content */}
          {activeTab === "code" ? (
            <CodePreview code={generatedCode} fileName={fileName} />
          ) : (
            <PreviewErrorBoundary onRetry={() => {}}>
              <SectionPreview liquidCode={generatedCode} />
            </PreviewErrorBoundary>
          )}
        </s-stack>
      </s-section>

      {/* Save Options */}
      <s-section heading={isCreateMode ? "Save Options" : "Save to Theme"}>
        <s-stack gap="large" direction="block">
          {/* Theme selector and file name - always shown */}
          <ThemeSelector
            themes={themes}
            selectedThemeId={selectedTheme}
            onChange={onThemeChange}
            disabled={isAnyActionLoading}
          />

          <SectionNameInput
            value={fileName}
            onChange={onFileNameChange}
            disabled={isAnyActionLoading}
          />

          {/* Create Mode: Save Draft + Publish buttons side by side */}
          {isCreateMode && (
            <s-stack gap="small-100" direction="inline">
              {onSaveDraft && (
                <s-button
                  variant="secondary"
                  onClick={onSaveDraft}
                  loading={isSavingDraft || undefined}
                  disabled={!generatedCode || isAnyActionLoading}
                >
                  Save Draft
                </s-button>
              )}
              {onPublish && (
                <s-button
                  variant="primary"
                  onClick={onPublish}
                  loading={isPublishing || undefined}
                  disabled={!canPublish || isAnyActionLoading}
                >
                  Publish to Theme
                </s-button>
              )}
            </s-stack>
          )}

          {/* Edit Mode: Single Save button */}
          {!isCreateMode && onSave && (
            <s-button
              variant="primary"
              onClick={onSave}
              loading={isSaving || undefined}
              disabled={!canSave || isAnyActionLoading}
            >
              Save to Theme
            </s-button>
          )}

          {/* Save as Template - available in both modes */}
          {onSaveAsTemplate && (
            <s-button
              variant="tertiary"
              onClick={onSaveAsTemplate}
              disabled={!generatedCode || isAnyActionLoading}
            >
              Save as Template
            </s-button>
          )}
        </s-stack>
      </s-section>
    </>
  );
}
</file>

<file path="app/components/preview/settings/SettingsPanel.tsx">
import { useState } from 'react';
import type { SchemaSetting, SettingsState, BlockInstance, SchemaDefinition } from '../schema/SchemaTypes';
import type { SelectedResource } from '../ResourceSelector';
import type { DeviceSize } from '../types';
import { SettingField } from './SettingField';
import { ImagePickerModal } from './ImagePickerModal';


export interface SettingsPanelProps {
  settings: SchemaSetting[];
  values: SettingsState;
  onChange: (values: SettingsState) => void;
  disabled?: boolean;
  schema?: SchemaDefinition | null;
  blocks?: BlockInstance[];
  onBlockSettingChange?: (blockIndex: number, settingId: string, value: string | number | boolean) => void;
  // Resource setting props
  resourceSettings?: Record<string, SelectedResource | null>;
  onResourceSelect?: (settingId: string, resourceId: string | null, resource: SelectedResource | null) => void;
  isLoadingResource?: boolean;
  // Multi-select resource props
  multiResourceSettings?: Record<string, SelectedResource[]>;
  onMultiResourceSelect?: (settingId: string, resources: SelectedResource[]) => void;
  // Preview controls (formerly in toolbar)
  deviceSize?: DeviceSize;
  onDeviceSizeChange?: (size: DeviceSize) => void;
  onRefresh?: () => void;
  isRendering?: boolean;

}

/**
 * Collapsible panel displaying schema settings form using Polaris Web Components
 */
export function SettingsPanel({
  settings,
  values,
  onChange,
  disabled,
  schema,
  blocks,
  onBlockSettingChange,
  resourceSettings,
  onResourceSelect,
  isLoadingResource,
  multiResourceSettings,
  onMultiResourceSelect,
  // Preview controls
  deviceSize = 'desktop',
  onDeviceSizeChange,
  onRefresh,
  isRendering
}: SettingsPanelProps) {
  const [isExpanded, setIsExpanded] = useState(true);
  const [expandedBlocks, setExpandedBlocks] = useState<Record<string, boolean>>({});

  // Local multi-resource state if not provided externally
  const [localMultiResourceSettings, setLocalMultiResourceSettings] = useState<Record<string, SelectedResource[]>>({});

  // Use external state if provided, otherwise use local state
  const effectiveMultiResourceSettings = multiResourceSettings ?? localMultiResourceSettings;
  const handleMultiResourceSelect = onMultiResourceSelect ?? ((settingId: string, resources: SelectedResource[]) => {
    setLocalMultiResourceSettings(prev => ({
      ...prev,
      [settingId]: resources
    }));
  });



  // Preview controls toolbar (always shown)
  const previewControls = (
    <div style={{ paddingBottom: '16px', borderBottom: '1px solid #e1e3e5', marginBottom: '16px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '12px' }}>
        {/* Device size selector */}
        {onDeviceSizeChange && (
          <div style={{ display: 'flex', gap: '4px' }}>
            <s-button
              variant={deviceSize === 'mobile' ? 'primary' : 'secondary'}
              onClick={() => onDeviceSizeChange('mobile')}
            >
              Mobile
            </s-button>
            <s-button
              variant={deviceSize === 'tablet' ? 'primary' : 'secondary'}
              onClick={() => onDeviceSizeChange('tablet')}
            >
              Tablet
            </s-button>
            <s-button
              variant={deviceSize === 'desktop' ? 'primary' : 'secondary'}
              onClick={() => onDeviceSizeChange('desktop')}
            >
              Desktop
            </s-button>
          </div>
        )}

        <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>

          {/* Refresh button */}
          {onRefresh && (
            <s-button
              variant="secondary"
              onClick={onRefresh}
              disabled={isRendering || undefined}
              loading={isRendering || undefined}
            >
              Refresh
            </s-button>
          )}
        </div>
      </div>
    </div>
  );

  if (settings.length === 0 && (!blocks || blocks.length === 0)) {
    return (
      <div style={{
        backgroundColor: '#fff',
        border: '1px solid #e1e3e5',
        borderRadius: '8px',
        padding: '16px'
      }}>
        {previewControls}
        <span style={{ color: '#6d7175' }}>
          No customizable settings found in section schema.
        </span>
      </div>
    );
  }

  const toggleBlockExpanded = (blockId: string) => {
    setExpandedBlocks(prev => ({
      ...prev,
      [blockId]: !prev[blockId]
    }));
  };

  const getBlockTitle = (block: BlockInstance, blockDef: { name?: string } | undefined) => {
    const settingsTitle = block.settings.heading || block.settings.title || block.settings.text;
    return String(settingsTitle || blockDef?.name || block.type);
  };

  const handleFieldChange = (id: string, value: string | number | boolean) => {
    onChange({
      ...values,
      [id]: value
    });
  };

  const handleResetDefaults = () => {
    const defaults: SettingsState = {};
    for (const setting of settings) {
      if (setting.default !== undefined) {
        defaults[setting.id] = setting.default;
      } else {
        switch (setting.type) {
          case 'checkbox':
            defaults[setting.id] = false;
            break;
          case 'number':
          case 'range':
            defaults[setting.id] = setting.min ?? 0;
            break;
          case 'color':
          case 'color_background':
            defaults[setting.id] = '#000000';
            break;
          case 'select':
          case 'radio':
            defaults[setting.id] = setting.options?.[0]?.value ?? '';
            break;
          case 'font_picker':
            defaults[setting.id] = 'system-ui';
            break;
          case 'text_alignment':
            defaults[setting.id] = 'left';
            break;
          case 'collection_list':
          case 'product_list':
            defaults[setting.id] = '[]';
            break;
          default:
            defaults[setting.id] = '';
        }
      }
    }
    onChange(defaults);
  };

  return (
    <div style={{
      backgroundColor: '#fff',
      border: '1px solid #e1e3e5',
      borderRadius: '8px',
      padding: '16px'
    }}>
      {/* Preview controls */}
      {previewControls}

      {/* Info Banner */}
      <div style={{ marginBottom: '16px' }}>
        <s-banner tone="info">
          <strong>Preview Mode</strong>  These settings are for testing only.
          To customize your section in production, use the Shopify Theme Editor
          after saving this section to your theme.
        </s-banner>
      </div>

      <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
        {/* Settings header */}
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontSize: '14px', fontWeight: 600 }}>
            Preview Settings ({settings.length})
          </span>
          <div style={{ display: 'flex', gap: '8px' }}>
            <s-button
              variant="secondary"
              onClick={handleResetDefaults}
              disabled={disabled || undefined}
            >
              Reset
            </s-button>
            <s-button
              variant="secondary"
              onClick={() => setIsExpanded(!isExpanded)}
            >
              {isExpanded ? 'Collapse' : 'Expand'}
            </s-button>
          </div>
        </div>

        {/* Settings form */}
        {isExpanded && settings.length > 0 && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
            {settings.map((setting) => (
              <SettingField
                key={setting.id}
                setting={setting}
                value={values[setting.id]}
                onChange={handleFieldChange}
                disabled={disabled}
                resourceSettings={resourceSettings}
                onResourceSelect={onResourceSelect}
                isLoadingResource={isLoadingResource}
                multiResourceSettings={effectiveMultiResourceSettings}
                onMultiResourceSelect={handleMultiResourceSelect}
              />
            ))}
          </div>
        )}

        {/* Block Settings */}
        {isExpanded && blocks && blocks.length > 0 && (
          <div style={{ marginTop: settings.length > 0 ? '16px' : 0 }}>
            {settings.length > 0 && (
              <div style={{ borderTop: '1px solid #e1e3e5', paddingTop: '16px' }} />
            )}
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              <span style={{ fontSize: '14px', fontWeight: 600 }}>
                Blocks ({blocks.length})
              </span>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {blocks.map((block, blockIndex) => {
                  const blockDef = schema?.blocks?.find(b => b.type === block.type);
                  const blockSettings = blockDef?.settings || [];

                  if (blockSettings.length === 0) return null;

                  const isBlockExpanded = expandedBlocks[block.id] ?? false;
                  const blockTitle = getBlockTitle(block, blockDef);

                  return (
                    <div
                      key={block.id}
                      style={{
                        backgroundColor: '#f6f6f7',
                        border: '1px solid #e1e3e5',
                        borderRadius: '6px',
                        overflow: 'hidden'
                      }}
                    >
                      {/* Block Header */}
                      <button
                        onClick={() => toggleBlockExpanded(block.id)}
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          backgroundColor: 'transparent',
                          border: 'none',
                          cursor: 'pointer',
                          textAlign: 'left'
                        }}
                      >
                        <span style={{ fontSize: '13px', fontWeight: 500, color: '#202223' }}>
                          {blockTitle} #{blockIndex + 1}
                        </span>
                        <span style={{
                          fontSize: '12px',
                          color: '#6d7175',
                          transform: isBlockExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                          transition: 'transform 0.2s'
                        }}>
                          
                        </span>
                      </button>

                      {/* Block Settings */}
                      {isBlockExpanded && (
                        <div style={{
                          padding: '12px',
                          borderTop: '1px solid #e1e3e5',
                          backgroundColor: '#fff',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '12px'
                        }}>
                          {blockSettings.map((setting) => (
                            <SettingField
                              key={`${block.id}-${setting.id}`}
                              setting={setting}
                              value={block.settings[setting.id] ?? ''}
                              onChange={(_id, value) => {
                                onBlockSettingChange?.(blockIndex, setting.id, value);
                              }}
                              disabled={disabled}
                              multiResourceSettings={effectiveMultiResourceSettings}
                              onMultiResourceSelect={handleMultiResourceSelect}
                              blockId={block.id}
                            />
                          ))}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Image Picker Modal - rendered once at SettingsPanel level */}
      <ImagePickerModal />
    </div>
  );
}
</file>

<file path="app/components/preview/SectionPreview.tsx">
import { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { PreviewFrame } from './PreviewFrame';
import { useLiquidRenderer } from './hooks/useLiquidRenderer';
import { usePreviewMessaging } from './hooks/usePreviewMessaging';
import { useResourceFetcher } from './hooks/useResourceFetcher';
import { parseSchema, extractSettings, buildInitialState, buildBlockInstancesFromPreset } from './schema/parseSchema';
import { SettingsPanel } from './settings/SettingsPanel';
import { buildPreviewContext } from './utils/buildPreviewContext';
import type { DeviceSize, PreviewMessage, PreviewSettings } from './types';
import type { SchemaSetting, SettingsState, SchemaDefinition, BlockInstance } from './schema/SchemaTypes';
import type { MockProduct, MockCollection } from './mockData/types';
import type { SelectedResource } from './ResourceSelector';

export interface SectionPreviewProps {
  liquidCode: string;
  onSettingsChange?: (settings: PreviewSettings) => void;
}

/**
 * Main section preview component
 * Renders Liquid code in sandboxed iframe with settings editor
 */
export function SectionPreview({
  liquidCode,
  onSettingsChange
}: SectionPreviewProps) {
  const [deviceSize, setDeviceSize] = useState<DeviceSize>('desktop');
  const [error, setError] = useState<string | null>(null);

  // Settings-based resources (from schema settings with type: product/collection)
  const [settingsResourceSelections, setSettingsResourceSelections] = useState<Record<string, SelectedResource | null>>({});
  const [settingsResources, setSettingsResources] = useState<Record<string, MockProduct | MockCollection>>({});
  const [isLoadingSettingsResource, setIsLoadingSettingsResource] = useState(false);

  // Resource fetching hook
  const { fetchProduct, fetchCollection, error: fetchError } = useResourceFetcher();

  // Parse schema from liquid code
  const parsedSchema = useMemo<SchemaDefinition | null>(
    () => parseSchema(liquidCode),
    [liquidCode]
  );

  const schemaSettings = useMemo<SchemaSetting[]>(
    () => extractSettings(parsedSchema),
    [parsedSchema]
  );

  const [settingsValues, setSettingsValues] = useState<SettingsState>(() =>
    buildInitialState(schemaSettings)
  );

  // Block state management
  const [blocksState, setBlocksState] = useState<BlockInstance[]>([]);

  // Reset settings when schema changes
  useEffect(() => {
    setSettingsValues(buildInitialState(schemaSettings));
  }, [schemaSettings]);

  // Initialize blocks from schema
  useEffect(() => {
    const blocks = buildBlockInstancesFromPreset(parsedSchema);
    setBlocksState(blocks);
  }, [parsedSchema]);

  const { render, isRendering } = useLiquidRenderer();
  const { sendMessage, setIframe } = usePreviewMessaging(
    useCallback((msg: PreviewMessage) => {
      if (msg.type === 'RESIZE' && msg.height) {
        // Could use this to auto-adjust iframe height
      }
    }, [])
  );

  // Debounced render
  const renderTimeoutRef = useRef<NodeJS.Timeout>();

  const triggerRender = useCallback(async () => {
    if (!liquidCode.trim()) {
      sendMessage({ type: 'RENDER', html: '<p style="color: #6d7175; text-align: center;">No code to preview</p>', css: '' });
      return;
    }

    try {
      setError(null);

      // Build context with settings-based resources
      // Extract collection/product from settingsResources to also provide as global context
      // This is needed because AI-generated templates use `collection.products` (global), not just section.settings
      let collectionFromSettings: import('./mockData/types').MockCollection | null = null;
      let productFromSettings: import('./mockData/types').MockProduct | null = null;

      for (const [, resource] of Object.entries(settingsResources)) {
        // Check if it's a collection (has products array)
        if ('products' in resource && Array.isArray((resource as { products?: unknown }).products)) {
          collectionFromSettings = resource as import('./mockData/types').MockCollection;
        }
        // Check if it's a product (has variants)
        else if ('variants' in resource) {
          productFromSettings = resource as import('./mockData/types').MockProduct;
        }
      }

      const previewData = buildPreviewContext({
        collection: collectionFromSettings,
        product: productFromSettings,
        settingsResources
      });

      const { html, css } = await render(liquidCode, settingsValues, blocksState, previewData as unknown as Record<string, unknown>);
      sendMessage({ type: 'RENDER', html, css });
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Render failed';
      setError(errorMsg);
      sendMessage({ type: 'RENDER_ERROR', error: errorMsg });
    }
  }, [liquidCode, settingsValues, blocksState, settingsResources, render, sendMessage]);

  // Debounce renders on code/settings/resource change
  useEffect(() => {
    if (renderTimeoutRef.current) {
      clearTimeout(renderTimeoutRef.current);
    }
    renderTimeoutRef.current = setTimeout(triggerRender, 100);

    return () => {
      if (renderTimeoutRef.current) {
        clearTimeout(renderTimeoutRef.current);
      }
    };
  }, [triggerRender]);

  const handleIframeLoad = useCallback((iframe: HTMLIFrameElement) => {
    setIframe(iframe);
    // Trigger initial render after iframe loads
    setTimeout(triggerRender, 50);
  }, [setIframe, triggerRender]);

  const handleSettingsChange = useCallback((newValues: SettingsState) => {
    setSettingsValues(newValues);
    onSettingsChange?.(newValues);
  }, [onSettingsChange]);

  // Block setting change handler
  const handleBlockSettingChange = useCallback(
    (blockIndex: number, settingId: string, value: string | number | boolean) => {
      setBlocksState(prev => {
        const updated = [...prev];
        updated[blockIndex] = {
          ...updated[blockIndex],
          settings: {
            ...updated[blockIndex].settings,
            [settingId]: value
          }
        };
        return updated;
      });
    },
    []
  );

  // Settings resource selection handler (for schema-based resource settings)
  const handleSettingsResourceSelect = useCallback(async (
    settingId: string,
    resourceId: string | null,
    resource: SelectedResource | null
  ) => {
    // Update selection UI state
    setSettingsResourceSelections(prev => ({
      ...prev,
      [settingId]: resource
    }));

    if (!resourceId) {
      // Clear the resource data
      setSettingsResources(prev => {
        const updated = { ...prev };
        delete updated[settingId];
        return updated;
      });
      return;
    }

    // Find the setting type to know what kind of resource to fetch
    const setting = schemaSettings.find(s => s.id === settingId);
    if (!setting) return;

    setIsLoadingSettingsResource(true);
    try {
      let data: MockProduct | MockCollection | null = null;

      if (setting.type === 'product') {
        data = await fetchProduct(resourceId);
      } else if (setting.type === 'collection') {
        data = await fetchCollection(resourceId);
      }

      if (data) {
        setSettingsResources(prev => ({
          ...prev,
          [settingId]: data
        }));
      }
    } finally {
      setIsLoadingSettingsResource(false);
    }
  }, [schemaSettings, fetchProduct, fetchCollection]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl/Cmd + R: Refresh preview (prevent page reload)
      if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
        e.preventDefault();
        triggerRender();
      }
      // Ctrl/Cmd + 1/2/3: Switch device size
      if ((e.ctrlKey || e.metaKey) && ['1', '2', '3'].includes(e.key)) {
        e.preventDefault();
        const sizes: DeviceSize[] = ['mobile', 'tablet', 'desktop'];
        setDeviceSize(sizes[parseInt(e.key) - 1]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [triggerRender]);

  // Combine errors
  const displayError = error || fetchError;

  return (
    <s-stack gap="large" direction="block">
      {/* Settings panel with preview controls */}
      <SettingsPanel
        settings={schemaSettings}
        values={settingsValues}
        onChange={handleSettingsChange}
        disabled={isRendering}
        schema={parsedSchema}
        blocks={blocksState}
        onBlockSettingChange={handleBlockSettingChange}
        resourceSettings={settingsResourceSelections}
        onResourceSelect={handleSettingsResourceSelect}
        isLoadingResource={isLoadingSettingsResource}
        // Preview controls (formerly in toolbar)
        deviceSize={deviceSize}
        onDeviceSizeChange={setDeviceSize}
        onRefresh={triggerRender}
        isRendering={isRendering}
      />

      {/* Error banner */}
      {displayError && (
        <div style={{
          padding: '12px 16px',
          backgroundColor: '#fff5ea',
          border: '1px solid #ffb84d',
          borderRadius: '8px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}>
          <p style={{ margin: 0, fontSize: '14px' }}>
            Preview error: {displayError}. The code may use unsupported Liquid features.
          </p>
          <button
            onClick={() => setError(null)}
            style={{
              background: 'none',
              border: 'none',
              cursor: 'pointer',
              padding: '4px',
              fontSize: '18px'
            }}
          >
            
          </button>
        </div>
      )}

      {/* Preview frame */}
      <PreviewFrame
        deviceSize={deviceSize}
        onLoad={handleIframeLoad}
      />

      {/* Keyboard shortcuts hint */}
      <p style={{ color: '#6d7175', fontSize: '13px', margin: 0 }}>
        Shortcuts: Ctrl+R refresh, Ctrl+1/2/3 device size
      </p>
    </s-stack>
  );
}
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Session model for Shopify OAuth (MongoDB requires dual ID pattern)
model Session {
  session_id    String   @id @default(auto()) @map("_id") @db.ObjectId
  id            String   @unique // Shopify session ID (e.g., "offline_shop.myshopify.com")
  shop          String
  state         String
  isOnline      Boolean  @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean  @default(false)
  locale        String?
  collaborator  Boolean? @default(false)
  emailVerified Boolean? @default(false)

  @@index([shop])
}

// Section model for AI-generated theme sections
model Section {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  shop         String
  name         String?  // User-friendly section name (auto-generated from prompt if not provided)
  prompt       String
  code         String   // Generated Liquid code
  themeId      String?  // Theme it was saved to (if saved)
  themeName    String?
  fileName     String?

  // Generation metadata
  tone         String?  // professional, casual, friendly
  style        String?  // minimal, bold, elegant

  // Status
  status       String   @default("generated") // generated, saved, error
  isFavorite   Boolean  @default(false)

  createdAt    DateTime @default(now())

  @@index([shop])
  @@index([createdAt])
  @@index([status])
}

// Section templates for reusable prompts and generated code
model SectionTemplate {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  shop        String   // Merchant who owns template
  title       String
  description String
  category    String   // marketing, product, content, layout
  icon        String   // Emoji or icon identifier
  prompt      String   // Original generation prompt
  code        String?  // Liquid code (optional - can be prompt-only)
  isFavorite  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([shop])
  @@index([category])
}

// Shop-level settings (onboarding, preferences)
model ShopSettings {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  shop                 String   @unique
  hasViewedHistory     Boolean  @default(false)
  onboardingDismissed  Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// Subscription tracking for Shopify App Billing
model Subscription {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  shop              String   // Multiple subscriptions per shop allowed (pending, active, cancelled)
  shopifySubId      String   @unique // Shopify GraphQL subscription ID (e.g., gid://shopify/AppSubscription/123)
  planName          String   // starter, growth, professional
  status            String   // active, cancelled, expired, pending
  currentPeriodEnd  DateTime
  trialEndsAt       DateTime? // Free trial end date (null if no trial)

  // Pricing
  basePrice         Float    // Monthly base charge (USD)
  includedQuota     Int      // Included generations per billing cycle
  overagePrice      Float    // Price per additional generation (USD)
  cappedAmount      Float    // Max overage charge (USD)

  // Usage tracking (current billing cycle)
  usageThisCycle    Int      @default(0)
  overagesThisCycle Int      @default(0)

  // Cache Shopify usage line item ID for faster charge recording
  usageLineItemId   String?  // Shopify usage line item GID

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([shop, status, createdAt])
  @@index([status])
  @@index([currentPeriodEnd])
}

// Usage records sent to Shopify for billing
model UsageRecord {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  shop            String
  subscriptionId  String   @db.ObjectId // Link to Subscription model
  sectionId       String   @db.ObjectId // Link to Section
  idempotencyKey  String   @unique // Prevent duplicate charges: ${shop}-${generationId}-${timestamp}

  // Charge details
  amount          Float    // Charge amount (USD)
  description     String   // "Section generation - Hero banner"
  billingCycle    DateTime // Which billing cycle this belongs to

  // Shopify API response
  shopifyChargeId String?  // Shopify usage charge ID (null if not yet sent)
  chargeStatus    String   @default("pending") // pending, accepted, declined, error
  errorMessage    String?  // If charge failed

  createdAt       DateTime @default(now())
  sentAt          DateTime? // When sent to Shopify

  @@index([shop])
  @@index([subscriptionId])
  @@index([chargeStatus])
  @@index([createdAt])
}

// Plan configuration (pricing tiers)
model PlanConfiguration {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  planName      String   @unique // starter, growth, professional
  displayName   String   // "Starter", "Growth", "Professional"
  description   String   // Short description for UI

  // Pricing
  basePrice     Float    // Monthly base charge (USD)
  includedQuota Int      // Included generations
  overagePrice  Float    // Price per overage generation
  cappedAmount  Float    // Max total monthly charge

  // Features
  features      String[] // Array of feature descriptions for UI

  // Display
  badge         String?  // "Popular", "Best Value" (null if none)
  sortOrder     Int      @default(0) // Display order (lower = first)
  isActive      Boolean  @default(true) // Can merchants subscribe?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([sortOrder])
}

// Failed usage charges for recovery/reconciliation
model FailedUsageCharge {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  shop          String
  sectionId     String   @db.ObjectId
  errorMessage  String
  retryCount    Int      @default(0)
  createdAt     DateTime @default(now())
  retriedAt     DateTime?

  @@index([shop])
  @@index([createdAt])
  @@index([retryCount])
}
</file>

<file path="README.md">
# AI Section Generator - Shopify App

Generate custom Shopify Liquid theme sections using AI (Google Gemini). Describe what you want in natural language, get production-ready Liquid code, and save it directly to your theme.

Built with [React Router](https://reactrouter.com/), [Prisma](https://www.prisma.io/), and [Google Gemini AI](https://ai.google.dev/).

## What is this?

AI Section Generator is a Shopify embedded app that lets merchants create custom theme sections without coding:

1. Describe the section you want (e.g., "A hero section with background image and call-to-action button")
2. AI generates complete Liquid code with schema, styles, and markup
3. Preview the generated code
4. Select a theme and save the section directly

## Features

- **AI-Powered Generation**: Uses Google Gemini 2.5 Flash to generate Shopify Liquid sections
- **Theme Integration**: Fetches merchant themes and saves sections via Shopify Admin API
- **Dual-Action Save**: Save Draft or Publish to Theme with immediate redirect
- **Code Preview**: Review generated code with syntax highlighting before saving
- **Section Editing**: Edit saved sections and regenerate code without losing history
- **Polaris Web Components**: Native Shopify admin experience using `<s-*>` elements

## Documentation

- [Project Overview & PDR](docs/project-overview-pdr.md) - Product requirements, architecture, and roadmap
- [Codebase Summary](docs/codebase-summary.md) - Detailed codebase walkthrough and file structure
- [Code Standards](docs/code-standards.md) - Development guidelines and best practices
- [System Architecture](docs/system-architecture.md) - Technical architecture and data flows

## Project Status

**Current Version**: 1.0 (Development)

**Completed (Phase 3)** - 96% Complete:
-  AI section generation with Google Gemini 2.5 Flash
-  Theme fetching and selection
-  Dual-action save flow (Save Draft + Publish to Theme)
-  Redirect after save with toast notifications
-  Edit saved sections with regeneration capability
-  Section code preview with syntax highlighting
-  Polaris UI implementation with Web Components (`<s-*>`)
-  Authentication and session management
-  Feature flag system with adapter pattern
-  TypeScript type safety for services and APIs
-  Component-based architecture (9 reusable UI components)
-  Comprehensive error handling and user feedback

**Pending**:
-  Production deployment
-  Scope approval (write_themes) from Shopify

**Future Enhancements** (Phase 4+):
- Section template library with auto-seeding
- Section history and versioning
- Section marketplace and sharing
- Advanced customization options
- Batch section generation

## Quick start

### Prerequisites

Before you begin, you'll need the following:

1. **Node.js**: [Download and install](https://nodejs.org/en/download/) it if you haven't already.
2. **Shopify Partner Account**: [Create an account](https://partners.shopify.com/signup) if you don't have one.
3. **Test Store**: Set up either a [development store](https://help.shopify.com/en/partners/dashboard/development-stores#create-a-development-store) or a [Shopify Plus sandbox store](https://help.shopify.com/en/partners/dashboard/managing-stores/plus-sandbox-store) for testing your app.
4. **Shopify CLI**: [Download and install](https://shopify.dev/docs/apps/tools/cli/getting-started) it if you haven't already.
```shell
npm install -g @shopify/cli@latest
```

### Setup

```shell
shopify app init --template=https://github.com/Shopify/shopify-app-template-react-router
```

### Local Development

```shell
shopify app dev
```

Press P to open the URL to your app. Once you click install, you can start development.

Local development is powered by [the Shopify CLI](https://shopify.dev/docs/apps/tools/cli). It logs into your partners account, connects to an app, provides environment variables, updates remote config, creates a tunnel and provides commands to generate extensions.

### Environment Variables

#### Core Configuration

- `GEMINI_API_KEY`: Your Google AI Studio API key ([Get one here](https://aistudio.google.com/app/apikey))
  - Required for AI-powered section generation

#### Feature Flags (Optional)

Control app behavior with feature flag environment variables (prefix: `FLAG_`):

- `FLAG_VERBOSE_LOGGING=true` - Enable detailed service logging (default: enabled in dev)

**Example `.env` for development**:
```bash
# API Keys
GEMINI_API_KEY=your_gemini_api_key_here

# Debug Features
FLAG_VERBOSE_LOGGING=true
```

### Authenticating and querying data

To authenticate and query data you can use the `shopify` const that is exported from `/app/shopify.server.js`:

```js
export async function loader({ request }) {
  const { admin } = await shopify.authenticate.admin(request);

  const response = await admin.graphql(`
    {
      products(first: 25) {
        nodes {
          title
          description
        }
      }
    }`);

  const {
    data: {
      products: { nodes },
    },
  } = await response.json();

  return nodes;
}
```

This template comes pre-configured with examples of:

1. Setting up your Shopify app in [/app/shopify.server.ts](https://github.com/Shopify/shopify-app-template-react-router/blob/main/app/shopify.server.ts)
2. Querying data using Graphql. Please see: [/app/routes/app.\_index.tsx](https://github.com/Shopify/shopify-app-template-react-router/blob/main/app/routes/app._index.tsx).
3. Responding to webhooks. Please see [/app/routes/webhooks.tsx](https://github.com/Shopify/shopify-app-template-react-router/blob/main/app/routes/webhooks.app.uninstalled.tsx).

Please read the [documentation for @shopify/shopify-app-react-router](https://shopify.dev/docs/api/shopify-app-react-router) to see what other API's are available.

## Shopify Dev MCP

This template is configured with the Shopify Dev MCP. This instructs [Cursor](https://cursor.com/), [GitHub Copilot](https://github.com/features/copilot) and [Claude Code](https://claude.com/product/claude-code) and [Google Gemini CLI](https://github.com/google-gemini/gemini-cli) to use the Shopify Dev MCP.  

For more information on the Shopify Dev MCP please read [the  documentation](https://shopify.dev/docs/apps/build/devmcp).

## Deployment

### Application Storage

This template uses [Prisma](https://www.prisma.io/) to store session data, by default using an [SQLite](https://www.sqlite.org/index.html) database.
The database is defined as a Prisma schema in `prisma/schema.prisma`.

This use of SQLite works in production if your app runs as a single instance.
The database that works best for you depends on the data your app needs and how it is queried.
Heres a short list of databases providers that provide a free tier to get started:

| Database   | Type             | Hosters                                                                                                                                                                                                                               |
| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | SQL              | [Digital Ocean](https://www.digitalocean.com/products/managed-databases-mysql), [Planet Scale](https://planetscale.com/), [Amazon Aurora](https://aws.amazon.com/rds/aurora/), [Google Cloud SQL](https://cloud.google.com/sql/docs/mysql) |
| PostgreSQL | SQL              | [Digital Ocean](https://www.digitalocean.com/products/managed-databases-postgresql), [Amazon Aurora](https://aws.amazon.com/rds/aurora/), [Google Cloud SQL](https://cloud.google.com/sql/docs/postgres)                                   |
| Redis      | Key-value        | [Digital Ocean](https://www.digitalocean.com/products/managed-databases-redis), [Amazon MemoryDB](https://aws.amazon.com/memorydb/)                                                                                                        |
| MongoDB    | NoSQL / Document | [Digital Ocean](https://www.digitalocean.com/products/managed-databases-mongodb), [MongoDB Atlas](https://www.mongodb.com/atlas/database)                                                                                                  |

To use one of these, you can use a different [datasource provider](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#datasource) in your `schema.prisma` file, or a different [SessionStorage adapter package](https://github.com/Shopify/shopify-api-js/blob/main/packages/shopify-api/docs/guides/session-storage.md).

### Build

Build the app by running the command below with the package manager of your choice:

Using yarn:

```shell
yarn build
```

Using npm:

```shell
npm run build
```

Using pnpm:

```shell
pnpm run build
```

## Hosting

When you're ready to set up your app in production, you can follow [our deployment documentation](https://shopify.dev/docs/apps/launch/deployment) to host it externally. From there, you have a few options:

- [Google Cloud Run](https://shopify.dev/docs/apps/launch/deployment/deploy-to-google-cloud-run): This tutorial is written specifically for this example repo, and is compatible with the extended steps included in the subsequent [**Build your app**](tutorial) in the **Getting started** docs. It is the most detailed tutorial for taking a React Router-based Shopify app and deploying it to production. It includes configuring permissions and secrets, setting up a production database, and even hosting your apps behind a load balancer across multiple regions. 
- [Fly.io](https://fly.io/docs/js/shopify/): Leverages the Fly.io CLI to quickly launch Shopify apps to a single machine. 
- [Render](https://render.com/docs/deploy-shopify-app): This tutorial guides you through using Docker to deploy and install apps on a Dev store. 
- [Manual deployment guide](https://shopify.dev/docs/apps/launch/deployment/deploy-to-hosting-service): This resource provides general guidance on the requirements of deployment including environment variables, secrets, and persistent data. 

When you reach the step for [setting up environment variables](https://shopify.dev/docs/apps/deployment/web#set-env-vars), you also need to set the variable `NODE_ENV=production`.

## Gotchas / Troubleshooting

### Database tables don't exist

If you get an error like:

```
The table `main.Session` does not exist in the current database.
```

Create the database for Prisma. Run the `setup` script in `package.json` using `npm`, `yarn` or `pnpm`.

### Navigating/redirecting breaks an embedded app

Embedded apps must maintain the user session, which can be tricky inside an iFrame. To avoid issues:

1. Use `Link` from `react-router` or `@shopify/polaris`. Do not use `<a>`.
2. Use `redirect` returned from `authenticate.admin`. Do not use `redirect` from `react-router`
3. Use `useSubmit` from `react-router`.

This only applies if your app is embedded, which it will be by default.

### Webhooks: shop-specific webhook subscriptions aren't updated

If you are registering webhooks in the `afterAuth` hook, using `shopify.registerWebhooks`, you may find that your subscriptions aren't being updated.  

Instead of using the `afterAuth` hook declare app-specific webhooks in the `shopify.app.toml` file.  This approach is easier since Shopify will automatically sync changes every time you run `deploy` (e.g: `npm run deploy`).  Please read these guides to understand more:

1. [app-specific vs shop-specific webhooks](https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-subscriptions)
2. [Create a subscription tutorial](https://shopify.dev/docs/apps/build/webhooks/subscribe/get-started?deliveryMethod=https)

If you do need shop-specific webhooks, keep in mind that the package calls `afterAuth` in 2 scenarios:

- After installing the app
- When an access token expires

During normal development, the app won't need to re-authenticate most of the time, so shop-specific subscriptions aren't updated. To force your app to update the subscriptions, uninstall and reinstall the app. Revisiting the app will call the `afterAuth` hook.

### Webhooks: Admin created webhook failing HMAC validation

Webhooks subscriptions created in the [Shopify admin](https://help.shopify.com/en/manual/orders/notifications/webhooks) will fail HMAC validation. This is because the webhook payload is not signed with your app's secret key.  

The recommended solution is to use [app-specific webhooks](https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-subscriptions) defined in your toml file instead.  Test your webhooks by triggering events manually in the Shopify admin(e.g. Updating the product title to trigger a `PRODUCTS_UPDATE`).

### Webhooks: Admin object undefined on webhook events triggered by the CLI

When you trigger a webhook event using the Shopify CLI, the `admin` object will be `undefined`. This is because the CLI triggers an event with a valid, but non-existent, shop. The `admin` object is only available when the webhook is triggered by a shop that has installed the app.  This is expected.

Webhooks triggered by the CLI are intended for initial experimentation testing of your webhook configuration. For more information on how to test your webhooks, see the [Shopify CLI documentation](https://shopify.dev/docs/apps/tools/cli/commands#webhook-trigger).

### Incorrect GraphQL Hints

By default the [graphql.vscode-graphql](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) extension for will assume that GraphQL queries or mutations are for the [Shopify Admin API](https://shopify.dev/docs/api/admin). This is a sensible default, but it may not be true if:

1. You use another Shopify API such as the storefront API.
2. You use a third party GraphQL API.

If so, please update [.graphqlrc.ts](https://github.com/Shopify/shopify-app-template-react-router/blob/main/.graphqlrc.ts).

### Using Defer & await for streaming responses

By default the CLI uses a cloudflare tunnel. Unfortunately  cloudflare tunnels wait for the Response stream to finish, then sends one chunk.  This will not affect production.

To test [streaming using await](https://reactrouter.com/api/components/Await#await) during local development we recommend [localhost based development](https://shopify.dev/docs/apps/build/cli-for-apps/networking-options#localhost-based-development).

### "nbf" claim timestamp check failed

This is because a JWT token is expired.  If you  are consistently getting this error, it could be that the clock on your machine is not in sync with the server.  To fix this ensure you have enabled "Set time and date automatically" in the "Date and Time" settings on your computer.

### Using MongoDB and Prisma

If you choose to use MongoDB with Prisma, there are some gotchas in Prisma's MongoDB support to be aware of. Please see the [Prisma SessionStorage README](https://www.npmjs.com/package/@shopify/shopify-app-session-storage-prisma#mongodb).

## Resources

React Router:

- [React Router docs](https://reactrouter.com/home)

Shopify:

- [Intro to Shopify apps](https://shopify.dev/docs/apps/getting-started)
- [Shopify App React Router docs](https://shopify.dev/docs/api/shopify-app-react-router)
- [Shopify CLI](https://shopify.dev/docs/apps/tools/cli)
- [Shopify App Bridge](https://shopify.dev/docs/api/app-bridge-library).
- [Polaris Web Components](https://shopify.dev/docs/api/app-home/polaris-web-components).
- [App extensions](https://shopify.dev/docs/apps/app-extensions/list)
- [Shopify Functions](https://shopify.dev/docs/api/functions)

Internationalization:

- [Internationalizing your app](https://shopify.dev/docs/apps/best-practices/internationalization/getting-started)
</file>

<file path="app/components/preview/hooks/useLiquidRenderer.ts">
import { useState, useCallback, useRef, useEffect } from 'react';
import { Liquid } from 'liquidjs';
import type { PreviewSettings } from '../types';
import type { BlockInstance } from '../schema/SchemaTypes';
import { BlockDrop } from '../drops';
import { arrayFilters, stringFilters, mathFilters } from '../utils/liquidFilters';
import { colorFilters } from '../utils/colorFilters';
import { mediaFilters } from '../utils/mediaFilters';
import { fontFilters } from '../utils/fontFilters';
import { metafieldFilters } from '../utils/metafieldFilters';
import { utilityFilters } from '../utils/utilityFilters';
import { registerShopifyTags } from '../utils/liquidTags';

interface RenderResult {
  html: string;
  css: string;
}

interface UseLiquidRendererResult {
  render: (template: string, settings: PreviewSettings, blocks?: BlockInstance[], mockData?: Record<string, unknown>) => Promise<RenderResult>;
  isRendering: boolean;
  error: string | null;
}

/**
 * Hook for rendering Liquid templates using LiquidJS
 * Provides Shopify-compatible filter stubs
 */
export function useLiquidRenderer(): UseLiquidRendererResult {
  const engineRef = useRef<Liquid | null>(null);
  const [isRendering, setIsRendering] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Initialize LiquidJS engine once
  useEffect(() => {
    engineRef.current = new Liquid({
      strictFilters: false,
      strictVariables: false
    });

    const engine = engineRef.current;

    // Inline SVG placeholder for broken/missing images (works offline)
    const PLACEHOLDER_IMAGE = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="200" viewBox="0 0 300 200"><rect fill="#f0f0f0" width="300" height="200"/><rect fill="#e0e0e0" x="110" y="60" width="80" height="80" rx="4"/><circle fill="#ccc" cx="130" cy="85" r="8"/><polygon fill="#ccc" points="120,130 150,95 180,130"/><polygon fill="#d0d0d0" points="140,130 160,110 180,130"/></svg>');

    // Register Shopify-specific filter stubs
    engine.registerFilter('img_url', (image: unknown, size?: string) => {
      if (!image) return PLACEHOLDER_IMAGE;
      if (typeof image === 'string') return image;

      // Handle ImageDrop or any object with src property
      const imageObj = image as { src?: string; url?: string; img_url?: (size?: string) => string };

      // Check if it has an img_url method (like ImageDrop)
      if (typeof imageObj.img_url === 'function') {
        return imageObj.img_url(size);
      }

      // Fall back to src or url property
      return imageObj.src || imageObj.url || PLACEHOLDER_IMAGE;
    });

    engine.registerFilter('image_url', (image: unknown, _options?: { width?: number; height?: number } | string) => {
      if (!image || image === 'placeholder') return PLACEHOLDER_IMAGE;
      if (typeof image === 'string') return image;

      // Handle ImageDrop or any object with src property
      const imageObj = image as { src?: string; url?: string };
      const baseUrl = imageObj.src || imageObj.url;

      if (!baseUrl) return PLACEHOLDER_IMAGE;

      // In real Shopify, options would add width/height params
      // For preview, just return the base URL
      return baseUrl;
    });

    engine.registerFilter('money', (cents: number) => {
      const amount = (cents / 100).toFixed(2);
      return `$${amount}`;
    });

    engine.registerFilter('money_with_currency', (cents: number) => {
      const amount = (cents / 100).toFixed(2);
      return `$${amount} USD`;
    });

    engine.registerFilter('money_without_currency', (cents: number) => {
      return (cents / 100).toFixed(2);
    });

    engine.registerFilter('money_without_trailing_zeros', (cents: number) => {
      const amount = cents / 100;
      return `$${amount % 1 === 0 ? amount.toFixed(0) : amount.toFixed(2)}`;
    });

    engine.registerFilter('asset_url', (path: string) => `/assets/${path}`);
    engine.registerFilter('file_url', (filename: string) => `/files/${filename}`);

    engine.registerFilter('t', (key: string) => key);

    engine.registerFilter('handle', (str: string) => {
      return (str || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    });

    engine.registerFilter('handleize', (str: string) => {
      return (str || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    });

    engine.registerFilter('pluralize', (count: number, singular: string, plural: string) => {
      return count === 1 ? singular : plural;
    });

    engine.registerFilter('json', (value: unknown) => JSON.stringify(value));

    engine.registerFilter('date', (dateStr: string) => {
      try {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      } catch {
        return dateStr;
      }
    });

    engine.registerFilter('img_tag', (url: string, alt?: string) => {
      return `<img src="${url}" alt="${alt || ''}" />`;
    });

    engine.registerFilter('link_to', (text: string, url?: string) => {
      // Shopify syntax: {{ 'text' | link_to: '/url' }}
      // text is the pipe input, url is the filter parameter
      return `<a href="${url || '#'}">${text || ''}</a>`;
    });

    // Payment button filter stub - renders placeholder button
    engine.registerFilter('payment_button', () => {
      return `<button type="button" class="shopify-payment-button" style="padding: 12px 24px; background: #5c6ac4; color: white; border: none; border-radius: 4px; cursor: pointer;">Buy with Shop Pay</button>`;
    });

    engine.registerFilter('product_url', (product: { url?: string; handle?: string }) => {
      return product?.url || `/products/${product?.handle || 'product'}`;
    });

    engine.registerFilter('collection_url', (collection: { url?: string; handle?: string }) => {
      return collection?.url || `/collections/${collection?.handle || 'collection'}`;
    });

    engine.registerFilter('url_for_type', (type: string) => {
      return `/collections/types?q=${encodeURIComponent(type)}`;
    });

    engine.registerFilter('url_for_vendor', (vendor: string) => {
      return `/collections/vendors?q=${encodeURIComponent(vendor)}`;
    });

    engine.registerFilter('where', (array: unknown[], key: string, value: unknown) => {
      if (!Array.isArray(array)) return [];
      return array.filter((item) => {
        const record = item as Record<string, unknown>;
        return record[key] === value;
      });
    });

    engine.registerFilter('times', (a: number, b: number) => a * b);
    engine.registerFilter('divided_by', (a: number, b: number) => Math.floor(a / b));
    engine.registerFilter('modulo', (a: number, b: number) => a % b);

    // Register array filters (first, last, map, compact, concat, etc.)
    Object.entries(arrayFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register string filters (escape_once, newline_to_br, strip_html, etc.)
    Object.entries(stringFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register math filters (abs, at_least, at_most, ceil, floor, round, plus, minus)
    Object.entries(mathFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register color filters (replace stubs with real implementations)
    Object.entries(colorFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register media filters (image_tag, video_tag, media_tag, etc.)
    Object.entries(mediaFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register font filters (font_face, font_url, font_modify)
    Object.entries(fontFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register metafield filters (metafield_tag, metafield_text)
    Object.entries(metafieldFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register utility filters (default, highlight, time_tag, weight_with_unit, etc.)
    Object.entries(utilityFilters).forEach(([name, fn]) => {
      engine.registerFilter(name, fn as (...args: unknown[]) => unknown);
    });

    // Register all Shopify-specific tags (form, paginate, section, render, comment, style, etc.)
    registerShopifyTags(engine);
  }, []);

  const render = useCallback(async (
    template: string,
    settings: PreviewSettings,
    blocks: BlockInstance[] = [],
    mockData: Record<string, unknown> = {}
  ): Promise<RenderResult> => {
    if (!engineRef.current) {
      throw new Error('Liquid engine not initialized');
    }

    setIsRendering(true);
    setError(null);

    try {
      // Strip {% schema %}...{% endschema %} blocks (not renderable)
      const processedTemplate = template.replace(/\{%\s*schema\s*%\}[\s\S]*?\{%\s*endschema\s*%\}/gi, '');

      // Build section settings by merging primitive values with resource drops
      const settingsResourceDrops = mockData.settingsResourceDrops as Record<string, unknown> | undefined;
      const mergedSettings = settingsResourceDrops
        ? { ...settings, ...settingsResourceDrops }
        : settings;

      // Build render context with section object including blocks
      const context = {
        ...mockData,
        section: {
          id: 'preview-section',
          settings: mergedSettings,
          blocks: blocks.map(block => new BlockDrop(block))
        },
        settings: mergedSettings
      };

      // Render the full template (including {% style %} tags which output <style data-shopify-style>)
      const renderedHtml = await engineRef.current.parseAndRender(processedTemplate, context);

      // Extract CSS from all <style> tags (including data-shopify-style from {% style %} tag)
      const allStyles = renderedHtml.match(/<style[^>]*>([\s\S]*?)<\/style>/gi);
      const css = allStyles?.map((s: string) => s.replace(/<\/?style[^>]*>/gi, '')).join('\n') || '';

      // Remove all style tags from HTML output
      const html = renderedHtml.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');

      return { html, css };
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Render failed';
      setError(errorMsg);
      throw err;
    } finally {
      setIsRendering(false);
    }
  }, []);

  return { render, isRendering, error };
}
</file>

</files>
